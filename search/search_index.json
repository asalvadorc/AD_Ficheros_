{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Ficheros","title":"Acceso a Datos - Ficheros"},{"location":"#ficheros","text":"","title":"Ficheros"},{"location":"Componentes/","text":"Programaci\u00f3n Orientada a Componentes (POC) La programaci\u00f3n orientada a componentes (POC) es un paradigma que se centra en el dise\u00f1o y construcci\u00f3n de aplicaciones mediante componentes reutilizables e independientes, que encapsulan tanto datos como l\u00f3gica de negocio y se comunican entre s\u00ed a trav\u00e9s de interfaces bien definidas. Se trata de clases o m\u00f3dulos que encapsulan la lectura, escritura, conversi\u00f3n o gesti\u00f3n de datos en distintos formatos como CSV, JSON o XML. En el contexto de la gesi\u00f3n de ficheros, un componente puede ser una clase con una \u00fanica responsabilidad clara y una interfaz definida. Por ejemplo: LectorCSV: componente que sabe leer archivos .csv EscritorJSON: componente que convierte objetos a JSON y los guarda RepositorioAlumnos: componente que encapsula acceso a datos almacenados en un fichero, sea cual sea el formato Ejemplo 1: Componente RepositorioAlumnosCSV Encapsula acceso a datos de alumnos en un archivo CSV data class Alumno(val nombre: String, val nota: Int) class RepositorioAlumnosCSV(private val fichero: String) { fun cargar(): List<Alumno> { return File(fichero).readLines().mapNotNull { linea -> val partes = linea.split(\";\") if (partes.size == 2) Alumno(partes[0], partes[1].toInt()) else null } } fun guardar(alumnos: List<Alumno>) { File(fichero).printWriter().use { writer -> alumnos.forEach { writer.println(\"${it.nombre};${it.nota}\") } } } } Componente reutilizable para cualquier lista de alumnos CSV. Ejemplo 2: Componente GestorJSON Leer y escribir objetos Kotlin desde/hacia ficheros .json con kotlinx.serialization import kotlinx.serialization.* import kotlinx.serialization.json.* import java.io.File @Serializable data class Producto(val nombre: String, val precio: Double) class GestorJSON<T>(private val serializer: KSerializer<T>) { fun leer(path: String): T { val contenido = File(path).readText() return Json.decodeFromString(serializer, contenido) } fun guardar(objeto: T, path: String) { val json = Json.encodeToString(serializer, objeto) File(path).writeText(json) } } val gestor = GestorJSON(Producto.serializer()) gestor.guardar(Producto(\"Teclado\", 29.99), \"producto.json\") Ejemplo 3: Componente ConversorCSVaJSON Transformar ficheros CSV a JSON (ideal como utilitario o servicio) import kotlinx.serialization.* import kotlinx.serialization.json.* import java.io.File @Serializable data class Alumno(val nombre: String, val nota: Int) class ConversorCSVaJSON { fun convertir(csvPath: String, jsonPath: String) { val alumnos = File(csvPath).readLines().mapNotNull { val partes = it.split(\";\") if (partes.size == 2) Alumno(partes[0], partes[1].toInt()) else null } val json = Json.encodeToString(alumnos) File(jsonPath).writeText(json) } } Ejemplo 4: Componente de persistencia XML Guardar una lista de objetos en un archivo XML (usando JDOM2) import org.jdom2.* import org.jdom2.output.XMLOutputter import org.jdom2.output.Format import java.io.File data class Alumno(val nombre: String, val nota: Int) class EscritorXML { fun guardar(alumnos: List<Alumno>, path: String) { val raiz = Element(\"alumnos\") alumnos.forEach { val alumnoElem = Element(\"alumno\") alumnoElem.addContent(Element(\"nombre\").setText(it.nombre)) alumnoElem.addContent(Element(\"nota\").setText(it.nota.toString())) raiz.addContent(alumnoElem) } val doc = Document(raiz) XMLOutputter().apply { format = Format.getPrettyFormat() output(doc, File(path).outputStream()) } } } Supongamos una aplicaci\u00f3n que: Lee alumnos desde un CSV Les aplica una transformaci\u00f3n (por ejemplo, sumar +1 a todas las notas) Guarda los resultados en JSON fun main() { val repoCSV = RepositorioAlumnosCSV(\"alumnos.csv\") val alumnos = repoCSV.cargar().map { it.copy(nota = it.nota + 1) } val gestorJSON = GestorJSON(ListSerializer(Alumno.serializer())) gestorJSON.guardar(alumnos, \"alumnos.json\") }","title":"Programaci\u00f3n Orientada a Componentes (POC)"},{"location":"Componentes/#programacion-orientada-a-componentes-poc","text":"La programaci\u00f3n orientada a componentes (POC) es un paradigma que se centra en el dise\u00f1o y construcci\u00f3n de aplicaciones mediante componentes reutilizables e independientes, que encapsulan tanto datos como l\u00f3gica de negocio y se comunican entre s\u00ed a trav\u00e9s de interfaces bien definidas. Se trata de clases o m\u00f3dulos que encapsulan la lectura, escritura, conversi\u00f3n o gesti\u00f3n de datos en distintos formatos como CSV, JSON o XML. En el contexto de la gesi\u00f3n de ficheros, un componente puede ser una clase con una \u00fanica responsabilidad clara y una interfaz definida. Por ejemplo: LectorCSV: componente que sabe leer archivos .csv EscritorJSON: componente que convierte objetos a JSON y los guarda RepositorioAlumnos: componente que encapsula acceso a datos almacenados en un fichero, sea cual sea el formato Ejemplo 1: Componente RepositorioAlumnosCSV Encapsula acceso a datos de alumnos en un archivo CSV data class Alumno(val nombre: String, val nota: Int) class RepositorioAlumnosCSV(private val fichero: String) { fun cargar(): List<Alumno> { return File(fichero).readLines().mapNotNull { linea -> val partes = linea.split(\";\") if (partes.size == 2) Alumno(partes[0], partes[1].toInt()) else null } } fun guardar(alumnos: List<Alumno>) { File(fichero).printWriter().use { writer -> alumnos.forEach { writer.println(\"${it.nombre};${it.nota}\") } } } } Componente reutilizable para cualquier lista de alumnos CSV. Ejemplo 2: Componente GestorJSON Leer y escribir objetos Kotlin desde/hacia ficheros .json con kotlinx.serialization import kotlinx.serialization.* import kotlinx.serialization.json.* import java.io.File @Serializable data class Producto(val nombre: String, val precio: Double) class GestorJSON<T>(private val serializer: KSerializer<T>) { fun leer(path: String): T { val contenido = File(path).readText() return Json.decodeFromString(serializer, contenido) } fun guardar(objeto: T, path: String) { val json = Json.encodeToString(serializer, objeto) File(path).writeText(json) } } val gestor = GestorJSON(Producto.serializer()) gestor.guardar(Producto(\"Teclado\", 29.99), \"producto.json\") Ejemplo 3: Componente ConversorCSVaJSON Transformar ficheros CSV a JSON (ideal como utilitario o servicio) import kotlinx.serialization.* import kotlinx.serialization.json.* import java.io.File @Serializable data class Alumno(val nombre: String, val nota: Int) class ConversorCSVaJSON { fun convertir(csvPath: String, jsonPath: String) { val alumnos = File(csvPath).readLines().mapNotNull { val partes = it.split(\";\") if (partes.size == 2) Alumno(partes[0], partes[1].toInt()) else null } val json = Json.encodeToString(alumnos) File(jsonPath).writeText(json) } } Ejemplo 4: Componente de persistencia XML Guardar una lista de objetos en un archivo XML (usando JDOM2) import org.jdom2.* import org.jdom2.output.XMLOutputter import org.jdom2.output.Format import java.io.File data class Alumno(val nombre: String, val nota: Int) class EscritorXML { fun guardar(alumnos: List<Alumno>, path: String) { val raiz = Element(\"alumnos\") alumnos.forEach { val alumnoElem = Element(\"alumno\") alumnoElem.addContent(Element(\"nombre\").setText(it.nombre)) alumnoElem.addContent(Element(\"nota\").setText(it.nota.toString())) raiz.addContent(alumnoElem) } val doc = Document(raiz) XMLOutputter().apply { format = Format.getPrettyFormat() output(doc, File(path).outputStream()) } } } Supongamos una aplicaci\u00f3n que: Lee alumnos desde un CSV Les aplica una transformaci\u00f3n (por ejemplo, sumar +1 a todas las notas) Guarda los resultados en JSON fun main() { val repoCSV = RepositorioAlumnosCSV(\"alumnos.csv\") val alumnos = repoCSV.cargar().map { it.copy(nota = it.nota + 1) } val gestorJSON = GestorJSON(ListSerializer(Alumno.serializer())) gestorJSON.guardar(alumnos, \"alumnos.json\") }","title":"Programaci\u00f3n Orientada a Componentes (POC)"},{"location":"RA_CE/","text":"RA1. Desarrolla aplicaciones que gestionan informaci\u00f3n almacenada en ficheros identificando el campo de aplicaci\u00f3n de los mismos y utilizando clases espec\u00edficas. Contenidos vs Criterios de Evaluaci\u00f3n N\u00ba Contenido Did\u00e1ctico Criterios de Evaluaci\u00f3n Relacionados 1 Introducci\u00f3n a los ficheros y su aplicaci\u00f3n - 2 Acceso al sistema de archivos ( File , Path , etc.) a) Clases para gesti\u00f3n de ficheros y directorios 3 Formas de acceso: secuencial vs aleatorio b) Ventajas e inconvenientes del acceso 4 Lectura de ficheros c) Clases para recuperar informaci\u00f3n 5 Escritura en ficheros d) Clases para almacenar informaci\u00f3n 6 Conversi\u00f3n entre formatos (JSON, XML, binario) e) Clases para realizar conversiones 7 Gesti\u00f3n de excepciones ( try-catch , use ) f) Gesti\u00f3n de errores y validaciones 8 Pruebas y documentaci\u00f3n de aplicaciones g) Pruebas y documentaci\u00f3n","title":"RA y CE"},{"location":"RA_CE/#ra1-desarrolla-aplicaciones-que-gestionan-informacion-almacenada-en-ficheros-identificando-el-campo-de-aplicacion-de-los-mismos-y-utilizando-clases-especificas","text":"Contenidos vs Criterios de Evaluaci\u00f3n N\u00ba Contenido Did\u00e1ctico Criterios de Evaluaci\u00f3n Relacionados 1 Introducci\u00f3n a los ficheros y su aplicaci\u00f3n - 2 Acceso al sistema de archivos ( File , Path , etc.) a) Clases para gesti\u00f3n de ficheros y directorios 3 Formas de acceso: secuencial vs aleatorio b) Ventajas e inconvenientes del acceso 4 Lectura de ficheros c) Clases para recuperar informaci\u00f3n 5 Escritura en ficheros d) Clases para almacenar informaci\u00f3n 6 Conversi\u00f3n entre formatos (JSON, XML, binario) e) Clases para realizar conversiones 7 Gesti\u00f3n de excepciones ( try-catch , use ) f) Gesti\u00f3n de errores y validaciones 8 Pruebas y documentaci\u00f3n de aplicaciones g) Pruebas y documentaci\u00f3n","title":"RA1. Desarrolla aplicaciones que gestionan informaci\u00f3n almacenada en ficheros identificando el campo de aplicaci\u00f3n de los mismos y utilizando clases espec\u00edficas."},{"location":"Resumen/","text":"\ud83d\udcd8 Gu\u00eda resumen: Lectura y escritura de distintos formatos de ficheros en Kotlin \ud83d\udcc1 Tipos de ficheros y m\u00e9todos de acceso Tipo de fichero Lectura Escritura Comentario Texto (l\u00edneas) Files.readAllLines Files.write(Path, List<String>) Carga todo en memoria Files.newBufferedReader Files.newBufferedWriter M\u00e1s eficiente para archivos grandes Files.readString (Java 11+) Files.writeString Lectura/escritura completa como bloque Binario Files.readAllBytes Files.write(Path, ByteArray) Lee y escribe bytes puros Files.newInputStream Files.newOutputStream Flujo de bytes directo Binario estructurado FileChannel.read(ByteBuffer) FileChannel.write(ByteBuffer) Acceso secuencial o aleatorio con ByteBuffer SeekableByteChannel.read(...) SeekableByteChannel.write(...) M\u00e1s flexible (se puede posicionar) ByteBuffer.get*() ByteBuffer.put*() Tipos primitivos Acceso aleatorio FileChannel.position(offset) FileChannel.position(offset) Permite saltar a posiciones concretas Imagen ImageIO.read(Path/File) ImageIO.write(BufferedImage, ...) Usa javax.imageio.ImageIO \ud83d\udcbe Serializaci\u00f3n de objetos Herramienta Uso principal Notas clave Serializable (Java) Marca una clase como serializable Necesario para ObjectOutputStream ObjectOutputStream Serializa y guarda un objeto Solo con clases Serializable ObjectInputStream Lee un objeto serializado Funciona solo con objetos serializados en Java transient Evita serializar ciertos atributos \u00datil para datos temporales o sensibles writeObject/readObject M\u00e9todos opcionales para personalizar Control sobre la serializaci\u00f3n binaria \ud83d\udd01 Conversi\u00f3n de formatos Formato Librer\u00eda Uso principal CSV OpenCSV, Kotlin-CSV Lectura y escritura de archivos CSV JSON kotlinx.serialization Ligero, multiplataforma, integrado con Kotlin JSON Jackson Muy usado en backend Java y con Spring Boot XML DOM API ( javax.xml ) Bajo nivel, control manual de nodos y estructura XML Jackson Conversi\u00f3n directa entre objetos y XML con anotaciones \u2699\ufe0f M\u00e9todos de OpenCSV (CSV) Lectura con OpenCSV Clase / M\u00e9todo \u00bfQu\u00e9 hace? Ejemplo b\u00e1sico CSVReader(FileReader) Crea un lector de archivos CSV. val reader = CSVReader(FileReader(\"archivo.csv\")) readAll() Lee todo el contenido como List<Array<String>> . val filas = reader.readAll() readNext() Lee una fila como Array<String> . val fila = reader.readNext() close() Cierra el lector. reader.close() CSVReaderBuilder(...) Permite configurar el lector: separador, comillas, salto de l\u00ednea, etc. CSVReaderBuilder(FileReader(...)).withSeparator(';') withSkipLines(n) Omite las primeras n l\u00edneas (\u00fatil para saltar cabeceras). withSkipLines(1) build() Construye el lector configurado. build() Escritura con OpenCSV Clase / M\u00e9todo \u00bfQu\u00e9 hace? Ejemplo b\u00e1sico CSVWriter(FileWriter) Crea un escritor CSV b\u00e1sico. val writer = CSVWriter(FileWriter(\"archivo.csv\")) writeNext(Array<String>) Escribe una l\u00ednea al CSV. writer.writeNext(arrayOf(\"Ana\", \"30\")) writeAll(List<Array<String>>) Escribe m\u00faltiples filas al CSV. writer.writeAll(listaFilas) flush() Fuerza la escritura del buffer. writer.flush() close() Cierra el escritor. writer.close() CSVWriterBuilder(...) Permite configurar el escritor: delimitador, comillas, escape, etc. CSVWriterBuilder(FileWriter(...)).withSeparator(';') withQuoteChar(c) Define el car\u00e1cter de comillas (por defecto es \" ). withQuoteChar(CSVWriter.NO_QUOTE_CHARACTER) withEscapeChar(c) Define el car\u00e1cter de escape (por defecto \\ ). withEscapeChar('\\\\') withLineEnd(e) Define el car\u00e1cter de fin de l\u00ednea. withLineEnd(\"\\n\") build() Construye el escritor configurado. build() \ud83e\uddf0 M\u00e9todos de kotlinx.serialization M\u00e9todo \u00bfQu\u00e9 hace? Ejemplo b\u00e1sico Json.encodeToString(obj) Objeto \u2192 JSON como String Json.encodeToString(persona) Json.decodeFromString<T>(json) JSON como String \u2192 Objeto Kotlin Json.decodeFromString<Persona>(json) Json.encodeToJsonElement(obj) Objeto \u2192 JsonElement (estructura de \u00e1rbol) val elem = Json.encodeToJsonElement(persona) Json.decodeFromJsonElement(elem) JsonElement \u2192 Objeto Kotlin val persona = Json.decodeFromJsonElement<Persona>(elem) Json.parseToJsonElement(string) Cadena JSON \u2192 \u00e1rbol JsonElement sin mapear val elem = Json.parseToJsonElement(json) \ud83e\udde9 M\u00e9todos de Jackson M\u00e9todo \u00bfQu\u00e9 hace? Ejemplo readValue(String, Class) JSON \u2192 objeto mapper.readValue(json, Persona::class.java) readValue(File, Class) Archivo JSON \u2192 objeto mapper.readValue(File(\"persona.json\"), ...) readTree(String) JSON \u2192 JsonNode (sin mapeo a clase) val node = mapper.readTree(json) writeValue(File, Object) Objeto \u2192 archivo JSON mapper.writeValue(File(\"salida.json\"), persona) writeValueAsString(Object) Objeto \u2192 cadena JSON val json = mapper.writeValueAsString(persona) writeValueAsBytes(Object) Objeto \u2192 bytes JSON val bytes = mapper.writeValueAsBytes(persona) writerWithDefaultPrettyPrinter() Formatea JSON de salida .writerWithDefaultPrettyPrinter().writeValue(...) \ud83d\udcda Clases \u00fatiles para XML con JDOM Clase Funci\u00f3n SAXBuilder Lee y convierte un archivo XML en Document Document Representa todo el documento XML Element Representa una etiqueta o nodo XML Attribute Atributo de un Element XMLOutputter Convierte el documento XML a texto \ud83e\udde0 Recomendaciones seg\u00fan situaci\u00f3n Situaci\u00f3n Mejor opci\u00f3n Motivo principal Solo necesitas JSON kotlinx.serialization Ligero, r\u00e1pido, oficial para Kotlin Necesitas JSON + XML (complejo) Jackson M\u00e1s completo y flexible para ambos formatos Proyecto en Java o Spring Boot Jackson Integraci\u00f3n fluida Proyecto Multiplataforma Kotlin kotlinx.serialization Compatible con JS, JVM y Native","title":"Resumen"},{"location":"Resumen/#guia-resumen-lectura-y-escritura-de-distintos-formatos-de-ficheros-en-kotlin","text":"","title":"\ud83d\udcd8 Gu\u00eda resumen: Lectura y escritura de distintos formatos de ficheros en Kotlin"},{"location":"Resumen/#tipos-de-ficheros-y-metodos-de-acceso","text":"Tipo de fichero Lectura Escritura Comentario Texto (l\u00edneas) Files.readAllLines Files.write(Path, List<String>) Carga todo en memoria Files.newBufferedReader Files.newBufferedWriter M\u00e1s eficiente para archivos grandes Files.readString (Java 11+) Files.writeString Lectura/escritura completa como bloque Binario Files.readAllBytes Files.write(Path, ByteArray) Lee y escribe bytes puros Files.newInputStream Files.newOutputStream Flujo de bytes directo Binario estructurado FileChannel.read(ByteBuffer) FileChannel.write(ByteBuffer) Acceso secuencial o aleatorio con ByteBuffer SeekableByteChannel.read(...) SeekableByteChannel.write(...) M\u00e1s flexible (se puede posicionar) ByteBuffer.get*() ByteBuffer.put*() Tipos primitivos Acceso aleatorio FileChannel.position(offset) FileChannel.position(offset) Permite saltar a posiciones concretas Imagen ImageIO.read(Path/File) ImageIO.write(BufferedImage, ...) Usa javax.imageio.ImageIO","title":"\ud83d\udcc1 Tipos de ficheros y m\u00e9todos de acceso"},{"location":"Resumen/#serializacion-de-objetos","text":"Herramienta Uso principal Notas clave Serializable (Java) Marca una clase como serializable Necesario para ObjectOutputStream ObjectOutputStream Serializa y guarda un objeto Solo con clases Serializable ObjectInputStream Lee un objeto serializado Funciona solo con objetos serializados en Java transient Evita serializar ciertos atributos \u00datil para datos temporales o sensibles writeObject/readObject M\u00e9todos opcionales para personalizar Control sobre la serializaci\u00f3n binaria","title":"\ud83d\udcbe Serializaci\u00f3n de objetos"},{"location":"Resumen/#conversion-de-formatos","text":"Formato Librer\u00eda Uso principal CSV OpenCSV, Kotlin-CSV Lectura y escritura de archivos CSV JSON kotlinx.serialization Ligero, multiplataforma, integrado con Kotlin JSON Jackson Muy usado en backend Java y con Spring Boot XML DOM API ( javax.xml ) Bajo nivel, control manual de nodos y estructura XML Jackson Conversi\u00f3n directa entre objetos y XML con anotaciones","title":"\ud83d\udd01 Conversi\u00f3n de formatos"},{"location":"Resumen/#metodos-de-opencsv-csv","text":"Lectura con OpenCSV Clase / M\u00e9todo \u00bfQu\u00e9 hace? Ejemplo b\u00e1sico CSVReader(FileReader) Crea un lector de archivos CSV. val reader = CSVReader(FileReader(\"archivo.csv\")) readAll() Lee todo el contenido como List<Array<String>> . val filas = reader.readAll() readNext() Lee una fila como Array<String> . val fila = reader.readNext() close() Cierra el lector. reader.close() CSVReaderBuilder(...) Permite configurar el lector: separador, comillas, salto de l\u00ednea, etc. CSVReaderBuilder(FileReader(...)).withSeparator(';') withSkipLines(n) Omite las primeras n l\u00edneas (\u00fatil para saltar cabeceras). withSkipLines(1) build() Construye el lector configurado. build() Escritura con OpenCSV Clase / M\u00e9todo \u00bfQu\u00e9 hace? Ejemplo b\u00e1sico CSVWriter(FileWriter) Crea un escritor CSV b\u00e1sico. val writer = CSVWriter(FileWriter(\"archivo.csv\")) writeNext(Array<String>) Escribe una l\u00ednea al CSV. writer.writeNext(arrayOf(\"Ana\", \"30\")) writeAll(List<Array<String>>) Escribe m\u00faltiples filas al CSV. writer.writeAll(listaFilas) flush() Fuerza la escritura del buffer. writer.flush() close() Cierra el escritor. writer.close() CSVWriterBuilder(...) Permite configurar el escritor: delimitador, comillas, escape, etc. CSVWriterBuilder(FileWriter(...)).withSeparator(';') withQuoteChar(c) Define el car\u00e1cter de comillas (por defecto es \" ). withQuoteChar(CSVWriter.NO_QUOTE_CHARACTER) withEscapeChar(c) Define el car\u00e1cter de escape (por defecto \\ ). withEscapeChar('\\\\') withLineEnd(e) Define el car\u00e1cter de fin de l\u00ednea. withLineEnd(\"\\n\") build() Construye el escritor configurado. build()","title":"\u2699\ufe0f M\u00e9todos de OpenCSV (CSV)"},{"location":"Resumen/#metodos-de-kotlinxserialization","text":"M\u00e9todo \u00bfQu\u00e9 hace? Ejemplo b\u00e1sico Json.encodeToString(obj) Objeto \u2192 JSON como String Json.encodeToString(persona) Json.decodeFromString<T>(json) JSON como String \u2192 Objeto Kotlin Json.decodeFromString<Persona>(json) Json.encodeToJsonElement(obj) Objeto \u2192 JsonElement (estructura de \u00e1rbol) val elem = Json.encodeToJsonElement(persona) Json.decodeFromJsonElement(elem) JsonElement \u2192 Objeto Kotlin val persona = Json.decodeFromJsonElement<Persona>(elem) Json.parseToJsonElement(string) Cadena JSON \u2192 \u00e1rbol JsonElement sin mapear val elem = Json.parseToJsonElement(json)","title":"\ud83e\uddf0 M\u00e9todos de kotlinx.serialization"},{"location":"Resumen/#metodos-de-jackson","text":"M\u00e9todo \u00bfQu\u00e9 hace? Ejemplo readValue(String, Class) JSON \u2192 objeto mapper.readValue(json, Persona::class.java) readValue(File, Class) Archivo JSON \u2192 objeto mapper.readValue(File(\"persona.json\"), ...) readTree(String) JSON \u2192 JsonNode (sin mapeo a clase) val node = mapper.readTree(json) writeValue(File, Object) Objeto \u2192 archivo JSON mapper.writeValue(File(\"salida.json\"), persona) writeValueAsString(Object) Objeto \u2192 cadena JSON val json = mapper.writeValueAsString(persona) writeValueAsBytes(Object) Objeto \u2192 bytes JSON val bytes = mapper.writeValueAsBytes(persona) writerWithDefaultPrettyPrinter() Formatea JSON de salida .writerWithDefaultPrettyPrinter().writeValue(...)","title":"\ud83e\udde9 M\u00e9todos de Jackson"},{"location":"Resumen/#clases-utiles-para-xml-con-jdom","text":"Clase Funci\u00f3n SAXBuilder Lee y convierte un archivo XML en Document Document Representa todo el documento XML Element Representa una etiqueta o nodo XML Attribute Atributo de un Element XMLOutputter Convierte el documento XML a texto","title":"\ud83d\udcda Clases \u00fatiles para XML con JDOM"},{"location":"Resumen/#recomendaciones-segun-situacion","text":"Situaci\u00f3n Mejor opci\u00f3n Motivo principal Solo necesitas JSON kotlinx.serialization Ligero, r\u00e1pido, oficial para Kotlin Necesitas JSON + XML (complejo) Jackson M\u00e1s completo y flexible para ambos formatos Proyecto en Java o Spring Boot Jackson Integraci\u00f3n fluida Proyecto Multiplataforma Kotlin kotlinx.serialization Compatible con JS, JVM y Native","title":"\ud83e\udde0 Recomendaciones seg\u00fan situaci\u00f3n"},{"location":"T1_Sistema_de_ficheros/NIO_AccesoFicheros/","text":"Acceso al sistema de ficheros. Java.nio Proyecto Ficheros Para probar y organizar los ejemplos propuestos en esta parte del temario, crearemos en IntelliJ un proyecto llamado Ficheros . Dentro de este proyecto crearemos tres paquetes ( sistema , contenido y formatos ) para organizar los diferentes ejemplos, que en cada ocasi\u00f3n se indicar\u00e1 en que paquete deben ubicarse. | Durante muchos a\u00f1os se ha utilizado la librer\u00eda java.io para trabajar con ficheros en el mundo Java. Se trata de un API muy potente y flexible que nos permite realizar casi cualquier tipo de operaci\u00f3n. Sin embargo es una API complicada de entender. Java.nio (New IO) es una nueva API disponible desde Java7 que nos permite mejorar el rendimiento, as\u00ed como simplificar el manejo de muchas operaciones. Java.nio define interfaces y clases para que la m\u00e1quina virtual Java tenga acceso a archivos, atributos de archivos y sistemas de archivos. Aunque dicho API comprende numerosas clases, solo existen unas pocas de ellas que sirven de puntos de entrada al API, lo que simplifica considerablemente su manejo. La interfaz java.nio.file.Path representa un path, y las clases que implementen esta interfaz puede utilizarse para localizar ficheros en el sistema de ficheros. Nos permite manejar rutas al estilo GNU/Linux y rutas al estilo Windows dependiendo del SO en el que estemos trabajando. La clase java.nio.file.Files es el otro punto de entrada a la librer\u00eda de ficheros de Java. Es la que nos permite manejar ficheros reales del disco desde Java. Clases para la gesit\u00f3n de ficheros Paths : Crea objetos Path desde cadenas de texto Path : Representa rutas a archivos o directorios Files : Permite operaciones sobre archivos usando Path Ejemplos Los siguientes ejemplos se incluir\u00e1n en el paquete sistema dentro del proyecto Ficheros . \ud83d\udd39Paths La clase Paths es una clase de utilidad que proporciona m\u00e9todos est\u00e1ticos para crear objetos Path , que luego puedes usar con m\u00e9todos de Files . M\u00e9todo Descripci\u00f3n get(String first, String... ) Crea un objeto Path a partir de una o m\u00e1s cadenas. get(URI uri) Crea un Path desde un URI que debe ser del esquema file:///. El uso de Paths.get(...) en Java (o Kotlin) no implica que el archivo o directorio exista. Este m\u00e9todo simplemente crea una instancia de Path que representa una ruta en el sistema de archivos, pero no accede al disco ni verifica su existencia. \ud83d\udda5\ufe0f Ejemplo_get.kt import java.nio.file.Path import java.nio.file.Paths fun main() { val path1: Path = Paths.get(\"documentos\", \"archivo.txt\") val path2: Path = Paths.get(\"C:\", \"usuarios\", \"nombre\", \"archivo.txt\") println(\"Ruta 1: $path1\") println(\"Ruta 2: $path2\") } \ud83d\udda5\ufe0f Ejemplo_uri.kt import java.net.URI import java.nio.file.Path import java.nio.file.Paths fun main() { val uri = URI(\"file:///C:/usuarios/nombre/archivo.txt\") val path: Path = Paths.get(uri) println(\"Ruta a partir de URI: $path\") } \ud83d\udd39Path La clase Path Se utiliza junto con la clase Files para realizar operaciones como lectura, escritura, copia, o eliminaci\u00f3n de archivos. La forma mas sencilla de construir un objeto que cumpla la interfaz Path es a partir de la clase java.nio.file.Paths , que tiene m\u00e9todos est\u00e1ticos que retornan objetos Path a partir de una representaci\u00f3n tipo String del path deseado. Por supuesto, no es necesario que los ficheros existan de verdad en el disco duro para que se puedan crear los objetos Path correspondientes. Un objeto Path puede representarse de dos formas: Ruta absoluta val path = Paths.get(\"/home/usuario/archivo.txt\") Ruta relativa val path = Paths.get(\"documentos/ejemplo.txt\") println(path.toAbsolutePath()) Las operaciones y m\u00e9todos principales que se pueden hacer con Path son: M\u00e9todo Qu\u00e9 devuelve Descripci\u00f3n .startsWith(Path other) Boolean Devuelve true si el path empieza por el path dado. .endsWith(Path other) Boolean Devuelve true si el path termina con el path dado. .getParent() Path? Devuelve el path padre (superior) o null si no tiene. .getRoot() Path? Devuelve el componente ra\u00edz ( / , C:\\ , etc.) o null si no existe. .iterator() Iterator<Path> Permite iterar sobre cada parte del path (carpetas y nombre final). .toString() String Devuelve el path como texto. .toAbsolutePath() Path Devuelve el path completo desde la ra\u00edz del sistema. .resolve(Path/String) Path Une dos partes de un path de forma correcta, manejando barras autom\u00e1ticamente. .toFile() java.io.File Convierte el Path en un File de la API tradicional de Java ( java.io ). \ud83d\udda5\ufe0f Ejemplo_Path.kt import java.nio.file.Path import java.nio.file.Paths fun main() { val path: Path = Paths.get(\"documentos/ejemplo.txt\") println(\"toString(): ${path}\") println(\"toAbsolutePath(): ${path.toAbsolutePath()}\") println(\"getFileName(): ${path.fileName}\") println(\"getParent(): ${path.parent}\") println(\"getRoot(): ${path.root}\") val otroPath: Path = Paths.get(\"imagenes/foto.png\") println(\"resolve(): ${path.resolve(otroPath)}\") val relativo: Path = path.relativize(Paths.get(\"documentos/otroArchivo.txt\")) println(\"relativize(): $relativo\") val rutaNormalizada: Path = Paths.get(\"carpeta/../archivo.txt\").normalize() println(\"normalize(): $rutaNormalizada\") println(\"startsWith(\\\"documentos\\\"): ${path.startsWith(\"documentos\")}\") println(\"endsWith(\\\"ejemplo.txt\\\"): ${path.endsWith(\"ejemplo.txt\")}\") } \ud83d\udd39Files La clase Files es el otro punto de entrada a la librer\u00eda de ficheros de Java. Es la que nos permite manejar ficheros reales del disco desde Java. Esta clase tiene m\u00e9todos est\u00e1ticos para el manejo de ficheros, los m\u00e9todos de la clase Files trabajan sobre objetos Path . Muchos de estos m\u00e9todos devuelven streams , lo que permite procesar archivos y directorios de forma eficiente y elegante. En Java (y tambi\u00e9n en Kotlin), un Stream es una secuencia de elementos que permite realizar operaciones funcionales (como map, filter, forEach, etc.) sobre datos de forma eficiente y fluida, sin necesidad de estructuras intermedias ni bucles expl\u00edcitos. Algunos m\u00e9todo de Files utilizan o devuelven Streams . Las operaciones y m\u00e9todos principales a realizar con Files son: M\u00e9todo Qu\u00e9 devuelve Descripci\u00f3n list(Path) Stream<Path> Lista contenido directo (no recursivo) del directorio. .walk(Path) Stream<Path> Recorre directorios de forma recursiva. .find(... ) Stream<Path> Busca elementos que cumplan una condici\u00f3n. .lines(Path) Stream<String> Devuelve las l\u00edneas de un archivo de texto. .exists(Path) Boolean Verifica si el archivo existe. .isDirectory(Path) Boolean Verifica si es un directorio. .isRegularFile(Path) Boolean Verifica si es un archivo normal. .isReadable(Path) Boolean Verifica si se puede leer. .createFile(Path) Path Crea un archivo vac\u00edo. .createDirectory(Path) Path Crea un directorio. .createDirectories(Path) Path Crea directorios y subdirectorios necesarios. .delete(Path) void Elimina un archivo o directorio. .deleteIfExists(Path) Boolean Elimina si existe. .move(Path, Path) Path Mueve un archivo o directorio. .copy(Path, Path) Path Copia un archivo o directorio. .size(Path) Long Tama\u00f1o del archivo. .getLastModifiedTime(Path) FileTime \u00daltima modificaci\u00f3n. .getOwner(Path) UserPrincipal Devuelve el propietario. .getAttribute(Path, String) Object Devuelve un atributo espec\u00edfico. \ud83d\udda5\ufe0f Ejemplo_permisos.kt : existencia y comprobaci\u00f3n de permisos import java.nio.file.Path import java.nio.file.Paths import java.nio.file.Files fun main() { val path: Path = Paths.get(\"documentos/ejemplo.txt\") println(\"path = $path\") println(\"exists = ${Files.exists(path)}\") println(\"readable = ${Files.isReadable(path)}\") println(\"writable = ${Files.isWritable(path)}\") println(\"executable = ${Files.isExecutable(path)}\") } \ud83d\udda5\ufe0f Ejemplo_creardirectorio.kt : crear un directorio import java.nio.file.Path import java.nio.file.Paths import java.nio.file.Files import java.nio.file.FileAlreadyExistsException import java.io.IOException fun main() { val path: Path = Paths.get(\"documentos\") try { val newDir = Files.createDirectory(path) println(\"Directorio creado en: $newDir\") } catch (e: FileAlreadyExistsException) { println(\"El directorio ya existe: $path\") } catch (e: IOException) { println(\"Error de entrada/salida: ${e.message}\") e.printStackTrace() } } \ud83d\udda5\ufe0f Ejemplo_borrardirectorio.kt : elimina un directorio import java.nio.file.Files import java.nio.file.Path import java.nio.file.Paths fun main() { val directorio: Path = Paths.get(\"c:/mi_directorio\") // Si ya existe, lo eliminamos if (Files.exists(directorio)) { println(\"El directorio ya existe. Borr\u00e1ndolo...\") Files.delete(directorio) } } Gesti\u00f3n de errores y validaciones El m\u00e9todo delete(Path) borra el fichero o directorio o lanza una excepci\u00f3n si el borrado falla. El siguiente ejemplo muestra como capturar y gestionar las excepciones que pueden producirse en el borrado. Si el fichero o directorio no existe, la excepci\u00f3n que se produce es NoSuchFileException . Los sucesivos cath permiten determinar por que ha fallado el borrado: import java.nio.file.* import java.io.IOException fun main() { val path = Paths.get(\"c:/mi_directorio\") try { Files.delete(path) } catch (e: NoSuchFileException) { System.err.printf(\"%s: no such file or directory%n\", path) } catch (e: DirectoryNotEmptyException) { System.err.printf(\"%s not empty%n\", path) } catch (e: IOException) { // Problemas de permisos u otros errores de E/S System.err.println(\"Error: ${e.message}\") } } El metodo deleteIfExists(Path) tambien borra el fichero o directorio, pero no lanza ningun error en caso de que el fichero o directorio no exista. \ud83d\udda5\ufe0f Ejemplo_copiardirectorio.kt : copiar directorios Se puede copiar un archivo o directorio usando el m\u00e9todo copy(Path, Path, CopyOption...). La copia falla si el archivo de destino existe, a menos que se especifique la opci\u00f3n REPLACE_EXISTING. Se puede copiar directorios aunque, los archivos dentro del directorio no se copian, por lo que el nuevo directorio est\u00e1 vac\u00edo incluso cuando el directorio original contiene archivos. import java.io.IOException import java.nio.file.FileAlreadyExistsException import java.nio.file.Files import java.nio.file.Path import java.nio.file.Paths // import java.nio.file.StandardCopyOption // si se desea sobrescribir fun main() { val sourcePath: Path = Paths.get(\"documentos\") val destinationPath: Path = Paths.get(\"documentos/destino\") try { Files.copy(sourcePath, destinationPath) // Para sobrescribir si ya existe, descomenta la siguiente l\u00ednea: // Files.copy(sourcePath, destinationPath, StandardCopyOption.REPLACE_EXISTING) println(\"Copia realizada con \u00e9xito.\") } catch (e: FileAlreadyExistsException) { println(\"El fichero o directorio ya existe en el destino.\") } catch (e: IOException) { println(\"Error al copiar: ${e.message}\") e.printStackTrace() } } \ud83d\udda5\ufe0f Ejemplo_copiarficheros.kt : copiar ficheros import java.io.IOException import java.nio.file.FileAlreadyExistsException import java.nio.file.Files import java.nio.file.Path import java.nio.file.Paths import java.nio.file.StandardCopyOption fun main() { val sourcePath: Path = Paths.get(\"documentos/ejemplo.txt\") val destinationPath: Path = Paths.get(\"documentos/ejemplo_copia.txt\") try { Files.copy(sourcePath, destinationPath, StandardCopyOption.REPLACE_EXISTING) println(\"Archivo copiado correctamente a: $destinationPath\") } catch (e: FileAlreadyExistsException) { println(\"El archivo destino ya existe.\") } catch (e: IOException) { println(\" Error al copiar el archivo: ${e.message}\") e.printStackTrace() } } \ud83d\udda5\ufe0f Ejemplo_moverficheros.kt : mover ficheros y directorios cambiando el nombre. import java.io.IOException import java.nio.file.FileAlreadyExistsException import java.nio.file.Files import java.nio.file.Path import java.nio.file.Paths import java.nio.file.StandardCopyOption fun main() { val sourcePath: Path = Paths.get(\"documentos/ejemplo.txt\") val destinationPath: Path = Paths.get(\"documentos2/ejemplo2.txt\") try { Files.move(sourcePath, destinationPath, StandardCopyOption.REPLACE_EXISTING) println(\"Archivo movido/renombrado correctamente a: $destinationPath\") } catch (e: FileAlreadyExistsException) { println(\"El archivo destino ya existe.\") } catch (e: IOException) { println(\"Error al mover el archivo: ${e.message}\") e.printStackTrace() } } El siguiente ejemplo recorre la estructura home en tu sistema, indicando los permisos de cada archivo y directorio: \ud83d\udda5\ufe0f Ejemplo_SistemaFicheros.kt import java.nio.file.* import java.nio.file.attribute.BasicFileAttributes import java.util.Scanner fun main() { val scanner = Scanner(System.`in`) var currentPath: Path = Paths.get(System.getProperty(\"user.home\")) while (true) { println(\"\\n Directorio actual: $currentPath\") try { val paths = Files.list(currentPath).toList() paths.forEachIndexed { index, path -> val attrs = Files.readAttributes(path, BasicFileAttributes::class.java) val tipo = when { attrs.isDirectory -> \"[DIR]\" attrs.isRegularFile -> \"[FILE]\" else -> \"[OTRO]\" } val permisos = listOfNotNull( if (Files.isReadable(path)) \"r\" else null, if (Files.isWritable(path)) \"w\" else null, if (Files.isExecutable(path)) \"x\" else null ).joinToString(\"\") val size = if (attrs.isRegularFile) \"${attrs.size()} bytes\" else \"\" println(\"$index. $tipo ${path.fileName} [$permisos] $size\") } println(\"\\nOpciones:\") println(\" - N\u00famero: acceder a subdirectorio\") println(\" - `..`: subir al directorio padre\") println(\" - `salir`: finalizar el programa\") print(\"Opci\u00f3n: \") when (val input = scanner.nextLine()) { \"salir\" -> { println(\"Saliendo del explorador.\") return } \"..\" -> { currentPath = currentPath.parent ?: currentPath } else -> { val index = input.toIntOrNull() if (index != null && index in paths.indices) { val selected = paths[index] if (Files.isDirectory(selected)) { currentPath = selected } else { println(\"No es un directorio.\") } } else { println(\"Entrada no v\u00e1lida.\") } } } } catch (e: Exception) { println(\"Error al acceder al directorio: ${e.message}\") } } } \ud83d\udd39FileSystem En la biblioteca java.nio podemos encontrar otras clases que complementan y ampl\u00edan lo que se puede hacer con java.nio.file.Path . El concepto de FileSystem define un sistema de ficheros completo . Mientras que por otro lado el concepto de Path hace referencia a un directorio, fichero o link que tengamos dentro de nuestro sistema de ficheros. M\u00e9todo Qu\u00e9 devuelve Descripci\u00f3n .getDefault() FileSystem Devuelve el sistema de ficheros por defecto del entorno en ejecuci\u00f3n. .getSeparator() String Devuelve el separador de nombres de ruta (por ejemplo, / o \\ ). .getRootDirectories() Iterable<Path> Devuelve los directorios ra\u00edz del sistema (ej: / , C:\\ ). .getFileStores() Iterable<FileStore> Devuelve las particiones o vol\u00famenes montados en el sistema. .getPath(...) Path Crea una instancia de Path a partir de cadenas de texto. .provider() FileSystemProvider Devuelve el proveedor del sistema de archivos (ej. UnixFileSystemProvider ). Esto: val fileSystem = FileSystems.getDefault() val path = fileSystem.getPath(\"C:\\\\Users\\\\alumno\\\\documento.txt\") Es equivalente a usar: val path = Paths.get(\"C:\\\\Users\\\\alumno\\\\documento.txt\") Pero usando FileSystems.getDefault() puedes: Cambiar de sistema de ficheros si lo necesitas (por ejemplo, ZIP o virtuales). Obtener caracter\u00edsticas del sistema. \ud83d\udda5\ufe0f Ejemplo_FileSystem.kt : obtener el nombre de un fichero as\u00ed como la carpeta padre en la que se encuentra ubicado. import java.nio.file.FileSystems import java.nio.file.Path fun main() { val sistemaFicheros = FileSystems.getDefault() val rutaFichero: Path = sistemaFicheros.getPath(\"documentos/destino/ejemplo3.txt\") println(rutaFichero.fileName) println(rutaFichero.parent.fileName) val rutaDirectorio: Path = sistemaFicheros.getPath(\"documentos/destino\") val it = rutaDirectorio.iterator() while (it.hasNext()) { println(it.next().fileName) } } \ud83d\udd39BasicFileAttributes BasicFileAttributes permite obtener informaci\u00f3n detallada sobre archivos y directorios , como fecha de creaci\u00f3n, tama\u00f1o, etc. Para poder utilizar un objeto de tipo BasicFileAttributes , primero es necesario llamar al m\u00e9todo readAttributes : val attr = Files.readAttributes(path, BasicFileAttributes::class.java) Este m\u00e9todo pertenece a la clase Files y se encarga de leer los atributos asociados al archivo o directorio indicado por path . BasicFileAttributes::class.java: indica que queremos obtener los atributos b\u00e1sicos definidos en esa clase. El resultado ( attr ) es un objeto del tipo BasicFileAttributes. M\u00e9todo Descripci\u00f3n Devuelve creationTime() Devuelve la fecha de creaci\u00f3n del archivo. FileTime lastModifiedTime() Devuelve la \u00faltima fecha de modificaci\u00f3n. FileTime size() Devuelve el tama\u00f1o del archivo en bytes. Long isDirectory() Verifica si el Path representa un directorio. Boolean isRegularFile() Verifica si es un archivo regular (no directorio). Boolean \ud83d\udda5\ufe0f Ejemplo_BasicFileAttributes.kt : leer los atributos b\u00e1sicos de un archivo o directorio. import java.nio.file.Files import java.nio.file.Paths import java.nio.file.attribute.BasicFileAttributes fun main() { val path = Paths.get(\"documentos\") if (Files.exists(path)) { val attr = Files.readAttributes(path, BasicFileAttributes::class.java) println(\"Creaci\u00f3n: ${attr.creationTime()}\") println(\"\u00daltimo acceso: ${attr.lastAccessTime()}\") println(\"Es un directorio: ${attr.isDirectory}\") println(\"Tama\u00f1o del archivo: ${attr.size()} bytes\") } } \ud83d\udd39FileStore FileStore permite obtener informaci\u00f3n sobre el sistema de archivos , como el espacio disponible. No se puede instanciar un FileStore directamente. Para usarlo, necesitamos obtenerlo desde un Path (archivo o directorio) val Store = Files.getFileStore(path) M\u00e9todo Descripci\u00f3n Devuelve name() Nombre del volumen o unidad l\u00f3gica. String type() Tipo de sistema de archivos (por ejemplo, ext4 , NTFS , etc.). String getTotalSpace() Espacio total disponible en el volumen (en bytes). Long getUsableSpace() Espacio disponible para el usuario (en bytes). Long supportsFileAttributeView(...) Verifica si el volumen soporta ciertos atributos como POSIX o DOS. Boolean \ud83d\udda5\ufe0f Ejemplo_FileStore.kt : obtener informaci\u00f3n del almacenamiento f\u00edsico. import java.nio.file.FileStore import java.nio.file.Files import java.nio.file.Paths fun main() { val path = Paths.get(\"/\") val fileStore: FileStore = Files.getFileStore(path) println(\"Sistema de archivos: ${fileStore.type()}\") println(\"Espacio total: ${fileStore.totalSpace / (1024 * 1024)} MB\") println(\"Espacio disponible: ${fileStore.usableSpace / (1024 * 1024)} MB\") } Nota Funciona en Windows y Linux, aunque Files.getFileStore(Paths.get(\"/\")) podr\u00eda requerir ajustes en Windows para seleccionar una unidad espec\u00edfica (C:\\, D:\\, etc.). EjemploCompleto_File.kt :El siguiente ejemplo utiliza todas estas funciones para mostrar informaci\u00f3n sobre el sistema de ficheros. import java.io.File import java.nio.file.* import java.nio.file.attribute.BasicFileAttributes import java.nio.file.FileStore import java.nio.file.FileSystems fun main() { println(\" Ra\u00edces del sistema:\") File.listRoots().forEach { raiz -> println(\"- ${raiz.absolutePath}\") } println(\"\\n Sistemas de archivos detectados:\") val fileSystem: FileSystem = FileSystems.getDefault() fileSystem.fileStores.forEach { store: FileStore -> println(\"Unidad: ${store.name()} (${store.type()})\") println(\"Total: ${store.totalSpace / 1024 / 1024} MB\") println(\"Libre: ${store.usableSpace / 1024 / 1024} MB\") } // Usamos Path y Files para analizar un fichero concreto val path: Path = Paths.get(\"datos.txt\") // Si el fichero existe, mostramos sus atributos if (Files.exists(path)) { println(\"\\n Atributos del fichero '${path.fileName}':\") val attrs: BasicFileAttributes = Files.readAttributes(path, BasicFileAttributes::class.java) println(\"Creaci\u00f3n: ${attrs.creationTime()}\") println(\"\u00daltimo acceso: ${attrs.lastAccessTime()}\") println(\"\u00daltima modificaci\u00f3n: ${attrs.lastModifiedTime()}\") println(\"Tama\u00f1o: ${attrs.size()} bytes\") println(\"\u00bfEs directorio?: ${attrs.isDirectory}\") println(\"\u00bfEs archivo normal?: ${attrs.isRegularFile}\") } else { println(\"\\n El fichero 'datos.txt' no existe en la ra\u00edz del proyecto.\") } }","title":"\ud83d\udd39 Acceso al sistema de ficheros. Java.nio"},{"location":"T1_Sistema_de_ficheros/NIO_AccesoFicheros/#acceso-al-sistema-de-ficheros-javanio","text":"Proyecto Ficheros Para probar y organizar los ejemplos propuestos en esta parte del temario, crearemos en IntelliJ un proyecto llamado Ficheros . Dentro de este proyecto crearemos tres paquetes ( sistema , contenido y formatos ) para organizar los diferentes ejemplos, que en cada ocasi\u00f3n se indicar\u00e1 en que paquete deben ubicarse. | Durante muchos a\u00f1os se ha utilizado la librer\u00eda java.io para trabajar con ficheros en el mundo Java. Se trata de un API muy potente y flexible que nos permite realizar casi cualquier tipo de operaci\u00f3n. Sin embargo es una API complicada de entender. Java.nio (New IO) es una nueva API disponible desde Java7 que nos permite mejorar el rendimiento, as\u00ed como simplificar el manejo de muchas operaciones. Java.nio define interfaces y clases para que la m\u00e1quina virtual Java tenga acceso a archivos, atributos de archivos y sistemas de archivos. Aunque dicho API comprende numerosas clases, solo existen unas pocas de ellas que sirven de puntos de entrada al API, lo que simplifica considerablemente su manejo. La interfaz java.nio.file.Path representa un path, y las clases que implementen esta interfaz puede utilizarse para localizar ficheros en el sistema de ficheros. Nos permite manejar rutas al estilo GNU/Linux y rutas al estilo Windows dependiendo del SO en el que estemos trabajando. La clase java.nio.file.Files es el otro punto de entrada a la librer\u00eda de ficheros de Java. Es la que nos permite manejar ficheros reales del disco desde Java. Clases para la gesit\u00f3n de ficheros Paths : Crea objetos Path desde cadenas de texto Path : Representa rutas a archivos o directorios Files : Permite operaciones sobre archivos usando Path Ejemplos Los siguientes ejemplos se incluir\u00e1n en el paquete sistema dentro del proyecto Ficheros .","title":"Acceso al sistema de ficheros. Java.nio"},{"location":"T1_Sistema_de_ficheros/NIO_AccesoFicheros/#paths","text":"La clase Paths es una clase de utilidad que proporciona m\u00e9todos est\u00e1ticos para crear objetos Path , que luego puedes usar con m\u00e9todos de Files . M\u00e9todo Descripci\u00f3n get(String first, String... ) Crea un objeto Path a partir de una o m\u00e1s cadenas. get(URI uri) Crea un Path desde un URI que debe ser del esquema file:///. El uso de Paths.get(...) en Java (o Kotlin) no implica que el archivo o directorio exista. Este m\u00e9todo simplemente crea una instancia de Path que representa una ruta en el sistema de archivos, pero no accede al disco ni verifica su existencia. \ud83d\udda5\ufe0f Ejemplo_get.kt import java.nio.file.Path import java.nio.file.Paths fun main() { val path1: Path = Paths.get(\"documentos\", \"archivo.txt\") val path2: Path = Paths.get(\"C:\", \"usuarios\", \"nombre\", \"archivo.txt\") println(\"Ruta 1: $path1\") println(\"Ruta 2: $path2\") } \ud83d\udda5\ufe0f Ejemplo_uri.kt import java.net.URI import java.nio.file.Path import java.nio.file.Paths fun main() { val uri = URI(\"file:///C:/usuarios/nombre/archivo.txt\") val path: Path = Paths.get(uri) println(\"Ruta a partir de URI: $path\") }","title":"\ud83d\udd39Paths"},{"location":"T1_Sistema_de_ficheros/NIO_AccesoFicheros/#path","text":"La clase Path Se utiliza junto con la clase Files para realizar operaciones como lectura, escritura, copia, o eliminaci\u00f3n de archivos. La forma mas sencilla de construir un objeto que cumpla la interfaz Path es a partir de la clase java.nio.file.Paths , que tiene m\u00e9todos est\u00e1ticos que retornan objetos Path a partir de una representaci\u00f3n tipo String del path deseado. Por supuesto, no es necesario que los ficheros existan de verdad en el disco duro para que se puedan crear los objetos Path correspondientes. Un objeto Path puede representarse de dos formas: Ruta absoluta val path = Paths.get(\"/home/usuario/archivo.txt\") Ruta relativa val path = Paths.get(\"documentos/ejemplo.txt\") println(path.toAbsolutePath()) Las operaciones y m\u00e9todos principales que se pueden hacer con Path son: M\u00e9todo Qu\u00e9 devuelve Descripci\u00f3n .startsWith(Path other) Boolean Devuelve true si el path empieza por el path dado. .endsWith(Path other) Boolean Devuelve true si el path termina con el path dado. .getParent() Path? Devuelve el path padre (superior) o null si no tiene. .getRoot() Path? Devuelve el componente ra\u00edz ( / , C:\\ , etc.) o null si no existe. .iterator() Iterator<Path> Permite iterar sobre cada parte del path (carpetas y nombre final). .toString() String Devuelve el path como texto. .toAbsolutePath() Path Devuelve el path completo desde la ra\u00edz del sistema. .resolve(Path/String) Path Une dos partes de un path de forma correcta, manejando barras autom\u00e1ticamente. .toFile() java.io.File Convierte el Path en un File de la API tradicional de Java ( java.io ). \ud83d\udda5\ufe0f Ejemplo_Path.kt import java.nio.file.Path import java.nio.file.Paths fun main() { val path: Path = Paths.get(\"documentos/ejemplo.txt\") println(\"toString(): ${path}\") println(\"toAbsolutePath(): ${path.toAbsolutePath()}\") println(\"getFileName(): ${path.fileName}\") println(\"getParent(): ${path.parent}\") println(\"getRoot(): ${path.root}\") val otroPath: Path = Paths.get(\"imagenes/foto.png\") println(\"resolve(): ${path.resolve(otroPath)}\") val relativo: Path = path.relativize(Paths.get(\"documentos/otroArchivo.txt\")) println(\"relativize(): $relativo\") val rutaNormalizada: Path = Paths.get(\"carpeta/../archivo.txt\").normalize() println(\"normalize(): $rutaNormalizada\") println(\"startsWith(\\\"documentos\\\"): ${path.startsWith(\"documentos\")}\") println(\"endsWith(\\\"ejemplo.txt\\\"): ${path.endsWith(\"ejemplo.txt\")}\") }","title":"\ud83d\udd39Path"},{"location":"T1_Sistema_de_ficheros/NIO_AccesoFicheros/#files","text":"La clase Files es el otro punto de entrada a la librer\u00eda de ficheros de Java. Es la que nos permite manejar ficheros reales del disco desde Java. Esta clase tiene m\u00e9todos est\u00e1ticos para el manejo de ficheros, los m\u00e9todos de la clase Files trabajan sobre objetos Path . Muchos de estos m\u00e9todos devuelven streams , lo que permite procesar archivos y directorios de forma eficiente y elegante. En Java (y tambi\u00e9n en Kotlin), un Stream es una secuencia de elementos que permite realizar operaciones funcionales (como map, filter, forEach, etc.) sobre datos de forma eficiente y fluida, sin necesidad de estructuras intermedias ni bucles expl\u00edcitos. Algunos m\u00e9todo de Files utilizan o devuelven Streams . Las operaciones y m\u00e9todos principales a realizar con Files son: M\u00e9todo Qu\u00e9 devuelve Descripci\u00f3n list(Path) Stream<Path> Lista contenido directo (no recursivo) del directorio. .walk(Path) Stream<Path> Recorre directorios de forma recursiva. .find(... ) Stream<Path> Busca elementos que cumplan una condici\u00f3n. .lines(Path) Stream<String> Devuelve las l\u00edneas de un archivo de texto. .exists(Path) Boolean Verifica si el archivo existe. .isDirectory(Path) Boolean Verifica si es un directorio. .isRegularFile(Path) Boolean Verifica si es un archivo normal. .isReadable(Path) Boolean Verifica si se puede leer. .createFile(Path) Path Crea un archivo vac\u00edo. .createDirectory(Path) Path Crea un directorio. .createDirectories(Path) Path Crea directorios y subdirectorios necesarios. .delete(Path) void Elimina un archivo o directorio. .deleteIfExists(Path) Boolean Elimina si existe. .move(Path, Path) Path Mueve un archivo o directorio. .copy(Path, Path) Path Copia un archivo o directorio. .size(Path) Long Tama\u00f1o del archivo. .getLastModifiedTime(Path) FileTime \u00daltima modificaci\u00f3n. .getOwner(Path) UserPrincipal Devuelve el propietario. .getAttribute(Path, String) Object Devuelve un atributo espec\u00edfico. \ud83d\udda5\ufe0f Ejemplo_permisos.kt : existencia y comprobaci\u00f3n de permisos import java.nio.file.Path import java.nio.file.Paths import java.nio.file.Files fun main() { val path: Path = Paths.get(\"documentos/ejemplo.txt\") println(\"path = $path\") println(\"exists = ${Files.exists(path)}\") println(\"readable = ${Files.isReadable(path)}\") println(\"writable = ${Files.isWritable(path)}\") println(\"executable = ${Files.isExecutable(path)}\") } \ud83d\udda5\ufe0f Ejemplo_creardirectorio.kt : crear un directorio import java.nio.file.Path import java.nio.file.Paths import java.nio.file.Files import java.nio.file.FileAlreadyExistsException import java.io.IOException fun main() { val path: Path = Paths.get(\"documentos\") try { val newDir = Files.createDirectory(path) println(\"Directorio creado en: $newDir\") } catch (e: FileAlreadyExistsException) { println(\"El directorio ya existe: $path\") } catch (e: IOException) { println(\"Error de entrada/salida: ${e.message}\") e.printStackTrace() } } \ud83d\udda5\ufe0f Ejemplo_borrardirectorio.kt : elimina un directorio import java.nio.file.Files import java.nio.file.Path import java.nio.file.Paths fun main() { val directorio: Path = Paths.get(\"c:/mi_directorio\") // Si ya existe, lo eliminamos if (Files.exists(directorio)) { println(\"El directorio ya existe. Borr\u00e1ndolo...\") Files.delete(directorio) } } Gesti\u00f3n de errores y validaciones El m\u00e9todo delete(Path) borra el fichero o directorio o lanza una excepci\u00f3n si el borrado falla. El siguiente ejemplo muestra como capturar y gestionar las excepciones que pueden producirse en el borrado. Si el fichero o directorio no existe, la excepci\u00f3n que se produce es NoSuchFileException . Los sucesivos cath permiten determinar por que ha fallado el borrado: import java.nio.file.* import java.io.IOException fun main() { val path = Paths.get(\"c:/mi_directorio\") try { Files.delete(path) } catch (e: NoSuchFileException) { System.err.printf(\"%s: no such file or directory%n\", path) } catch (e: DirectoryNotEmptyException) { System.err.printf(\"%s not empty%n\", path) } catch (e: IOException) { // Problemas de permisos u otros errores de E/S System.err.println(\"Error: ${e.message}\") } } El metodo deleteIfExists(Path) tambien borra el fichero o directorio, pero no lanza ningun error en caso de que el fichero o directorio no exista. \ud83d\udda5\ufe0f Ejemplo_copiardirectorio.kt : copiar directorios Se puede copiar un archivo o directorio usando el m\u00e9todo copy(Path, Path, CopyOption...). La copia falla si el archivo de destino existe, a menos que se especifique la opci\u00f3n REPLACE_EXISTING. Se puede copiar directorios aunque, los archivos dentro del directorio no se copian, por lo que el nuevo directorio est\u00e1 vac\u00edo incluso cuando el directorio original contiene archivos. import java.io.IOException import java.nio.file.FileAlreadyExistsException import java.nio.file.Files import java.nio.file.Path import java.nio.file.Paths // import java.nio.file.StandardCopyOption // si se desea sobrescribir fun main() { val sourcePath: Path = Paths.get(\"documentos\") val destinationPath: Path = Paths.get(\"documentos/destino\") try { Files.copy(sourcePath, destinationPath) // Para sobrescribir si ya existe, descomenta la siguiente l\u00ednea: // Files.copy(sourcePath, destinationPath, StandardCopyOption.REPLACE_EXISTING) println(\"Copia realizada con \u00e9xito.\") } catch (e: FileAlreadyExistsException) { println(\"El fichero o directorio ya existe en el destino.\") } catch (e: IOException) { println(\"Error al copiar: ${e.message}\") e.printStackTrace() } } \ud83d\udda5\ufe0f Ejemplo_copiarficheros.kt : copiar ficheros import java.io.IOException import java.nio.file.FileAlreadyExistsException import java.nio.file.Files import java.nio.file.Path import java.nio.file.Paths import java.nio.file.StandardCopyOption fun main() { val sourcePath: Path = Paths.get(\"documentos/ejemplo.txt\") val destinationPath: Path = Paths.get(\"documentos/ejemplo_copia.txt\") try { Files.copy(sourcePath, destinationPath, StandardCopyOption.REPLACE_EXISTING) println(\"Archivo copiado correctamente a: $destinationPath\") } catch (e: FileAlreadyExistsException) { println(\"El archivo destino ya existe.\") } catch (e: IOException) { println(\" Error al copiar el archivo: ${e.message}\") e.printStackTrace() } } \ud83d\udda5\ufe0f Ejemplo_moverficheros.kt : mover ficheros y directorios cambiando el nombre. import java.io.IOException import java.nio.file.FileAlreadyExistsException import java.nio.file.Files import java.nio.file.Path import java.nio.file.Paths import java.nio.file.StandardCopyOption fun main() { val sourcePath: Path = Paths.get(\"documentos/ejemplo.txt\") val destinationPath: Path = Paths.get(\"documentos2/ejemplo2.txt\") try { Files.move(sourcePath, destinationPath, StandardCopyOption.REPLACE_EXISTING) println(\"Archivo movido/renombrado correctamente a: $destinationPath\") } catch (e: FileAlreadyExistsException) { println(\"El archivo destino ya existe.\") } catch (e: IOException) { println(\"Error al mover el archivo: ${e.message}\") e.printStackTrace() } } El siguiente ejemplo recorre la estructura home en tu sistema, indicando los permisos de cada archivo y directorio: \ud83d\udda5\ufe0f Ejemplo_SistemaFicheros.kt import java.nio.file.* import java.nio.file.attribute.BasicFileAttributes import java.util.Scanner fun main() { val scanner = Scanner(System.`in`) var currentPath: Path = Paths.get(System.getProperty(\"user.home\")) while (true) { println(\"\\n Directorio actual: $currentPath\") try { val paths = Files.list(currentPath).toList() paths.forEachIndexed { index, path -> val attrs = Files.readAttributes(path, BasicFileAttributes::class.java) val tipo = when { attrs.isDirectory -> \"[DIR]\" attrs.isRegularFile -> \"[FILE]\" else -> \"[OTRO]\" } val permisos = listOfNotNull( if (Files.isReadable(path)) \"r\" else null, if (Files.isWritable(path)) \"w\" else null, if (Files.isExecutable(path)) \"x\" else null ).joinToString(\"\") val size = if (attrs.isRegularFile) \"${attrs.size()} bytes\" else \"\" println(\"$index. $tipo ${path.fileName} [$permisos] $size\") } println(\"\\nOpciones:\") println(\" - N\u00famero: acceder a subdirectorio\") println(\" - `..`: subir al directorio padre\") println(\" - `salir`: finalizar el programa\") print(\"Opci\u00f3n: \") when (val input = scanner.nextLine()) { \"salir\" -> { println(\"Saliendo del explorador.\") return } \"..\" -> { currentPath = currentPath.parent ?: currentPath } else -> { val index = input.toIntOrNull() if (index != null && index in paths.indices) { val selected = paths[index] if (Files.isDirectory(selected)) { currentPath = selected } else { println(\"No es un directorio.\") } } else { println(\"Entrada no v\u00e1lida.\") } } } } catch (e: Exception) { println(\"Error al acceder al directorio: ${e.message}\") } } }","title":"\ud83d\udd39Files"},{"location":"T1_Sistema_de_ficheros/NIO_AccesoFicheros/#filesystem","text":"En la biblioteca java.nio podemos encontrar otras clases que complementan y ampl\u00edan lo que se puede hacer con java.nio.file.Path . El concepto de FileSystem define un sistema de ficheros completo . Mientras que por otro lado el concepto de Path hace referencia a un directorio, fichero o link que tengamos dentro de nuestro sistema de ficheros. M\u00e9todo Qu\u00e9 devuelve Descripci\u00f3n .getDefault() FileSystem Devuelve el sistema de ficheros por defecto del entorno en ejecuci\u00f3n. .getSeparator() String Devuelve el separador de nombres de ruta (por ejemplo, / o \\ ). .getRootDirectories() Iterable<Path> Devuelve los directorios ra\u00edz del sistema (ej: / , C:\\ ). .getFileStores() Iterable<FileStore> Devuelve las particiones o vol\u00famenes montados en el sistema. .getPath(...) Path Crea una instancia de Path a partir de cadenas de texto. .provider() FileSystemProvider Devuelve el proveedor del sistema de archivos (ej. UnixFileSystemProvider ). Esto: val fileSystem = FileSystems.getDefault() val path = fileSystem.getPath(\"C:\\\\Users\\\\alumno\\\\documento.txt\") Es equivalente a usar: val path = Paths.get(\"C:\\\\Users\\\\alumno\\\\documento.txt\") Pero usando FileSystems.getDefault() puedes: Cambiar de sistema de ficheros si lo necesitas (por ejemplo, ZIP o virtuales). Obtener caracter\u00edsticas del sistema. \ud83d\udda5\ufe0f Ejemplo_FileSystem.kt : obtener el nombre de un fichero as\u00ed como la carpeta padre en la que se encuentra ubicado. import java.nio.file.FileSystems import java.nio.file.Path fun main() { val sistemaFicheros = FileSystems.getDefault() val rutaFichero: Path = sistemaFicheros.getPath(\"documentos/destino/ejemplo3.txt\") println(rutaFichero.fileName) println(rutaFichero.parent.fileName) val rutaDirectorio: Path = sistemaFicheros.getPath(\"documentos/destino\") val it = rutaDirectorio.iterator() while (it.hasNext()) { println(it.next().fileName) } }","title":"\ud83d\udd39FileSystem"},{"location":"T1_Sistema_de_ficheros/NIO_AccesoFicheros/#basicfileattributes","text":"BasicFileAttributes permite obtener informaci\u00f3n detallada sobre archivos y directorios , como fecha de creaci\u00f3n, tama\u00f1o, etc. Para poder utilizar un objeto de tipo BasicFileAttributes , primero es necesario llamar al m\u00e9todo readAttributes : val attr = Files.readAttributes(path, BasicFileAttributes::class.java) Este m\u00e9todo pertenece a la clase Files y se encarga de leer los atributos asociados al archivo o directorio indicado por path . BasicFileAttributes::class.java: indica que queremos obtener los atributos b\u00e1sicos definidos en esa clase. El resultado ( attr ) es un objeto del tipo BasicFileAttributes. M\u00e9todo Descripci\u00f3n Devuelve creationTime() Devuelve la fecha de creaci\u00f3n del archivo. FileTime lastModifiedTime() Devuelve la \u00faltima fecha de modificaci\u00f3n. FileTime size() Devuelve el tama\u00f1o del archivo en bytes. Long isDirectory() Verifica si el Path representa un directorio. Boolean isRegularFile() Verifica si es un archivo regular (no directorio). Boolean \ud83d\udda5\ufe0f Ejemplo_BasicFileAttributes.kt : leer los atributos b\u00e1sicos de un archivo o directorio. import java.nio.file.Files import java.nio.file.Paths import java.nio.file.attribute.BasicFileAttributes fun main() { val path = Paths.get(\"documentos\") if (Files.exists(path)) { val attr = Files.readAttributes(path, BasicFileAttributes::class.java) println(\"Creaci\u00f3n: ${attr.creationTime()}\") println(\"\u00daltimo acceso: ${attr.lastAccessTime()}\") println(\"Es un directorio: ${attr.isDirectory}\") println(\"Tama\u00f1o del archivo: ${attr.size()} bytes\") } }","title":"\ud83d\udd39BasicFileAttributes"},{"location":"T1_Sistema_de_ficheros/NIO_AccesoFicheros/#filestore","text":"FileStore permite obtener informaci\u00f3n sobre el sistema de archivos , como el espacio disponible. No se puede instanciar un FileStore directamente. Para usarlo, necesitamos obtenerlo desde un Path (archivo o directorio) val Store = Files.getFileStore(path) M\u00e9todo Descripci\u00f3n Devuelve name() Nombre del volumen o unidad l\u00f3gica. String type() Tipo de sistema de archivos (por ejemplo, ext4 , NTFS , etc.). String getTotalSpace() Espacio total disponible en el volumen (en bytes). Long getUsableSpace() Espacio disponible para el usuario (en bytes). Long supportsFileAttributeView(...) Verifica si el volumen soporta ciertos atributos como POSIX o DOS. Boolean \ud83d\udda5\ufe0f Ejemplo_FileStore.kt : obtener informaci\u00f3n del almacenamiento f\u00edsico. import java.nio.file.FileStore import java.nio.file.Files import java.nio.file.Paths fun main() { val path = Paths.get(\"/\") val fileStore: FileStore = Files.getFileStore(path) println(\"Sistema de archivos: ${fileStore.type()}\") println(\"Espacio total: ${fileStore.totalSpace / (1024 * 1024)} MB\") println(\"Espacio disponible: ${fileStore.usableSpace / (1024 * 1024)} MB\") } Nota Funciona en Windows y Linux, aunque Files.getFileStore(Paths.get(\"/\")) podr\u00eda requerir ajustes en Windows para seleccionar una unidad espec\u00edfica (C:\\, D:\\, etc.). EjemploCompleto_File.kt :El siguiente ejemplo utiliza todas estas funciones para mostrar informaci\u00f3n sobre el sistema de ficheros. import java.io.File import java.nio.file.* import java.nio.file.attribute.BasicFileAttributes import java.nio.file.FileStore import java.nio.file.FileSystems fun main() { println(\" Ra\u00edces del sistema:\") File.listRoots().forEach { raiz -> println(\"- ${raiz.absolutePath}\") } println(\"\\n Sistemas de archivos detectados:\") val fileSystem: FileSystem = FileSystems.getDefault() fileSystem.fileStores.forEach { store: FileStore -> println(\"Unidad: ${store.name()} (${store.type()})\") println(\"Total: ${store.totalSpace / 1024 / 1024} MB\") println(\"Libre: ${store.usableSpace / 1024 / 1024} MB\") } // Usamos Path y Files para analizar un fichero concreto val path: Path = Paths.get(\"datos.txt\") // Si el fichero existe, mostramos sus atributos if (Files.exists(path)) { println(\"\\n Atributos del fichero '${path.fileName}':\") val attrs: BasicFileAttributes = Files.readAttributes(path, BasicFileAttributes::class.java) println(\"Creaci\u00f3n: ${attrs.creationTime()}\") println(\"\u00daltimo acceso: ${attrs.lastAccessTime()}\") println(\"\u00daltima modificaci\u00f3n: ${attrs.lastModifiedTime()}\") println(\"Tama\u00f1o: ${attrs.size()} bytes\") println(\"\u00bfEs directorio?: ${attrs.isDirectory}\") println(\"\u00bfEs archivo normal?: ${attrs.isRegularFile}\") } else { println(\"\\n El fichero 'datos.txt' no existe en la ra\u00edz del proyecto.\") } }","title":"\ud83d\udd39FileStore"},{"location":"T1_Sistema_de_ficheros/exercicis/","text":"\ud83d\udcdd Ejercicio 1: Explorador interactivo del directorio personal \ud83d\udccb Enunciado Desarrollar un programa en Kotlin que permita explorar y manipular el contenido del directorio personal del usuario (home) utilizando la API de java.nio.file . El programa debe: Obtener la ruta del directorio personal del usuario mediante: val homePath = Paths.get(System.getProperty(\"user.home\")) Mostrar los primeros 5 elementos (archivos o carpetas) visibles dentro del home (excluyendo ocultos), mostrando: Nombre Tipo (archivo o directorio) Tama\u00f1o en bytes Fecha de creaci\u00f3n y \u00faltima modificaci\u00f3n Permisos: legible y escribible Mostrar informaci\u00f3n sobre el sistema de archivos : Tipo del sistema Espacio total y libre en bytes Presentar un men\u00fa interactivo con las siguientes opciones: \ud83d\udccb Men\u00fa de acciones: 1- Crear un directorio en el home 2- Eliminar un directorio del home 3- Ver contenido recursivo de un directorio 0- Salir \ud83d\udee0\ufe0f Requisitos t\u00e9cnicos El contenido del home debe actualizarse y mostrarse tras cada operaci\u00f3n del men\u00fa. El programa debe ignorar todos los archivos o carpetas cuyo nombre comience por . La opci\u00f3n 3 debe explorar el directorio de forma recursiva usando Files.walk() Se debe utilizar try/catch para capturar errores como directorios inexistentes, problemas de permisos, etc. La salida debe ser clara, bien estructurada y comprensible. \ud83d\udce4 Ejemplo de salida esperada \ud83d\udcc1 Exploraci\u00f3n del home: /home/alumno \ud83d\udd39 Nombre: Documentos Tipo: Directorio Tama\u00f1o: 4096 bytes Creado: 2024-10-01T12:30:00 Modificado: 2025-08-15T09:00:00 Legible: true Escribible: true \ud83d\udcca Informaci\u00f3n del sistema de archivos: - Tipo: LinuxFileSystem - Total: 500000000000 bytes - Libre: 123456789000 bytes \ud83d\udccb Men\u00fa de acciones: 1. Crear un directorio en el home 2. Eliminar un directorio del home 3. Ver contenido recursivo de un directorio 0. Salir \u2705 R\u00fabrica de evaluaci\u00f3n Criterio Puntuaci\u00f3n m\u00e1xima Exploraci\u00f3n y atributos del home 1 Men\u00fa funcional y navegaci\u00f3n clara 2 Creaci\u00f3n de directorios 1 Eliminaci\u00f3n de directorios 1 Recorrido recursivo completo 2 Control de errores 1 Claridad y organizaci\u00f3n del c\u00f3digo 1 Comentarios y estilo del c\u00f3digo 1 Total 10","title":"\ud83d\udcdd Ejercicio obligatorio 1"},{"location":"T1_Sistema_de_ficheros/exercicis/#ejercicio-1-explorador-interactivo-del-directorio-personal","text":"","title":"\ud83d\udcdd Ejercicio 1: Explorador interactivo del directorio personal"},{"location":"T1_Sistema_de_ficheros/exercicis/#enunciado","text":"Desarrollar un programa en Kotlin que permita explorar y manipular el contenido del directorio personal del usuario (home) utilizando la API de java.nio.file . El programa debe: Obtener la ruta del directorio personal del usuario mediante: val homePath = Paths.get(System.getProperty(\"user.home\")) Mostrar los primeros 5 elementos (archivos o carpetas) visibles dentro del home (excluyendo ocultos), mostrando: Nombre Tipo (archivo o directorio) Tama\u00f1o en bytes Fecha de creaci\u00f3n y \u00faltima modificaci\u00f3n Permisos: legible y escribible Mostrar informaci\u00f3n sobre el sistema de archivos : Tipo del sistema Espacio total y libre en bytes Presentar un men\u00fa interactivo con las siguientes opciones: \ud83d\udccb Men\u00fa de acciones: 1- Crear un directorio en el home 2- Eliminar un directorio del home 3- Ver contenido recursivo de un directorio 0- Salir","title":"\ud83d\udccb Enunciado"},{"location":"T1_Sistema_de_ficheros/exercicis/#requisitos-tecnicos","text":"El contenido del home debe actualizarse y mostrarse tras cada operaci\u00f3n del men\u00fa. El programa debe ignorar todos los archivos o carpetas cuyo nombre comience por . La opci\u00f3n 3 debe explorar el directorio de forma recursiva usando Files.walk() Se debe utilizar try/catch para capturar errores como directorios inexistentes, problemas de permisos, etc. La salida debe ser clara, bien estructurada y comprensible. \ud83d\udce4 Ejemplo de salida esperada \ud83d\udcc1 Exploraci\u00f3n del home: /home/alumno \ud83d\udd39 Nombre: Documentos Tipo: Directorio Tama\u00f1o: 4096 bytes Creado: 2024-10-01T12:30:00 Modificado: 2025-08-15T09:00:00 Legible: true Escribible: true \ud83d\udcca Informaci\u00f3n del sistema de archivos: - Tipo: LinuxFileSystem - Total: 500000000000 bytes - Libre: 123456789000 bytes \ud83d\udccb Men\u00fa de acciones: 1. Crear un directorio en el home 2. Eliminar un directorio del home 3. Ver contenido recursivo de un directorio 0. Salir","title":"\ud83d\udee0\ufe0f Requisitos t\u00e9cnicos"},{"location":"T1_Sistema_de_ficheros/exercicis/#rubrica-de-evaluacion","text":"Criterio Puntuaci\u00f3n m\u00e1xima Exploraci\u00f3n y atributos del home 1 Men\u00fa funcional y navegaci\u00f3n clara 2 Creaci\u00f3n de directorios 1 Eliminaci\u00f3n de directorios 1 Recorrido recursivo completo 2 Control de errores 1 Claridad y organizaci\u00f3n del c\u00f3digo 1 Comentarios y estilo del c\u00f3digo 1 Total 10","title":"\u2705 R\u00fabrica de evaluaci\u00f3n"},{"location":"T1_Sistema_de_ficheros/ficheros/","text":"Ficheros Un fichero es una unidad de almacenamiento de datos en un sistema inform\u00e1tico. Se trata de un conjunto de informaci\u00f3n organizada y almacenada en un dispositivo de almacenamiento (secuencia de bytes), como un disco duro, una memoria USB o un servidor en la nube. A los datos que se guardan en ficheros se llaman datos persistentes, porque persisten m\u00e1s all\u00e1 de la ejecuci\u00f3n de la aplicaci\u00f3n que los trata. Caracter\u00edsticas de un fichero Nombre : Cada fichero tiene un nombre \u00fanico dentro de su directorio. Extensi\u00f3n : Muchos ficheros tienen una extensi\u00f3n que indica su tipo (por ejemplo, .txt para texto, .jpg para im\u00e1genes, .pdf para documentos, .dat para binarios...). Ubicaci\u00f3n : Se encuentran organizados en carpetas o directorios dentro del sistema de archivos. Contenido : Puede ser texto, im\u00e1genes, v\u00eddeos, c\u00f3digo fuente, bases de datos, etc. Permisos de acceso : Se pueden configurar para permitir o restringir la lectura, escritura o ejecuci\u00f3n a determinados usuarios o programas. Tipos de ficheros Ficheros de texto : Contienen datos en formato legible por humanos (.txt, .csv, .json, .xml). Ficheros binarios : Almacenan informaci\u00f3n en un formato no legible directamente (.exe, .jpg, .mp3, .dat). Ficheros de c\u00f3digo fuente : Contienen instrucciones escritas en lenguajes de programaci\u00f3n (.java, .kt, .py). Ficheros de configuraci\u00f3n : Almacenan par\u00e1metros de configuraci\u00f3n de programas (.ini, .conf, .properties). Ficheros de bases de datos : Se utilizan para almacenar grandes vol\u00famenes de datos estructurados (.db, .sql). Principales usos de la persistencia de datos en ficheros El uso de ficheros para la persistencia de datos es una alternativa sencilla y eficiente cuando no se requiere una base de datos completa: Guardar ajustes de una aplicaci\u00f3n en archivos de configuraci\u00f3n (.properties, .ini, .json). Mantener un historial de eventos o errores en un sistema (.log). Guardar informaci\u00f3n de usuario o estado de la aplicaci\u00f3n sin necesidad de una base de datos (.csv, .json). Comunicaci\u00f3n entre programas mediante archivos JSON o XML. Aplicaciones que funcionan sin internet o sin una base de datos centralizada.","title":"\ud83d\udd39 Ficheros"},{"location":"T1_Sistema_de_ficheros/ficheros/#ficheros","text":"Un fichero es una unidad de almacenamiento de datos en un sistema inform\u00e1tico. Se trata de un conjunto de informaci\u00f3n organizada y almacenada en un dispositivo de almacenamiento (secuencia de bytes), como un disco duro, una memoria USB o un servidor en la nube. A los datos que se guardan en ficheros se llaman datos persistentes, porque persisten m\u00e1s all\u00e1 de la ejecuci\u00f3n de la aplicaci\u00f3n que los trata. Caracter\u00edsticas de un fichero Nombre : Cada fichero tiene un nombre \u00fanico dentro de su directorio. Extensi\u00f3n : Muchos ficheros tienen una extensi\u00f3n que indica su tipo (por ejemplo, .txt para texto, .jpg para im\u00e1genes, .pdf para documentos, .dat para binarios...). Ubicaci\u00f3n : Se encuentran organizados en carpetas o directorios dentro del sistema de archivos. Contenido : Puede ser texto, im\u00e1genes, v\u00eddeos, c\u00f3digo fuente, bases de datos, etc. Permisos de acceso : Se pueden configurar para permitir o restringir la lectura, escritura o ejecuci\u00f3n a determinados usuarios o programas. Tipos de ficheros Ficheros de texto : Contienen datos en formato legible por humanos (.txt, .csv, .json, .xml). Ficheros binarios : Almacenan informaci\u00f3n en un formato no legible directamente (.exe, .jpg, .mp3, .dat). Ficheros de c\u00f3digo fuente : Contienen instrucciones escritas en lenguajes de programaci\u00f3n (.java, .kt, .py). Ficheros de configuraci\u00f3n : Almacenan par\u00e1metros de configuraci\u00f3n de programas (.ini, .conf, .properties). Ficheros de bases de datos : Se utilizan para almacenar grandes vol\u00famenes de datos estructurados (.db, .sql). Principales usos de la persistencia de datos en ficheros El uso de ficheros para la persistencia de datos es una alternativa sencilla y eficiente cuando no se requiere una base de datos completa: Guardar ajustes de una aplicaci\u00f3n en archivos de configuraci\u00f3n (.properties, .ini, .json). Mantener un historial de eventos o errores en un sistema (.log). Guardar informaci\u00f3n de usuario o estado de la aplicaci\u00f3n sin necesidad de una base de datos (.csv, .json). Comunicaci\u00f3n entre programas mediante archivos JSON o XML. Aplicaciones que funcionan sin internet o sin una base de datos centralizada.","title":"Ficheros"},{"location":"T2_Gestion_del_contenido/Formas_acceso/","text":"\ud83d\udd39 Formas de acceso a un fichero El acceso a ficheros es una tarea fundamental en la programaci\u00f3n, ya que permite leer y escribir datos persistentes. En Kotlin , utilizando las bibliotecas de Java ( java.io y java.nio ), se pueden manejar diferentes tipos de ficheros (texto, binarios, im\u00e1genes...), seg\u00fan sus caracter\u00edsticas y necesidades, y seg\u00fan su forma de acceder a ellos. Existen dos formas principales de acceder a un fichero: Acceso secuencial Los datos se procesan en orden, desde el principio hasta el final del fichero. Es el m\u00e1s com\u00fan y sencillo. Se usa cuando se desea leer todo el contenido o recorrer registro por registro, por ejemplo la lectura de un archivo de texto l\u00ednea por l\u00ednea, o de un fichero binario estructurado registro a registro. Acceso aleatorio Permite saltar a una posici\u00f3n concreta del fichero sin necesidad de leer lo anterior. Es \u00fatil cuando los registros tienen un tama\u00f1o fijo y se necesita eficiencia (por ejemplo, ir directamente al registro 100). Requiere t\u00e9cnicas m\u00e1s avanzadas como el uso de FileChannel , SeekableByteChannel o RandomAccessFile .","title":"\ud83d\udd39Formas de acceso a un fichero"},{"location":"T2_Gestion_del_contenido/Formas_acceso/#formas-de-acceso-a-un-fichero","text":"El acceso a ficheros es una tarea fundamental en la programaci\u00f3n, ya que permite leer y escribir datos persistentes. En Kotlin , utilizando las bibliotecas de Java ( java.io y java.nio ), se pueden manejar diferentes tipos de ficheros (texto, binarios, im\u00e1genes...), seg\u00fan sus caracter\u00edsticas y necesidades, y seg\u00fan su forma de acceder a ellos. Existen dos formas principales de acceder a un fichero: Acceso secuencial Los datos se procesan en orden, desde el principio hasta el final del fichero. Es el m\u00e1s com\u00fan y sencillo. Se usa cuando se desea leer todo el contenido o recorrer registro por registro, por ejemplo la lectura de un archivo de texto l\u00ednea por l\u00ednea, o de un fichero binario estructurado registro a registro. Acceso aleatorio Permite saltar a una posici\u00f3n concreta del fichero sin necesidad de leer lo anterior. Es \u00fatil cuando los registros tienen un tama\u00f1o fijo y se necesita eficiencia (por ejemplo, ir directamente al registro 100). Requiere t\u00e9cnicas m\u00e1s avanzadas como el uso de FileChannel , SeekableByteChannel o RandomAccessFile .","title":"\ud83d\udd39 Formas de acceso a un fichero"},{"location":"T2_Gestion_del_contenido/Lectura_Escritura_ficheros/","text":"\ud83d\udd39Lectura y escritura de ficheros Ejemplos Los ejemplos de esta parte se incluir\u00e1n en el paquete contenido , dentro de nuestro proyecto Ficheros . Tambi\u00e9n ser\u00e1 neceario crear las carpetas documentos y documentos2 para guardar los archivos generados. \ud83d\udd39Ficheros de texto y binarios En el desarrollo de software, los ficheros de texto y los ficheros binarios son los dos tipos de archivos m\u00e1s comunes y utilizados para almacenar y gestionar informaci\u00f3n. Ficheros de texto : contienen \u00fanicamente caracteres. Su contenido se puede leer y escribir con cualquier editor de texto, como .txt, .csv, .json, .xml, etc. Ficheros binarios : son ficheros que contienen cualquier tipo de informaci\u00f3n (texto, im\u00e1genes, v\u00eddeos, ficheros\u2026) codificada como bytes. En general, requiere de programas especiales para mostrar la informaci\u00f3n que contienen. \ud83d\udcc4Lectura y escritura de un archivo de texto Tipo de fichero Lectura Escritura Comentario Texto (l\u00edneas) Files.readAllLines(Path) Files.write(Path, List<String>) Carga todo en memoria Files.newBufferedReader(Path) Files.newBufferedWriter(Path) M\u00e1s eficiente para archivos grandes Files.readString(Path) (Java 11+) Files.writeString(Path, String) Lectura/escritura completa como bloque \ud83d\udda5\ufe0f Ejemplo_Lect_esc_ficheroTexto.kt : lectura y escritura en ficheros de texto (UTF-8) import java.nio.file.Files import java.nio.file.Paths import java.nio.charset.StandardCharsets fun main() { val ruta = Paths.get(\"documentos/texto.txt\") //Escritura en fichero de texto val lineasParaGuardar = listOf( \"Primera l\u00ednea\", \"Segunda l\u00ednea\", \"\u00a1Hola desde Kotlin!\" ) Files.write(ruta, lineasParaGuardar, StandardCharsets.UTF_8) println(\"Fichero de texto escrito.\") //Lectura del fichero de texto //readAllLines val lineasLeidas = Files.readAllLines(ruta) println(\"Contenido le\u00eddo con readAllLines:\") for (lineas in lineasLeidas) { println(lineas) } //readString val contenido = Files.readString(ruta) println(\"Contenido le\u00eddo con readString:\") println(contenido) //newBufferedReader Files.newBufferedReader(ruta).use { reader -> println(\"Contenido le\u00eddo con newBufferedReader:\") reader.lineSequence().forEach { println(it) } } } \ud83e\udde9 Lectura y escritura de un archivo binario Tipo de fichero Lectura Escritura Comentario Binario Files.readAllBytes(Path) Files.write(Path, ByteArray) Lee y escribe bytes puros Files.newInputStream(Path) Files.newOutputStream(Path) Flujo de bytes directo \ud83d\udda5\ufe0f Ejemplo_Lect_esc_ficheroBinario.kt : lectura y escritura en ficheros binario import java.nio.file.Files import java.nio.file.Paths fun main() { val ruta = Paths.get(\"documentos/datos.bin\") //Escritura en fichero binario val datos = byteArrayOf(1, 2, 3, 4, 5) Files.write(ruta, datos) println(\"Archivo binario creado: ${ruta.toAbsolutePath()}\") val bytes = Files.readAllBytes(ruta) println(\"Contenido le\u00eddo (byte a byte):\") for (b in bytes) { print(\"$b \") } } \ud83d\udd39Ficheros de imagen Los ficheros de imagen contienen datos que representan gr\u00e1ficamente una imagen visual (fotograf\u00edas, ilustraciones, iconos, etc.). A diferencia de los ficheros de texto o binarios crudos, estos archivos tienen estructura interna que depende del formato (como .png, .jpg, .bmp, etc.). \ud83d\udce6 Formatos m\u00e1s comunes .jpg : Comprimido con p\u00e9rdida, ideal para fotos .png : Comprimido sin p\u00e9rdida, soporta transparencia .bmp : Sin compresi\u00f3n, ocupa m\u00e1s espacio .gif : Admite animaciones simples, limitada a 256 colores En la plataforma Java (y por tanto en Kotlin), el manejo de im\u00e1genes se hace generalmente usando: ImageIO : para leer y escribir im\u00e1genes BufferedImage : para acceder y modificar p\u00edxeles Tipo de fichero Lectura Escritura Comentario Imagen ImageIO.read(Path/File) ImageIO.write(BufferedImage, ...) Usa javax.imageio.ImageIO \ud83d\udda5\ufe0f Ejemplo_generar_imagen.kt: genera una imagen de ejemplo. import java.awt.Color import java.awt.image.BufferedImage import java.io.File import javax.imageio.ImageIO fun main() { val ancho = 200 val alto = 100 val imagen = BufferedImage(ancho, alto, BufferedImage.TYPE_INT_RGB) // Rellenar la imagen con colores for (x in 0 until ancho) { for (y in 0 until alto) { val rojo = (x * 255) / ancho val verde = (y * 255) / alto val azul = 128 val color = Color(rojo, verde, azul) imagen.setRGB(x, y, color.rgb) } } // Guardar la imagen val archivo = File(\"documentos/imagen_generada.png\") ImageIO.write(imagen, \"png\", archivo) println(\"\u2705 Imagen generada correctamente: ${archivo.absolutePath}\") } \ud83d\udda5\ufe0f Ejemplo_invertircolores_imagen.kt: invierte los colores de la imagen generada en el ejemplo atenerior. import java.awt.Color import java.awt.image.BufferedImage import java.io.File import javax.imageio.ImageIO fun main() { val archivoEntrada = File(\"documentos/imagen_generada.png\") val archivoSalida = File(\"documentos/imagen_salida.png\") // Leer imagen original val imagen: BufferedImage = ImageIO.read(archivoEntrada) // Recorrer todos los p\u00edxeles for (x in 0 until imagen.width) { for (y in 0 until imagen.height) { val colorOriginal = Color(imagen.getRGB(x, y)) val colorInvertido = Color( 255 - colorOriginal.red, 255 - colorOriginal.green, 255 - colorOriginal.blue ) imagen.setRGB(x, y, colorInvertido.rgb) } } // Guardar imagen modificada ImageIO.write(imagen, \"png\", archivoSalida) println(\"\u2705 Imagen guardada como ${archivoSalida.name}\") } \ud83d\udda5\ufe0f Ejemplo_img_penyagolosa.kt: Invierte los colores de una imagen. Copia la imagen penyagolosa.png en la capreta documentos imagen a copiar (penyagolosa.png) imagen con los colores invertidos import java.awt.Color import java.awt.image.BufferedImage import java.nio.file.Files import java.nio.file.Path import java.nio.file.StandardCopyOption import javax.imageio.ImageIO fun main() { val originalPath = Path.of(\"documentos/penyagolosa.png\") val copiaPath = Path.of(\"documentos/penyagolosa_copia.png\") val modificadaPath = Path.of(\"documentos/penyagolosa_modificada.png\") // 1. Comprobar si la imagen existe if (!Files.exists(originalPath)) { println(\"No se encuentra la imagen original: $originalPath\") return } // 2. Copiar la imagen con java.nio Files.copy(originalPath, copiaPath, StandardCopyOption.REPLACE_EXISTING) println(\"Imagen copiada a: $copiaPath\") // 3. Leer la imagen como BufferedImage val imagen: BufferedImage = ImageIO.read(copiaPath.toFile()) // 4. Invertir colores for (x in 0 until imagen.width) { for (y in 0 until imagen.height) { val color = Color(imagen.getRGB(x, y)) val invertido = Color(255 - color.red, 255 - color.green, 255 - color.blue) imagen.setRGB(x, y, invertido.rgb) } } // 5. Guardar la imagen modificada ImageIO.write(imagen, \"png\", modificadaPath.toFile()) println(\"Imagen modificada guardada como: $modificadaPath\") } \ud83d\udd39Ficheros binarios estructurados Aunque java.nio.file es la API moderna para trabajar con rutas y archivos, las clases DataOutputStream y DataInputStream de java.io siguen siendo la opci\u00f3n m\u00e1s adecuada para escribir y leer binario estructurado . Son m\u00e1s simples, seguras, portables y claras para representar estructuras secuenciales como registros. En contextos donde se requiera rendimiento avanzado o acceso aleatorio, puede usarse FileChannel y ByteBuffer , aunque su complejidad las hace menos recomendables. Clases y m\u00e9todo de DataInputStream y DataOutputStream Clase M\u00e9todo Tipo de dato Descripci\u00f3n DataOutputStream writeInt(int) Entero (4 bytes) Escribe un entero con signo writeDouble(double) Decimal (8 bytes) Escribe un n\u00famero en coma flotante writeFloat(float) Decimal (4 bytes) Escribe un n\u00famero float writeLong(long) Entero largo (8 bytes) Escribe un long writeBoolean(boolean) Booleano (1 byte) Escribe un valor verdadero/falso writeChar(char) Car\u00e1cter (2 bytes) Escribe un car\u00e1cter Unicode writeUTF(String) Cadena UTF-8 Escribe una cadena precedida por su longitud en 2 bytes writeByte(int) Byte (1 byte) Escribe un solo byte writeShort(int) Entero corto (2 bytes) Escribe un short DataInputStream readInt() Entero Lee un entero con signo readDouble() Decimal Lee un n\u00famero double readFloat() Decimal Lee un n\u00famero float readLong() Entero largo Lee un long readBoolean() Booleano Lee un valor verdadero/falso readChar() Car\u00e1cter Lee un car\u00e1cter Unicode readUTF() Cadena UTF-8 Lee una cadena UTF-8 readByte() Byte Lee un byte readShort() Entero corto Lee un short \ud83d\udda5\ufe0f Ejemplo_binario_estructurado.kt : Lectura y escritura en ficheros binarios (con tipos primitivos). import java.io.DataInputStream import java.io.DataOutputStream import java.io.FileInputStream import java.io.FileOutputStream import java.nio.file.Files import java.nio.file.Paths fun main() { val ruta = Paths.get(\"documentos/binario.dat\") Files.createDirectories(ruta.parent) // Escritura binaria val out= DataOutputStream(Files.newOutputStream(ruta)).use { out -> //devuelve OutputStream out.writeInt(42) // int (4 bytes) out.writeDouble(3.1416) // double (8 bytes) out.writeUTF(\"K\") // char (2 bytes) } println(\"\u2705 Fichero binario escrito con DataOutputStream (sin lambda).\") // Lectura binaria val fis = FileInputStream(ruta.toFile()) val input = DataInputStream(fis) val entero = input.readInt() val decimal = input.readDouble() val caracter = input.readUTF() input.close() fis.close() println(\"\ud83d\udcc4 Contenido le\u00eddo:\") println(\" Int: $entero\") println(\" Double: $decimal\") println(\" Char: $caracter\") } \ud83d\udd39Ficheros de acceso aleatorio Hasta el momento todos los accesos que hemos hecho a los archivos, tanto binarios como de texto, han sido secuenciales. Esto significa que siempre empezamos por el principio del archivo hasta que llegamos a la informaci\u00f3n que queremos, o en la mayor parte de los casos hasta el final de archivo. Pero, \u00bfy si queremos \u00fanicamente una determinada informaci\u00f3n? Afortunadamente hay otra forma de acceder, otro tipo de acceso. Se llama acceso directo o aleatorio , porque permitir\u00e1 ir directamente a una posici\u00f3n determinada del archivo. Cuando se necesita mayor control, eficiencia y rendimiento en el acceso a ficheros, especialmente en operaciones binarias o de acceso aleatorio, el enfoque tradicional con la clase RandomAccessFile de Java.io puede quedarse corto. Para estos casos, Java ofrece una soluci\u00f3n moderna a trav\u00e9s del paquete java.nio.file combinado con FileChannel y ByteBuffer . Las clases FileChannel , ByteBuffer y StandardOpenOption forman parte de la API java.nio y se utilizan juntas para realizar lectura y escritura de archivos binarios y en el acceso aleatorio a ficheros . FileChannel Tipo de fichero Lectura Escritura Comentario Acceso aleatorio FileChannel.position(offset) FileChannel.position(offset) Permite saltar a cualquier posici\u00f3n del fichero M\u00e9todos habituales de FileChannel para el acceso aleatorio a ficheros M\u00e9todo Funci\u00f3n principal position() Devuelve la posici\u00f3n actual del puntero en el archivo position(long) Establece una posici\u00f3n exacta para lectura/escritura truncate(long) Recorta o ampl\u00eda el tama\u00f1o del archivo size() Devuelve el tama\u00f1o total actual del archivo ByteBuffer ByteBuffer se utiliza en archivos de acceso aleatorio porque permite leer y escribir bloques binarios de datos en posiciones espec\u00edficas del archivo de forma eficiente y controlada. M\u00e9todos de creaci\u00f3n M\u00e9todo Descripci\u00f3n allocate(capacidad) Crea un buffer con capacidad fija en memoria (no compartida). wrap(byteArray) Crea un buffer que envuelve un array de bytes existente (memoria compartida). wrap(byteArray, offset, length) Crea un buffer desde una porci\u00f3n del array existente. M\u00e9todos de escritura ( put ) M\u00e9todo Descripci\u00f3n put(byte) Escribe un byte en la posici\u00f3n actual. putInt(int) Escribe un valor int . putDouble(double) Escribe un valor double . putFloat(float) Escribe un valor float . putChar(char) Escribe un car\u00e1cter ( char , 2 bytes). putShort(short) Escribe un valor short . putLong(long) Escribe un valor long . put(byte[], offset, length)` Escribe una porci\u00f3n de un array de bytes. M\u00e9todos de lectura ( get ) M\u00e9todo Descripci\u00f3n get() Lee un byte desde la posici\u00f3n actual. getInt() Lee un valor int . getDouble() Lee un valor double . getFloat() Lee un valor float . getChar() Lee un car\u00e1cter ( char ). getShort() Lee un valor short . getLong() Lee un valor long . get(byte[], offset, length)` Lee una porci\u00f3n del buffer a un array. M\u00e9todos de control del buffer M\u00e9todo Descripci\u00f3n position() Devuelve la posici\u00f3n actual del cursor. position(int) Establece la posici\u00f3n del cursor. limit() Devuelve el l\u00edmite del buffer. limit(int) Establece un nuevo l\u00edmite. capacity() Devuelve la capacidad total del buffer. clear() Limpia el buffer: posici\u00f3n a 0, l\u00edmite al m\u00e1ximo (sin borrar contenido). flip() Prepara el buffer para lectura despu\u00e9s de escribir. rewind() Posici\u00f3n a 0 para releer desde el inicio. remaining Indica cu\u00e1ntos elementos quedan por procesar. hasRemaining() true si a\u00fan queda contenido por leer o escribir. StandardOpenOption Se utiliza para indicar c\u00f3mo debe abrirse o crearse un archivo al trabajar con FileChannel o Files.newOutputStream, Files.newByteChannel, etc. Se utiliza para indicar si el archivo se va a: Leer (READ) , Escribir (WRITE) , Crear (CREATE) , sobrescribir (TRUNCATE_EXISTING) , A\u00f1adir al final (APPEND) . val canal = FileChannel.open( Paths.get(\"archivo.txt\"), StandardOpenOption.WRITE, StandardOpenOption.CREATE ) \ud83d\udda5\ufe0f Ejemplo_acceso_posicion.kt : realiza una operaci\u00f3n b\u00e1sica de lectura y escritura de archivo de texto usando FileChannel y ByteBuffer . // Importamos las clases necesarias import java.nio.ByteBuffer // Para gestionar buffers de bytes import java.nio.channels.FileChannel // Para acceder al archivo como canal import java.nio.file.Paths // Para crear la ruta del archivo import java.nio.file.StandardOpenOption.* // Para usar opciones como READ, WRITE, CREATE fun main() { // Creamos una ruta al archivo datos.txt val path = Paths.get(\"documentos/datos.txt\") // Abrimos el canal con permisos de lectura, escritura y creaci\u00f3n FileChannel.open(path, READ, WRITE, CREATE).use { canal -> // Creamos un buffer con el texto a escribir convertido a bytes val buffer = ByteBuffer.wrap(\"Hola desde Kotlin\\n\".toByteArray()) // Establecemos la posici\u00f3n del canal al principio del archivo canal.position(0) // Escribimos el contenido del buffer en el archivo canal.write(buffer) // Creamos un nuevo buffer vac\u00edo para leer hasta 1024 bytes val bufferLectura = ByteBuffer.allocate(1024) // Volvemos al principio del archivo para leer desde el inicio canal.position(0) // Leemos desde el archivo al buffer canal.read(bufferLectura) // Cambiamos el buffer de modo escritura a modo lectura bufferLectura.flip() // Convertimos el contenido le\u00eddo a cadena y lo mostramos println(String(bufferLectura.array(), 0, bufferLectura.limit())) } // El canal se cierra autom\u00e1ticamente gracias a `use` } \ud83d\udda5\ufe0f Ejemplo_acceso_aleatorio.kt : acceso directo a posiciones en un archivo con FileChannel y ByteBuffer . import java.nio.ByteBuffer import java.nio.channels.FileChannel import java.nio.file.Paths import java.nio.file.StandardOpenOption.* fun main() { val path = Paths.get(\"documentos/datos.txt\") // Abrimos el canal con permisos de lectura y escritura FileChannel.open(path, READ, WRITE, CREATE).use { canal -> // Escribimos \"Inicio\\n\" en la posici\u00f3n 0 del archivo canal.position(0) val inicio = ByteBuffer.wrap(\"Inicio\\n\".toByteArray()) canal.write(inicio) // Escribimos \"Texto en posici\u00f3n 20\\n\" en la posici\u00f3n 20 del archivo canal.position(20) val texto = ByteBuffer.wrap(\"Texto en posici\u00f3n 20\\n\".toByteArray()) canal.write(texto) // Leemos el contenido completo desde el inicio (posici\u00f3n 0) val bufferLectura = ByteBuffer.allocate(1024) canal.position(0) canal.read(bufferLectura) // Preparamos el buffer para lectura e imprimimos el contenido bufferLectura.flip() val contenido = String(bufferLectura.array(), 0, bufferLectura.limit()) println(\"Contenido le\u00eddo del archivo:\\n$contenido\") } }","title":"\ud83d\udd39Lectura y escritura de ficheros"},{"location":"T2_Gestion_del_contenido/Lectura_Escritura_ficheros/#lectura-y-escritura-de-ficheros","text":"Ejemplos Los ejemplos de esta parte se incluir\u00e1n en el paquete contenido , dentro de nuestro proyecto Ficheros . Tambi\u00e9n ser\u00e1 neceario crear las carpetas documentos y documentos2 para guardar los archivos generados.","title":"\ud83d\udd39Lectura y escritura de ficheros"},{"location":"T2_Gestion_del_contenido/Lectura_Escritura_ficheros/#ficheros-de-texto-y-binarios","text":"En el desarrollo de software, los ficheros de texto y los ficheros binarios son los dos tipos de archivos m\u00e1s comunes y utilizados para almacenar y gestionar informaci\u00f3n. Ficheros de texto : contienen \u00fanicamente caracteres. Su contenido se puede leer y escribir con cualquier editor de texto, como .txt, .csv, .json, .xml, etc. Ficheros binarios : son ficheros que contienen cualquier tipo de informaci\u00f3n (texto, im\u00e1genes, v\u00eddeos, ficheros\u2026) codificada como bytes. En general, requiere de programas especiales para mostrar la informaci\u00f3n que contienen. \ud83d\udcc4Lectura y escritura de un archivo de texto Tipo de fichero Lectura Escritura Comentario Texto (l\u00edneas) Files.readAllLines(Path) Files.write(Path, List<String>) Carga todo en memoria Files.newBufferedReader(Path) Files.newBufferedWriter(Path) M\u00e1s eficiente para archivos grandes Files.readString(Path) (Java 11+) Files.writeString(Path, String) Lectura/escritura completa como bloque \ud83d\udda5\ufe0f Ejemplo_Lect_esc_ficheroTexto.kt : lectura y escritura en ficheros de texto (UTF-8) import java.nio.file.Files import java.nio.file.Paths import java.nio.charset.StandardCharsets fun main() { val ruta = Paths.get(\"documentos/texto.txt\") //Escritura en fichero de texto val lineasParaGuardar = listOf( \"Primera l\u00ednea\", \"Segunda l\u00ednea\", \"\u00a1Hola desde Kotlin!\" ) Files.write(ruta, lineasParaGuardar, StandardCharsets.UTF_8) println(\"Fichero de texto escrito.\") //Lectura del fichero de texto //readAllLines val lineasLeidas = Files.readAllLines(ruta) println(\"Contenido le\u00eddo con readAllLines:\") for (lineas in lineasLeidas) { println(lineas) } //readString val contenido = Files.readString(ruta) println(\"Contenido le\u00eddo con readString:\") println(contenido) //newBufferedReader Files.newBufferedReader(ruta).use { reader -> println(\"Contenido le\u00eddo con newBufferedReader:\") reader.lineSequence().forEach { println(it) } } } \ud83e\udde9 Lectura y escritura de un archivo binario Tipo de fichero Lectura Escritura Comentario Binario Files.readAllBytes(Path) Files.write(Path, ByteArray) Lee y escribe bytes puros Files.newInputStream(Path) Files.newOutputStream(Path) Flujo de bytes directo \ud83d\udda5\ufe0f Ejemplo_Lect_esc_ficheroBinario.kt : lectura y escritura en ficheros binario import java.nio.file.Files import java.nio.file.Paths fun main() { val ruta = Paths.get(\"documentos/datos.bin\") //Escritura en fichero binario val datos = byteArrayOf(1, 2, 3, 4, 5) Files.write(ruta, datos) println(\"Archivo binario creado: ${ruta.toAbsolutePath()}\") val bytes = Files.readAllBytes(ruta) println(\"Contenido le\u00eddo (byte a byte):\") for (b in bytes) { print(\"$b \") } }","title":"\ud83d\udd39Ficheros de texto y binarios"},{"location":"T2_Gestion_del_contenido/Lectura_Escritura_ficheros/#ficheros-de-imagen","text":"Los ficheros de imagen contienen datos que representan gr\u00e1ficamente una imagen visual (fotograf\u00edas, ilustraciones, iconos, etc.). A diferencia de los ficheros de texto o binarios crudos, estos archivos tienen estructura interna que depende del formato (como .png, .jpg, .bmp, etc.). \ud83d\udce6 Formatos m\u00e1s comunes .jpg : Comprimido con p\u00e9rdida, ideal para fotos .png : Comprimido sin p\u00e9rdida, soporta transparencia .bmp : Sin compresi\u00f3n, ocupa m\u00e1s espacio .gif : Admite animaciones simples, limitada a 256 colores En la plataforma Java (y por tanto en Kotlin), el manejo de im\u00e1genes se hace generalmente usando: ImageIO : para leer y escribir im\u00e1genes BufferedImage : para acceder y modificar p\u00edxeles Tipo de fichero Lectura Escritura Comentario Imagen ImageIO.read(Path/File) ImageIO.write(BufferedImage, ...) Usa javax.imageio.ImageIO \ud83d\udda5\ufe0f Ejemplo_generar_imagen.kt: genera una imagen de ejemplo. import java.awt.Color import java.awt.image.BufferedImage import java.io.File import javax.imageio.ImageIO fun main() { val ancho = 200 val alto = 100 val imagen = BufferedImage(ancho, alto, BufferedImage.TYPE_INT_RGB) // Rellenar la imagen con colores for (x in 0 until ancho) { for (y in 0 until alto) { val rojo = (x * 255) / ancho val verde = (y * 255) / alto val azul = 128 val color = Color(rojo, verde, azul) imagen.setRGB(x, y, color.rgb) } } // Guardar la imagen val archivo = File(\"documentos/imagen_generada.png\") ImageIO.write(imagen, \"png\", archivo) println(\"\u2705 Imagen generada correctamente: ${archivo.absolutePath}\") } \ud83d\udda5\ufe0f Ejemplo_invertircolores_imagen.kt: invierte los colores de la imagen generada en el ejemplo atenerior. import java.awt.Color import java.awt.image.BufferedImage import java.io.File import javax.imageio.ImageIO fun main() { val archivoEntrada = File(\"documentos/imagen_generada.png\") val archivoSalida = File(\"documentos/imagen_salida.png\") // Leer imagen original val imagen: BufferedImage = ImageIO.read(archivoEntrada) // Recorrer todos los p\u00edxeles for (x in 0 until imagen.width) { for (y in 0 until imagen.height) { val colorOriginal = Color(imagen.getRGB(x, y)) val colorInvertido = Color( 255 - colorOriginal.red, 255 - colorOriginal.green, 255 - colorOriginal.blue ) imagen.setRGB(x, y, colorInvertido.rgb) } } // Guardar imagen modificada ImageIO.write(imagen, \"png\", archivoSalida) println(\"\u2705 Imagen guardada como ${archivoSalida.name}\") } \ud83d\udda5\ufe0f Ejemplo_img_penyagolosa.kt: Invierte los colores de una imagen. Copia la imagen penyagolosa.png en la capreta documentos imagen a copiar (penyagolosa.png) imagen con los colores invertidos import java.awt.Color import java.awt.image.BufferedImage import java.nio.file.Files import java.nio.file.Path import java.nio.file.StandardCopyOption import javax.imageio.ImageIO fun main() { val originalPath = Path.of(\"documentos/penyagolosa.png\") val copiaPath = Path.of(\"documentos/penyagolosa_copia.png\") val modificadaPath = Path.of(\"documentos/penyagolosa_modificada.png\") // 1. Comprobar si la imagen existe if (!Files.exists(originalPath)) { println(\"No se encuentra la imagen original: $originalPath\") return } // 2. Copiar la imagen con java.nio Files.copy(originalPath, copiaPath, StandardCopyOption.REPLACE_EXISTING) println(\"Imagen copiada a: $copiaPath\") // 3. Leer la imagen como BufferedImage val imagen: BufferedImage = ImageIO.read(copiaPath.toFile()) // 4. Invertir colores for (x in 0 until imagen.width) { for (y in 0 until imagen.height) { val color = Color(imagen.getRGB(x, y)) val invertido = Color(255 - color.red, 255 - color.green, 255 - color.blue) imagen.setRGB(x, y, invertido.rgb) } } // 5. Guardar la imagen modificada ImageIO.write(imagen, \"png\", modificadaPath.toFile()) println(\"Imagen modificada guardada como: $modificadaPath\") }","title":"\ud83d\udd39Ficheros de imagen"},{"location":"T2_Gestion_del_contenido/Lectura_Escritura_ficheros/#ficheros-binarios-estructurados","text":"Aunque java.nio.file es la API moderna para trabajar con rutas y archivos, las clases DataOutputStream y DataInputStream de java.io siguen siendo la opci\u00f3n m\u00e1s adecuada para escribir y leer binario estructurado . Son m\u00e1s simples, seguras, portables y claras para representar estructuras secuenciales como registros. En contextos donde se requiera rendimiento avanzado o acceso aleatorio, puede usarse FileChannel y ByteBuffer , aunque su complejidad las hace menos recomendables. Clases y m\u00e9todo de DataInputStream y DataOutputStream Clase M\u00e9todo Tipo de dato Descripci\u00f3n DataOutputStream writeInt(int) Entero (4 bytes) Escribe un entero con signo writeDouble(double) Decimal (8 bytes) Escribe un n\u00famero en coma flotante writeFloat(float) Decimal (4 bytes) Escribe un n\u00famero float writeLong(long) Entero largo (8 bytes) Escribe un long writeBoolean(boolean) Booleano (1 byte) Escribe un valor verdadero/falso writeChar(char) Car\u00e1cter (2 bytes) Escribe un car\u00e1cter Unicode writeUTF(String) Cadena UTF-8 Escribe una cadena precedida por su longitud en 2 bytes writeByte(int) Byte (1 byte) Escribe un solo byte writeShort(int) Entero corto (2 bytes) Escribe un short DataInputStream readInt() Entero Lee un entero con signo readDouble() Decimal Lee un n\u00famero double readFloat() Decimal Lee un n\u00famero float readLong() Entero largo Lee un long readBoolean() Booleano Lee un valor verdadero/falso readChar() Car\u00e1cter Lee un car\u00e1cter Unicode readUTF() Cadena UTF-8 Lee una cadena UTF-8 readByte() Byte Lee un byte readShort() Entero corto Lee un short \ud83d\udda5\ufe0f Ejemplo_binario_estructurado.kt : Lectura y escritura en ficheros binarios (con tipos primitivos). import java.io.DataInputStream import java.io.DataOutputStream import java.io.FileInputStream import java.io.FileOutputStream import java.nio.file.Files import java.nio.file.Paths fun main() { val ruta = Paths.get(\"documentos/binario.dat\") Files.createDirectories(ruta.parent) // Escritura binaria val out= DataOutputStream(Files.newOutputStream(ruta)).use { out -> //devuelve OutputStream out.writeInt(42) // int (4 bytes) out.writeDouble(3.1416) // double (8 bytes) out.writeUTF(\"K\") // char (2 bytes) } println(\"\u2705 Fichero binario escrito con DataOutputStream (sin lambda).\") // Lectura binaria val fis = FileInputStream(ruta.toFile()) val input = DataInputStream(fis) val entero = input.readInt() val decimal = input.readDouble() val caracter = input.readUTF() input.close() fis.close() println(\"\ud83d\udcc4 Contenido le\u00eddo:\") println(\" Int: $entero\") println(\" Double: $decimal\") println(\" Char: $caracter\") }","title":"\ud83d\udd39Ficheros binarios estructurados"},{"location":"T2_Gestion_del_contenido/Lectura_Escritura_ficheros/#ficheros-de-acceso-aleatorio","text":"Hasta el momento todos los accesos que hemos hecho a los archivos, tanto binarios como de texto, han sido secuenciales. Esto significa que siempre empezamos por el principio del archivo hasta que llegamos a la informaci\u00f3n que queremos, o en la mayor parte de los casos hasta el final de archivo. Pero, \u00bfy si queremos \u00fanicamente una determinada informaci\u00f3n? Afortunadamente hay otra forma de acceder, otro tipo de acceso. Se llama acceso directo o aleatorio , porque permitir\u00e1 ir directamente a una posici\u00f3n determinada del archivo. Cuando se necesita mayor control, eficiencia y rendimiento en el acceso a ficheros, especialmente en operaciones binarias o de acceso aleatorio, el enfoque tradicional con la clase RandomAccessFile de Java.io puede quedarse corto. Para estos casos, Java ofrece una soluci\u00f3n moderna a trav\u00e9s del paquete java.nio.file combinado con FileChannel y ByteBuffer . Las clases FileChannel , ByteBuffer y StandardOpenOption forman parte de la API java.nio y se utilizan juntas para realizar lectura y escritura de archivos binarios y en el acceso aleatorio a ficheros . FileChannel Tipo de fichero Lectura Escritura Comentario Acceso aleatorio FileChannel.position(offset) FileChannel.position(offset) Permite saltar a cualquier posici\u00f3n del fichero M\u00e9todos habituales de FileChannel para el acceso aleatorio a ficheros M\u00e9todo Funci\u00f3n principal position() Devuelve la posici\u00f3n actual del puntero en el archivo position(long) Establece una posici\u00f3n exacta para lectura/escritura truncate(long) Recorta o ampl\u00eda el tama\u00f1o del archivo size() Devuelve el tama\u00f1o total actual del archivo ByteBuffer ByteBuffer se utiliza en archivos de acceso aleatorio porque permite leer y escribir bloques binarios de datos en posiciones espec\u00edficas del archivo de forma eficiente y controlada. M\u00e9todos de creaci\u00f3n M\u00e9todo Descripci\u00f3n allocate(capacidad) Crea un buffer con capacidad fija en memoria (no compartida). wrap(byteArray) Crea un buffer que envuelve un array de bytes existente (memoria compartida). wrap(byteArray, offset, length) Crea un buffer desde una porci\u00f3n del array existente. M\u00e9todos de escritura ( put ) M\u00e9todo Descripci\u00f3n put(byte) Escribe un byte en la posici\u00f3n actual. putInt(int) Escribe un valor int . putDouble(double) Escribe un valor double . putFloat(float) Escribe un valor float . putChar(char) Escribe un car\u00e1cter ( char , 2 bytes). putShort(short) Escribe un valor short . putLong(long) Escribe un valor long . put(byte[], offset, length)` Escribe una porci\u00f3n de un array de bytes. M\u00e9todos de lectura ( get ) M\u00e9todo Descripci\u00f3n get() Lee un byte desde la posici\u00f3n actual. getInt() Lee un valor int . getDouble() Lee un valor double . getFloat() Lee un valor float . getChar() Lee un car\u00e1cter ( char ). getShort() Lee un valor short . getLong() Lee un valor long . get(byte[], offset, length)` Lee una porci\u00f3n del buffer a un array. M\u00e9todos de control del buffer M\u00e9todo Descripci\u00f3n position() Devuelve la posici\u00f3n actual del cursor. position(int) Establece la posici\u00f3n del cursor. limit() Devuelve el l\u00edmite del buffer. limit(int) Establece un nuevo l\u00edmite. capacity() Devuelve la capacidad total del buffer. clear() Limpia el buffer: posici\u00f3n a 0, l\u00edmite al m\u00e1ximo (sin borrar contenido). flip() Prepara el buffer para lectura despu\u00e9s de escribir. rewind() Posici\u00f3n a 0 para releer desde el inicio. remaining Indica cu\u00e1ntos elementos quedan por procesar. hasRemaining() true si a\u00fan queda contenido por leer o escribir. StandardOpenOption Se utiliza para indicar c\u00f3mo debe abrirse o crearse un archivo al trabajar con FileChannel o Files.newOutputStream, Files.newByteChannel, etc. Se utiliza para indicar si el archivo se va a: Leer (READ) , Escribir (WRITE) , Crear (CREATE) , sobrescribir (TRUNCATE_EXISTING) , A\u00f1adir al final (APPEND) . val canal = FileChannel.open( Paths.get(\"archivo.txt\"), StandardOpenOption.WRITE, StandardOpenOption.CREATE ) \ud83d\udda5\ufe0f Ejemplo_acceso_posicion.kt : realiza una operaci\u00f3n b\u00e1sica de lectura y escritura de archivo de texto usando FileChannel y ByteBuffer . // Importamos las clases necesarias import java.nio.ByteBuffer // Para gestionar buffers de bytes import java.nio.channels.FileChannel // Para acceder al archivo como canal import java.nio.file.Paths // Para crear la ruta del archivo import java.nio.file.StandardOpenOption.* // Para usar opciones como READ, WRITE, CREATE fun main() { // Creamos una ruta al archivo datos.txt val path = Paths.get(\"documentos/datos.txt\") // Abrimos el canal con permisos de lectura, escritura y creaci\u00f3n FileChannel.open(path, READ, WRITE, CREATE).use { canal -> // Creamos un buffer con el texto a escribir convertido a bytes val buffer = ByteBuffer.wrap(\"Hola desde Kotlin\\n\".toByteArray()) // Establecemos la posici\u00f3n del canal al principio del archivo canal.position(0) // Escribimos el contenido del buffer en el archivo canal.write(buffer) // Creamos un nuevo buffer vac\u00edo para leer hasta 1024 bytes val bufferLectura = ByteBuffer.allocate(1024) // Volvemos al principio del archivo para leer desde el inicio canal.position(0) // Leemos desde el archivo al buffer canal.read(bufferLectura) // Cambiamos el buffer de modo escritura a modo lectura bufferLectura.flip() // Convertimos el contenido le\u00eddo a cadena y lo mostramos println(String(bufferLectura.array(), 0, bufferLectura.limit())) } // El canal se cierra autom\u00e1ticamente gracias a `use` } \ud83d\udda5\ufe0f Ejemplo_acceso_aleatorio.kt : acceso directo a posiciones en un archivo con FileChannel y ByteBuffer . import java.nio.ByteBuffer import java.nio.channels.FileChannel import java.nio.file.Paths import java.nio.file.StandardOpenOption.* fun main() { val path = Paths.get(\"documentos/datos.txt\") // Abrimos el canal con permisos de lectura y escritura FileChannel.open(path, READ, WRITE, CREATE).use { canal -> // Escribimos \"Inicio\\n\" en la posici\u00f3n 0 del archivo canal.position(0) val inicio = ByteBuffer.wrap(\"Inicio\\n\".toByteArray()) canal.write(inicio) // Escribimos \"Texto en posici\u00f3n 20\\n\" en la posici\u00f3n 20 del archivo canal.position(20) val texto = ByteBuffer.wrap(\"Texto en posici\u00f3n 20\\n\".toByteArray()) canal.write(texto) // Leemos el contenido completo desde el inicio (posici\u00f3n 0) val bufferLectura = ByteBuffer.allocate(1024) canal.position(0) canal.read(bufferLectura) // Preparamos el buffer para lectura e imprimimos el contenido bufferLectura.flip() val contenido = String(bufferLectura.array(), 0, bufferLectura.limit()) println(\"Contenido le\u00eddo del archivo:\\n$contenido\") } }","title":"\ud83d\udd39Ficheros de acceso aleatorio"},{"location":"T2_Gestion_del_contenido/clases/","text":"\ud83d\udd39 Clases y m\u00e9todos sobre ficheros. Java.nio En el desarrollo de aplicaciones es com\u00fan tener que leer y escribir datos almacenados en archivos. Seg\u00fan el tipo de contenido del fichero (texto, binario, imagen, estructurado...), se utilizan clases y m\u00e9todos distintos para acceder a ellos de forma eficiente y segura. Kotlin se apoya en las bibliotecas de Java ( java.io y java.nio.file ) para realizar estas operaciones, permitiendo un control detallado tanto para acceso secuencial como aleatorio. java.io : API tradicional basada en flujos de bytes o caracteres. java.nio (New I/O): API moderna basada en canales y buffers, introducida para mejorar el rendimiento y la flexibilidad. En el desarrollo actual, especialmente en aplicaciones que manejan datos estructurados, binarios o grandes vol\u00famenes de informaci\u00f3n, es preferible utilizar java.nio , por lo que ser\u00e1 la API que utilizaremos en los ejemplos y ejercicios. La siguiente tabla resume las clases m\u00e1s utilizadas para trabajar con los distintos tipos de ficheros, indicando las opciones recomendadas para lectura y escritura, y proporcionando notas aclaratorias sobre su uso t\u00edpico. Resumen de clases y m\u00e9todos para el acceso a ficheros en Kotlin (Java NIO) Tipo de fichero Lectura Escritura Comentario Texto (l\u00edneas) Files.readAllLines(Path) Files.write(Path, List ) Carga todo en memoria Files.newBufferedReader(Path) Files.newBufferedWriter(Path) M\u00e1s eficiente para archivos grandes Files.readString(Path) (Java 11+) Files.writeString(Path, String) Lectura/escritura completa como bloque Binario Files.readAllBytes(Path) Files.write(Path, ByteArray) Lee y escribe bytes puros Files.newInputStream(Path) Files.newOutputStream(Path) Flujo de bytes directo Binario estructurado FileChannel.read(ByteBuffer) FileChannel.write(ByteBuffer) Usa FileChannel para secuencial o aleatorio SeekableByteChannel.read(...) SeekableByteChannel.write(...) Canal flexible con .position() ByteBuffer.get*() ByteBuffer.put*() Tipos primitivos ( int , double , etc.) Imagen ImageIO.read(Path/File) ImageIO.write(BufferedImage, ...) Usa javax.imageio.ImageIO Acceso aleatorio FileChannel.position(offset) FileChannel.position(offset) Permite saltar a cualquier posici\u00f3n del fichero","title":"\ud83d\udd39Clases y m\u00e9todos sobre ficheros. Java.nio"},{"location":"T2_Gestion_del_contenido/clases/#clases-y-metodos-sobre-ficheros-javanio","text":"En el desarrollo de aplicaciones es com\u00fan tener que leer y escribir datos almacenados en archivos. Seg\u00fan el tipo de contenido del fichero (texto, binario, imagen, estructurado...), se utilizan clases y m\u00e9todos distintos para acceder a ellos de forma eficiente y segura. Kotlin se apoya en las bibliotecas de Java ( java.io y java.nio.file ) para realizar estas operaciones, permitiendo un control detallado tanto para acceso secuencial como aleatorio. java.io : API tradicional basada en flujos de bytes o caracteres. java.nio (New I/O): API moderna basada en canales y buffers, introducida para mejorar el rendimiento y la flexibilidad. En el desarrollo actual, especialmente en aplicaciones que manejan datos estructurados, binarios o grandes vol\u00famenes de informaci\u00f3n, es preferible utilizar java.nio , por lo que ser\u00e1 la API que utilizaremos en los ejemplos y ejercicios. La siguiente tabla resume las clases m\u00e1s utilizadas para trabajar con los distintos tipos de ficheros, indicando las opciones recomendadas para lectura y escritura, y proporcionando notas aclaratorias sobre su uso t\u00edpico. Resumen de clases y m\u00e9todos para el acceso a ficheros en Kotlin (Java NIO) Tipo de fichero Lectura Escritura Comentario Texto (l\u00edneas) Files.readAllLines(Path) Files.write(Path, List ) Carga todo en memoria Files.newBufferedReader(Path) Files.newBufferedWriter(Path) M\u00e1s eficiente para archivos grandes Files.readString(Path) (Java 11+) Files.writeString(Path, String) Lectura/escritura completa como bloque Binario Files.readAllBytes(Path) Files.write(Path, ByteArray) Lee y escribe bytes puros Files.newInputStream(Path) Files.newOutputStream(Path) Flujo de bytes directo Binario estructurado FileChannel.read(ByteBuffer) FileChannel.write(ByteBuffer) Usa FileChannel para secuencial o aleatorio SeekableByteChannel.read(...) SeekableByteChannel.write(...) Canal flexible con .position() ByteBuffer.get*() ByteBuffer.put*() Tipos primitivos ( int , double , etc.) Imagen ImageIO.read(Path/File) ImageIO.write(BufferedImage, ...) Usa javax.imageio.ImageIO Acceso aleatorio FileChannel.position(offset) FileChannel.position(offset) Permite saltar a cualquier posici\u00f3n del fichero","title":"\ud83d\udd39 Clases y m\u00e9todos sobre ficheros. Java.nio"},{"location":"T3_Formatos_diferentes/Conversion/","text":"\ud83d\udd39 Conversi\u00f3n entre formatos de ficheros en Kotlin/Java Importante Para convertir un fichero de un formato a otro, primero debo deserializarlo o interpretarlo convirti\u00e9ndolo a objetos en memoria, y despu\u00e9s generar el nuevo formato a partir de esos objetos. El proceso correcto es siempre: Formato de entrada \u2192 Objeto \u2192 Formato de salida. Cada formato (CSV, JSON, XML, binario) organiza la informaci\u00f3n de forma distinta: CSV \u2192 datos planos por filas/columnas JSON \u2192 datos jer\u00e1rquicos XML \u2192 etiquetas anidadas Binario \u2192 datos codificados En la siguiente tabla se resumen las conversiones m\u00e1s habituales entre formatos de ficheros trabajadas en el m\u00f3dulo. Para cada conversi\u00f3n se indican varias herramientas posibles, pero las opciones marcadas en negrita representan la recomendaci\u00f3n principal, ya que son las m\u00e1s sencillas. Las herramientas no destacadas en negrita son alternativas v\u00e1lidas, que pueden utilizarse en otros contextos o como ampliaci\u00f3n, pero no son las m\u00e1s recomendadas como primera opci\u00f3n. Conversi\u00f3n Herramientas recomendadas Proceso resumido CSV \u2192 JSON readAllLines + split / KotlinCSV / OpenCSV + Jackson / kotlinx.serialization Leer CSV \u2192 mapear a objetos \u2192 serializar a JSON JSON \u2192 CSV Jackson / kotlinx.serialization + KotlinCSV / OpenCSV Deserializar JSON a objetos \u2192 escribir filas CSV CSV \u2192 XML readAllLines + split / KotlinCSV / OpenCSV + Jackson (XmlMapper) Leer CSV \u2192 mapear a objetos \u2192 serializar a XML XML \u2192 CSV Jackson (XmlMapper) + KotlinCSV / OpenCSV Leer XML \u2192 mapear a objetos \u2192 escribir filas CSV JSON \u2192 XML Jackson (ObjectMapper, XmlMapper) Convertir JSON a objeto \u2192 serializar a XML XML \u2192 JSON Jackson (XmlMapper, ObjectMapper) Leer XML como objeto \u2192 serializar a JSON Texto \u2192 JSON / XML Files.readAllLines() + Jackson / kotlinx.serialization Leer texto \u2192 interpretar l\u00edneas \u2192 mapear a estructura \u2192 serializar Texto \u2192 binario Files.readAllLines() / Files.readString() + Files.write() Leer texto \u2192 convertir a bytes (UTF-8) \u2192 guardar en binario Texto \u2192 binario estructurado Files.readAllLines() / Files.readString() + DataOutputStream Leer texto \u2192 escribir campos con tipo fijo Binario estructurado \u2192 JSON DataInputStream + Jackson / kotlinx.serialization Leer datos binarios \u2192 construir objetos \u2192 serializar a JSON JSON \u2192 binario estructurado Jackson / kotlinx.serialization + DataOutputStream Deserializar JSON \u2192 escribir datos con tipo fijo Objeto \u2192 binario (serializaci\u00f3n) ObjectOutputStream (Serializable) Serializar objetos completos a binario Binario \u2192 objeto ObjectInputStream Deserializar objetos binarios PNG \u2192 JPG (imagen) ImageIO.read() + ImageIO.write() Leer imagen \u2192 guardar en otro formato \ud83d\udd39 Ejemplos de Conversi\u00f3n Ejemplos Los siguientes ejemplos tambi\u00e9n se incluir\u00e1n en el proyecto Ficheros_Gradle . En los siguientes ejemplos trabajaremos con tres archivos en diferentes formatos: CSV , XML y JSON . Estos archivos contienen informaci\u00f3n similar, representada con distinta estructura y sintaxis seg\u00fan el formato. Los utilizaremos como base para realizar ejercicios de conversi\u00f3n entre formatos. Contenido de los archivos: alumnos.csv persona.xml persona.json nombre;nota Luc\u00eda;28 Carlos;8 Elena;10 <Persona> <nombre>Luc\u00eda</nombre> <edad>28</edad> </Persona> { \"nombre\" : \"Luc\u00eda\", \"edad\" : 28 } Data Class Al trabajar con ficheros de intercambio como CSV, JSON o XML, es habitual encontrarnos con datos estructurados formados por distintos campos. Para poder manejar estos datos de forma c\u00f3moda y segura en Kotlin, es recomendable representarlos mediante data class , que permiten modelar la informaci\u00f3n con tipos y nombres claros. Una vez los datos est\u00e1n representados como objetos, el formato original del fichero deja de ser relevante. Esta idea ser\u00e1 fundamental en el siguiente apartado, donde se utilizar\u00e1n los data class como elemento intermedio para transformar la informaci\u00f3n entre distintos formatos de fichero, como CSV, JSON, XML o binario. \ud83d\udccc Nota: Las clases Alumno y Persona ya las creamos en los ejemplos sobre ficheros de intercambio y las volveremos a utilizar en los siguientes ejemplos. Alumno.kt data class Alumno( val nombre: String, val nota: Int ) Persona.kt @Serializable data class Persona( val nombre: String, val edad: Int ) Alumno Persona data class Alumno( val nombre: String, val nota: Int ) data class Persona( val nombre: String, val edad: Int ) CSV <-> JSON En estos ejemplos utilizamos la librer\u00eda Jackson , pero se podr\u00eda utilizar tambi\u00e9n Kotlinx.serialization . El intermediario entre el CSV y el JSON es la lista de objetos alumnos (de tipo Alumno) Alumno.kt (Clase ya creada) \ud83d\udda5\ufe0f Ejemplo_convertir_csv_a_json.kt import com.opencsv.CSVReaderBuilder import com.opencsv.CSVParserBuilder import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper import java.io.File import java.io.FileReader fun main() { val rutaCSV = \"documentos/alumnos.csv\" val rutaJSON = \"documentos/alumnos.json\" val reader = CSVReaderBuilder(FileReader(rutaCSV)) .withCSVParser(CSVParserBuilder().withSeparator(';').build()) .withSkipLines(1) .build() val registros = reader.readAll() //lista alumnos para guardar los objetos Alumno val alumnos = mutableListOf<Alumno>() for (campos in registros) { val nombre = campos[0] val nota = campos[1].toInt() // Cada l\u00ednea del CSV se transforma en un objeto val alumno = Alumno(nombre, nota) //Todos los objetos se guardan en la lista alumnos alumnos.add(alumno) } reader.close() val mapper = jacksonObjectMapper() mapper.writerWithDefaultPrettyPrinter().writeValue(File(rutaJSON), alumnos) println(\"\u2705 Conversi\u00f3n CSV \u2192 JSON completada: $rutaJSON\") } \ud83d\udda5\ufe0f Ejemplo_convertir_json_a_csv.kt import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper import com.fasterxml.jackson.module.kotlin.readValue import com.opencsv.CSVWriter import java.io.File import java.io.FileWriter fun main() { val rutaJson = \"documentos/alumnos.json\" val rutaCsv = \"documentos/alumnos.csv\" // 1. Leer JSON val mapper = jacksonObjectMapper() val alumnos: List<Alumno> = mapper.readValue(File(rutaJson)) // 2. Escribir CSV val writer = CSVWriter(FileWriter(rutaCsv), ';', CSVWriter.NO_QUOTE_CHARACTER, CSVWriter.DEFAULT_ESCAPE_CHARACTER, CSVWriter.DEFAULT_LINE_END) // Cabecera writer.writeNext(arrayOf(\"nombre\", \"nota\")) // Cuerpo for (alumno in alumnos) { writer.writeNext(arrayOf(alumno.nombre, alumno.nota.toString())) } writer.close() println(\"\u2705 Conversi\u00f3n JSON \u2192 CSV completada: $rutaCsv\") } JSON <-> XML En estos ejemplos utilizamos Jackson , en ambas conversiones, y por lo tanto tambi\u00e9n utiliza un objeto intermediario ( persona ), aunque de forma m\u00e1s impl\u00edcita. \ud83d\udda5\ufe0f Ejemplo_convertir_json_a_xml.kt import com.fasterxml.jackson.dataformat.xml.XmlMapper import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper import com.fasterxml.jackson.module.kotlin.readValue import com.fasterxml.jackson.module.kotlin.registerKotlinModule import java.io.File fun convertirJsonAXml(jsonPath: String, xmlPath: String) { val xmlMapper = XmlMapper().registerKotlinModule() val jsonMapper = jacksonObjectMapper() //Leer JSON y convertirlo a un objeto Persona val persona = jsonMapper.readValue<Persona>(File(jsonPath)) // Escribir el objeto Persona en formato XML xmlMapper.writerWithDefaultPrettyPrinter().writeValue(File(xmlPath), persona) println(\"Conversi\u00f3n JSON \u2192 XML completada\") } fun main() { convertirJsonAXml(\"documentos/persona.json\", \"documentos/persona.xml\") } Fichero JSON compuesto por una lista de elementos Si el fichero JSON contiene un array ( [...] ), es decir, una lista de objetos , entonces debemos indicar expl\u00edcitamente que queremos leer un List<Objeto> . lista_personas_jackson.json [ { \"nombre\" : \"Luc\u00eda\", \"edad\" : 28 }, { \"nombre\" : \"Pepe\", \"edad\" : 30 }, { \"nombre\" : \"Ana\", \"edad\" : 50 }, { \"nombre\" : \"Juan\", \"edad\" : 12 } ] \ud83d\udda5\ufe0f Ejemplo_convertir_listajson_a_xml.kt import com.fasterxml.jackson.dataformat.xml.XmlMapper import com.fasterxml.jackson.module.kotlin.readValue import java.io.File import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper import com.fasterxml.jackson.module.kotlin.registerKotlinModule fun convertirListaJsonAXml(jsonPath: String, xmlPath: String) { val jsonMapper = jacksonObjectMapper() val xmlMapper = XmlMapper().registerKotlinModule() // Leer JSON y convertirlo a lista de objetos Persona val personas: List<Persona> = jsonMapper.readValue(File(jsonPath)) // Escribir el XML xmlMapper.writerWithDefaultPrettyPrinter().writeValue(File(xmlPath), personas) println(\"Conversi\u00f3n JSON \u2192 XML completada\") } fun main() { convertirListaJsonAXml(\"documentos/lista_personas.json\", \"documentos/lista_personas.xml\") } El contenido del fichero xml convertido ser\u00eda el siguiente: <ArrayList> <item> <nombre>Luc\u00eda</nombre> <edad>28</edad> </item> <item> <nombre>Pepe</nombre> <edad>30</edad> </item> <item> <nombre>Ana</nombre> <edad>50</edad> </item> <item> <nombre>Juan</nombre> <edad>12</edad> </item> </ArrayList> \u26a0\ufe0f Esto no es correcto porque, aunque el XML se puede leer, cuando un XML representa una lista, siempre debe tener un elemento ra\u00edz con significado. Clase contenedora Cuando se convierte una lista de JSON a XML, es recomendable utilizar un data class para modelar los datos y una clase contenedora auxiliar para representar el nodo ra\u00edz del XML. \ud83d\udccc Creamos la Clase contenedora ListaPersonas en el paquete Ejemplos , fuera de los programas, para poder reutilizarla: import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlElementWrapper data class ListaPersonas( @JacksonXmlElementWrapper(useWrapping = false) val persona: List<Persona> ) \ud83d\udda5\ufe0f Ejemplo_convertir_listajson_a_xml_nodo.kt import com.fasterxml.jackson.dataformat.xml.XmlMapper import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper import com.fasterxml.jackson.module.kotlin.readValue import com.fasterxml.jackson.module.kotlin.registerKotlinModule import java.io.File fun convertirListaJsonAXml_nodo(jsonPath: String, xmlPath: String) { val jsonMapper = jacksonObjectMapper() val xmlMapper = XmlMapper().registerKotlinModule() // Leer JSON y convertirlo a lista de objetos Persona val personas: List<Persona> = jsonMapper.readValue(File(jsonPath)) // Envolver la lista en la clase contenedora para XML val listaPersonas = ListaPersonas(personas) // Escribir el XML xmlMapper.writerWithDefaultPrettyPrinter() .writeValue(File(xmlPath), listaPersonas) println(\"\u2705 Conversi\u00f3n JSON \u2192 XML completada\") } fun main() { convertirListaJsonAXml_nodo( \"documentos/lista_personas.json\", \"documentos/lista_personas_nodo.xml\" ) } Ahora la conversi\u00f3n si que es correcta: <ListaPersonas> <persona> <nombre>Luc\u00eda</nombre> <edad>28</edad> </persona> <persona> <nombre>Pepe</nombre> <edad>30</edad> </persona> <persona> <nombre>Ana</nombre> <edad>50</edad> </persona> <persona> <nombre>Juan</nombre> <edad>12</edad> </persona> </ListaPersonas> \ud83d\udda5\ufe0f Ejemplo_convertir_xml_a_json.kt import com.fasterxml.jackson.dataformat.xml.XmlMapper import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper import com.fasterxml.jackson.module.kotlin.readValue import com.fasterxml.jackson.module.kotlin.registerKotlinModule import java.io.File fun convertirXmlAJson(xmlPath: String, jsonPath: String) { val xmlMapper = XmlMapper().registerKotlinModule() val jsonMapper = jacksonObjectMapper() val persona = xmlMapper.readValue<Persona>(File(xmlPath)) jsonMapper.writerWithDefaultPrettyPrinter().writeValue(File(jsonPath), persona) println(\"Conversi\u00f3n XML \u2192 JSON completada\") } fun main() { convertirXmlAJson(\"documentos/persona.xml\", \"documentos/persona.json\") } Fichero XML compuesto por una lista de elementos Si el fichero XML contiene una lista de objetos , entonces debemos indicar expl\u00edcitamente que queremos leer un List<Objeto> . lista_personas.xml <ArrayList> <item> <nombre>Luc\u00eda</nombre> <edad>28</edad> </item> <item> <nombre>Pepe</nombre> <edad>30</edad> </item> <item> <nombre>Ana</nombre> <edad>50</edad> </item> <item> <nombre>Juan</nombre> <edad>12</edad> </item> </ArrayList> \ud83d\udda5\ufe0f Ejemplo_convertir_listaxml_a_json.kt import com.fasterxml.jackson.dataformat.xml.XmlMapper import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper import com.fasterxml.jackson.module.kotlin.readValue import com.fasterxml.jackson.module.kotlin.registerKotlinModule import java.io.File fun convertirListaXmlAJson(xmlPath: String, jsonPath: String) { val jsonMapper = jacksonObjectMapper() val xmlMapper = XmlMapper().registerKotlinModule() val personas: List<Persona> = xmlMapper.readValue(File(xmlPath)) jsonMapper.writerWithDefaultPrettyPrinter().writeValue(File(jsonPath), personas) println(\"Conversi\u00f3n XML \u2192 JSON completada\") } fun main() { convertirListaXmlAJson(\"documentos/lista_personas.xml\", \"documentos/lista_personas.json\") } Clase contenedora Cuando el XML contiene un nodo ra\u00edz que agrupa varios elementos, es conveniente utilizar una clase contenedora auxiliar para mapear correctamente la estructura del documento. lista_personas_nodo.xml <ListaPersonas> <persona> <nombre>Luc\u00eda</nombre> <edad>28</edad> </persona> <persona> <nombre>Pepe</nombre> <edad>30</edad> </persona> <persona> <nombre>Ana</nombre> <edad>50</edad> </persona> <persona> <nombre>Juan</nombre> <edad>12</edad> </persona> </ListaPersonas> \ud83d\udccc Utilizaremos la clase contenedora ListapPersona creada anteriormente. \ud83d\udda5\ufe0f Ejemplo_convertir_listaxml_a_json_nodo.kt import com.fasterxml.jackson.dataformat.xml.XmlMapper import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper import com.fasterxml.jackson.module.kotlin.readValue import com.fasterxml.jackson.module.kotlin.registerKotlinModule import java.io.File import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlElementWrapper fun convertirListaXmlAJsonNodo(xmlPath: String, jsonPath: String) { val jsonMapper = jacksonObjectMapper() val xmlMapper = XmlMapper().registerKotlinModule() // Lee el XML y lo convierte a un objeto de tipo ListaPersonas // Aqu\u00ed utilizamos la clase contenedora para representar el nodo ra\u00edz del XML val lista: ListaPersonas = xmlMapper.readValue(File(xmlPath)) //Aqu\u00ed utilizamos la clase contendora // Extrae la lista de objetos Persona desde la clase contenedora val personas = lista.persona // Escribe la lista de personas en formato JSON // El JSON generado ser\u00e1 un array de objetos jsonMapper.writerWithDefaultPrettyPrinter() .writeValue(File(jsonPath), personas) println(\"Conversi\u00f3n XML \u2192 JSON completada\") } fun main() { convertirListaXmlAJsonNodo(\"documentos/lista_personas_nodo.xml\", \"documentos/lista_personas.json\") } JSON <-> Binario estructurado En estos ejemplos utilizamos kotlinx.serialization . El objeto persona (instancia de la clase Persona) es el intermediario entre el archivo JSON y el archivo binario. \ud83d\udda5\ufe0f Ejemplo_convertir_json_a_binario.kt import kotlinx.serialization.json.Json import java.io.DataOutputStream import java.io.File import java.io.FileOutputStream import java.nio.file.Files import java.nio.file.Paths import java.io.DataInputStream import java.io.FileInputStream fun main() { val rutaJson = \"documentos/persona.json\" val rutaBin = \"documentos/persona.dat\" // Leer JSON val contenido = File(rutaJson).readText() val persona = Json.decodeFromString<Persona>(contenido) // Crear carpeta si no existe Files.createDirectories(Paths.get(rutaBin).parent) // Escribir como binario estructurado val salida = DataOutputStream(FileOutputStream(rutaBin)) salida.writeUTF(persona.nombre) // Guarda string como UTF con longitud salida.writeInt(persona.edad) // Guarda entero (4 bytes) salida.close() println(\"\u2705 .Persona guardada como binario estructurado en: $rutaBin\") //Leer el binario estructurado val entrada = DataInputStream(FileInputStream(rutaBin)) val nombre = entrada.readUTF() val edad = entrada.readInt() entrada.close() println(\"\ud83d\udcc4 Persona le\u00edda del binario:\") println(\"Nombre: $nombre, Edad: $edad\") } Fichero JSON compuesto por una lista de elementos Si el fichero JSON contiene un array ( [...] ), es decir, una lista de objetos , necesitas iterar sobre la lista al escribir y al leer. \ud83d\udda5\ufe0f Ejemplo_convertir_listajson_a_binario.kt import kotlinx.serialization.json.Json import java.io.DataOutputStream import java.io.File import java.io.FileOutputStream import java.nio.file.Files import java.nio.file.Paths import java.io.DataInputStream import java.io.FileInputStream fun main() { val rutaJson = \"documentos/lista_personas.json\" val rutaBin = \"documentos/lista_personas.dat\" // Leer JSON val contenido = File(rutaJson).readText() val personas = Json.decodeFromString<List<Persona>>(contenido) // Crear carpeta si no existe Files.createDirectories(Paths.get(rutaBin).parent) // Escribir como binario estructurado val salida = DataOutputStream(FileOutputStream(rutaBin)) salida.writeInt(personas.size) // Guardar el tama\u00f1o de la lista for (persona in personas) { salida.writeUTF(persona.nombre) salida.writeInt(persona.edad) } salida.close() println(\"\u2705 Lista de personas guardada como binario estructurado en: $rutaBin\") // Leer el binario estructurado val entrada = DataInputStream(FileInputStream(rutaBin)) val cantidad = entrada.readInt() // Leer el tama\u00f1o de la lista for (i in 0 until cantidad) { val nombre = entrada.readUTF() val edad = entrada.readInt() println(\"Nombre: $nombre, Edad: $edad\") } entrada.close() } El mismo ejermplo pero utilizando la libre\u00eda Jackson en lugar de Kotlinx.serialization \ud83d\udda5\ufe0f Ejemplo_convertir_listajson_a_binario_Jackson.kt import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper import com.fasterxml.jackson.module.kotlin.readValue import java.io.DataOutputStream import java.io.File import java.io.FileOutputStream import java.nio.file.Files import java.nio.file.Paths import java.io.DataInputStream import java.io.FileInputStream fun main() { val rutaJson = \"documentos/lista_personas.json\" val rutaBin = \"documentos/lista_personas.dat\" // Leer JSON con Jackson val mapper = jacksonObjectMapper() val personas: List<Persona> = mapper.readValue(File(rutaJson)) // Crear carpeta si no existe Files.createDirectories(Paths.get(rutaBin).parent) // Escribir como binario estructurado val salida = DataOutputStream(FileOutputStream(rutaBin)) salida.writeInt(personas.size) // Guardar el tama\u00f1o de la lista for (persona in personas) { salida.writeUTF(persona.nombre) salida.writeInt(persona.edad) } salida.close() println(\"\u2705 Lista de personas guardada como binario estructurado en: $rutaBin\") // Leer el binario estructurado val entrada = DataInputStream(FileInputStream(rutaBin)) val cantidad = entrada.readInt() // Leer el tama\u00f1o de la lista for (i in 0 until cantidad) { val nombre = entrada.readUTF() val edad = entrada.readInt() println(\"Nombre: $nombre, Edad: $edad\") } entrada.close() } \ud83d\udda5\ufe0f Ejemplo_convertir_binario_a_json.kt import kotlinx.serialization.encodeToString import kotlinx.serialization.json.Json import java.io.DataInputStream import java.io.File import java.io.FileInputStream import java.nio.file.Files import java.nio.file.Paths fun main() { val rutaBin = \"documentos/persona.dat\" val rutaJson = \"documentos/persona.json\" // Leer binario estructurado val entrada = DataInputStream(FileInputStream(rutaBin)) val nombre = entrada.readUTF() val edad = entrada.readInt() entrada.close() // Crear objeto val persona = Persona(nombre, edad) // Convertir a JSON con pretty print val json = Json { prettyPrint = true }.encodeToString(persona) // Crear carpeta si no existe Files.createDirectories(Paths.get(rutaJson).parent) // Escribir JSON en archivo File(rutaJson).writeText(json) println(\"\u2705 Binario estructurado convertido a JSON:\") println(json) } Fichero Binario compuesto por una lista de objetos Si el fichero Binario contiene una lista de objetos , debes leer el tama\u00f1o de la lista y luego leer cada objeto uno por uno, construir la lista y convertirla a JSON. \ud83d\udda5\ufe0f Ejemplo_convertir_listabinario_a_json.kt import kotlinx.serialization.encodeToString import kotlinx.serialization.json.Json import java.io.DataInputStream import java.io.File import java.io.FileInputStream import java.nio.file.Files import java.nio.file.Paths fun main() { val rutaBin = \"documentos/lista_personas.dat\" val rutaJson = \"documentos/lista_personas.json\" // Leer binario estructurado val entrada = DataInputStream(FileInputStream(rutaBin)) val cantidad = entrada.readInt() // Leer el tama\u00f1o de la lista val personas = mutableListOf<Persona>() for (i in 0 until cantidad) { val nombre = entrada.readUTF() val edad = entrada.readInt() personas.add(Persona(nombre, edad)) } entrada.close() // Convertir a JSON con pretty print val json = Json { prettyPrint = true }.encodeToString(personas) // Crear carpeta si no existe Files.createDirectories(Paths.get(rutaJson).parent) // Escribir JSON en archivo File(rutaJson).writeText(json) println(\"\u2705 Lista de personas convertida a JSON:\") println(json) } El mismo ejermplo pero utilizando la libre\u00eda Jackson en lugar de Kotlinx.serialization \ud83d\udda5\ufe0f Ejemplo_convertir_listabinario_a_json_Jackson.kt import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper import java.io.DataInputStream import java.io.File import java.io.FileInputStream import java.nio.file.Files import java.nio.file.Paths fun main() { val rutaBin = \"documentos/lista_personas.dat\" val rutaJson = \"documentos/lista_personas.json\" // Leer binario estructurado val entrada = DataInputStream(FileInputStream(rutaBin)) val cantidad = entrada.readInt() // Leer el tama\u00f1o de la lista val personas = mutableListOf<Persona>() for (i in 0 until cantidad) { val nombre = entrada.readUTF() val edad = entrada.readInt() personas.add(Persona(nombre, edad)) } entrada.close() // Convertir a JSON con pretty print usando Jackson val mapper = jacksonObjectMapper() mapper.writerWithDefaultPrettyPrinter().writeValue(File(rutaJson), personas) // Crear carpeta si no existe Files.createDirectories(Paths.get(rutaJson).parent) println(\"\u2705 Lista de personas convertida a JSON con Jackson:\") println(mapper.writeValueAsString(personas)) }","title":"\ud83d\udd39Conversi\u00f3n entre formatos diferentes"},{"location":"T3_Formatos_diferentes/Conversion/#conversion-entre-formatos-de-ficheros-en-kotlinjava","text":"Importante Para convertir un fichero de un formato a otro, primero debo deserializarlo o interpretarlo convirti\u00e9ndolo a objetos en memoria, y despu\u00e9s generar el nuevo formato a partir de esos objetos. El proceso correcto es siempre: Formato de entrada \u2192 Objeto \u2192 Formato de salida. Cada formato (CSV, JSON, XML, binario) organiza la informaci\u00f3n de forma distinta: CSV \u2192 datos planos por filas/columnas JSON \u2192 datos jer\u00e1rquicos XML \u2192 etiquetas anidadas Binario \u2192 datos codificados En la siguiente tabla se resumen las conversiones m\u00e1s habituales entre formatos de ficheros trabajadas en el m\u00f3dulo. Para cada conversi\u00f3n se indican varias herramientas posibles, pero las opciones marcadas en negrita representan la recomendaci\u00f3n principal, ya que son las m\u00e1s sencillas. Las herramientas no destacadas en negrita son alternativas v\u00e1lidas, que pueden utilizarse en otros contextos o como ampliaci\u00f3n, pero no son las m\u00e1s recomendadas como primera opci\u00f3n. Conversi\u00f3n Herramientas recomendadas Proceso resumido CSV \u2192 JSON readAllLines + split / KotlinCSV / OpenCSV + Jackson / kotlinx.serialization Leer CSV \u2192 mapear a objetos \u2192 serializar a JSON JSON \u2192 CSV Jackson / kotlinx.serialization + KotlinCSV / OpenCSV Deserializar JSON a objetos \u2192 escribir filas CSV CSV \u2192 XML readAllLines + split / KotlinCSV / OpenCSV + Jackson (XmlMapper) Leer CSV \u2192 mapear a objetos \u2192 serializar a XML XML \u2192 CSV Jackson (XmlMapper) + KotlinCSV / OpenCSV Leer XML \u2192 mapear a objetos \u2192 escribir filas CSV JSON \u2192 XML Jackson (ObjectMapper, XmlMapper) Convertir JSON a objeto \u2192 serializar a XML XML \u2192 JSON Jackson (XmlMapper, ObjectMapper) Leer XML como objeto \u2192 serializar a JSON Texto \u2192 JSON / XML Files.readAllLines() + Jackson / kotlinx.serialization Leer texto \u2192 interpretar l\u00edneas \u2192 mapear a estructura \u2192 serializar Texto \u2192 binario Files.readAllLines() / Files.readString() + Files.write() Leer texto \u2192 convertir a bytes (UTF-8) \u2192 guardar en binario Texto \u2192 binario estructurado Files.readAllLines() / Files.readString() + DataOutputStream Leer texto \u2192 escribir campos con tipo fijo Binario estructurado \u2192 JSON DataInputStream + Jackson / kotlinx.serialization Leer datos binarios \u2192 construir objetos \u2192 serializar a JSON JSON \u2192 binario estructurado Jackson / kotlinx.serialization + DataOutputStream Deserializar JSON \u2192 escribir datos con tipo fijo Objeto \u2192 binario (serializaci\u00f3n) ObjectOutputStream (Serializable) Serializar objetos completos a binario Binario \u2192 objeto ObjectInputStream Deserializar objetos binarios PNG \u2192 JPG (imagen) ImageIO.read() + ImageIO.write() Leer imagen \u2192 guardar en otro formato","title":"\ud83d\udd39 Conversi\u00f3n entre formatos de ficheros en Kotlin/Java"},{"location":"T3_Formatos_diferentes/Conversion/#ejemplos-de-conversion","text":"Ejemplos Los siguientes ejemplos tambi\u00e9n se incluir\u00e1n en el proyecto Ficheros_Gradle . En los siguientes ejemplos trabajaremos con tres archivos en diferentes formatos: CSV , XML y JSON . Estos archivos contienen informaci\u00f3n similar, representada con distinta estructura y sintaxis seg\u00fan el formato. Los utilizaremos como base para realizar ejercicios de conversi\u00f3n entre formatos. Contenido de los archivos: alumnos.csv persona.xml persona.json nombre;nota Luc\u00eda;28 Carlos;8 Elena;10 <Persona> <nombre>Luc\u00eda</nombre> <edad>28</edad> </Persona> { \"nombre\" : \"Luc\u00eda\", \"edad\" : 28 } Data Class Al trabajar con ficheros de intercambio como CSV, JSON o XML, es habitual encontrarnos con datos estructurados formados por distintos campos. Para poder manejar estos datos de forma c\u00f3moda y segura en Kotlin, es recomendable representarlos mediante data class , que permiten modelar la informaci\u00f3n con tipos y nombres claros. Una vez los datos est\u00e1n representados como objetos, el formato original del fichero deja de ser relevante. Esta idea ser\u00e1 fundamental en el siguiente apartado, donde se utilizar\u00e1n los data class como elemento intermedio para transformar la informaci\u00f3n entre distintos formatos de fichero, como CSV, JSON, XML o binario. \ud83d\udccc Nota: Las clases Alumno y Persona ya las creamos en los ejemplos sobre ficheros de intercambio y las volveremos a utilizar en los siguientes ejemplos. Alumno.kt data class Alumno( val nombre: String, val nota: Int ) Persona.kt @Serializable data class Persona( val nombre: String, val edad: Int ) Alumno Persona data class Alumno( val nombre: String, val nota: Int ) data class Persona( val nombre: String, val edad: Int )","title":"\ud83d\udd39 Ejemplos de Conversi\u00f3n"},{"location":"T3_Formatos_diferentes/Conversion/#csv-json","text":"En estos ejemplos utilizamos la librer\u00eda Jackson , pero se podr\u00eda utilizar tambi\u00e9n Kotlinx.serialization . El intermediario entre el CSV y el JSON es la lista de objetos alumnos (de tipo Alumno) Alumno.kt (Clase ya creada) \ud83d\udda5\ufe0f Ejemplo_convertir_csv_a_json.kt import com.opencsv.CSVReaderBuilder import com.opencsv.CSVParserBuilder import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper import java.io.File import java.io.FileReader fun main() { val rutaCSV = \"documentos/alumnos.csv\" val rutaJSON = \"documentos/alumnos.json\" val reader = CSVReaderBuilder(FileReader(rutaCSV)) .withCSVParser(CSVParserBuilder().withSeparator(';').build()) .withSkipLines(1) .build() val registros = reader.readAll() //lista alumnos para guardar los objetos Alumno val alumnos = mutableListOf<Alumno>() for (campos in registros) { val nombre = campos[0] val nota = campos[1].toInt() // Cada l\u00ednea del CSV se transforma en un objeto val alumno = Alumno(nombre, nota) //Todos los objetos se guardan en la lista alumnos alumnos.add(alumno) } reader.close() val mapper = jacksonObjectMapper() mapper.writerWithDefaultPrettyPrinter().writeValue(File(rutaJSON), alumnos) println(\"\u2705 Conversi\u00f3n CSV \u2192 JSON completada: $rutaJSON\") } \ud83d\udda5\ufe0f Ejemplo_convertir_json_a_csv.kt import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper import com.fasterxml.jackson.module.kotlin.readValue import com.opencsv.CSVWriter import java.io.File import java.io.FileWriter fun main() { val rutaJson = \"documentos/alumnos.json\" val rutaCsv = \"documentos/alumnos.csv\" // 1. Leer JSON val mapper = jacksonObjectMapper() val alumnos: List<Alumno> = mapper.readValue(File(rutaJson)) // 2. Escribir CSV val writer = CSVWriter(FileWriter(rutaCsv), ';', CSVWriter.NO_QUOTE_CHARACTER, CSVWriter.DEFAULT_ESCAPE_CHARACTER, CSVWriter.DEFAULT_LINE_END) // Cabecera writer.writeNext(arrayOf(\"nombre\", \"nota\")) // Cuerpo for (alumno in alumnos) { writer.writeNext(arrayOf(alumno.nombre, alumno.nota.toString())) } writer.close() println(\"\u2705 Conversi\u00f3n JSON \u2192 CSV completada: $rutaCsv\") }","title":"CSV &lt;-&gt; JSON"},{"location":"T3_Formatos_diferentes/Conversion/#json-xml","text":"En estos ejemplos utilizamos Jackson , en ambas conversiones, y por lo tanto tambi\u00e9n utiliza un objeto intermediario ( persona ), aunque de forma m\u00e1s impl\u00edcita. \ud83d\udda5\ufe0f Ejemplo_convertir_json_a_xml.kt import com.fasterxml.jackson.dataformat.xml.XmlMapper import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper import com.fasterxml.jackson.module.kotlin.readValue import com.fasterxml.jackson.module.kotlin.registerKotlinModule import java.io.File fun convertirJsonAXml(jsonPath: String, xmlPath: String) { val xmlMapper = XmlMapper().registerKotlinModule() val jsonMapper = jacksonObjectMapper() //Leer JSON y convertirlo a un objeto Persona val persona = jsonMapper.readValue<Persona>(File(jsonPath)) // Escribir el objeto Persona en formato XML xmlMapper.writerWithDefaultPrettyPrinter().writeValue(File(xmlPath), persona) println(\"Conversi\u00f3n JSON \u2192 XML completada\") } fun main() { convertirJsonAXml(\"documentos/persona.json\", \"documentos/persona.xml\") } Fichero JSON compuesto por una lista de elementos Si el fichero JSON contiene un array ( [...] ), es decir, una lista de objetos , entonces debemos indicar expl\u00edcitamente que queremos leer un List<Objeto> . lista_personas_jackson.json [ { \"nombre\" : \"Luc\u00eda\", \"edad\" : 28 }, { \"nombre\" : \"Pepe\", \"edad\" : 30 }, { \"nombre\" : \"Ana\", \"edad\" : 50 }, { \"nombre\" : \"Juan\", \"edad\" : 12 } ] \ud83d\udda5\ufe0f Ejemplo_convertir_listajson_a_xml.kt import com.fasterxml.jackson.dataformat.xml.XmlMapper import com.fasterxml.jackson.module.kotlin.readValue import java.io.File import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper import com.fasterxml.jackson.module.kotlin.registerKotlinModule fun convertirListaJsonAXml(jsonPath: String, xmlPath: String) { val jsonMapper = jacksonObjectMapper() val xmlMapper = XmlMapper().registerKotlinModule() // Leer JSON y convertirlo a lista de objetos Persona val personas: List<Persona> = jsonMapper.readValue(File(jsonPath)) // Escribir el XML xmlMapper.writerWithDefaultPrettyPrinter().writeValue(File(xmlPath), personas) println(\"Conversi\u00f3n JSON \u2192 XML completada\") } fun main() { convertirListaJsonAXml(\"documentos/lista_personas.json\", \"documentos/lista_personas.xml\") } El contenido del fichero xml convertido ser\u00eda el siguiente: <ArrayList> <item> <nombre>Luc\u00eda</nombre> <edad>28</edad> </item> <item> <nombre>Pepe</nombre> <edad>30</edad> </item> <item> <nombre>Ana</nombre> <edad>50</edad> </item> <item> <nombre>Juan</nombre> <edad>12</edad> </item> </ArrayList> \u26a0\ufe0f Esto no es correcto porque, aunque el XML se puede leer, cuando un XML representa una lista, siempre debe tener un elemento ra\u00edz con significado. Clase contenedora Cuando se convierte una lista de JSON a XML, es recomendable utilizar un data class para modelar los datos y una clase contenedora auxiliar para representar el nodo ra\u00edz del XML. \ud83d\udccc Creamos la Clase contenedora ListaPersonas en el paquete Ejemplos , fuera de los programas, para poder reutilizarla: import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlElementWrapper data class ListaPersonas( @JacksonXmlElementWrapper(useWrapping = false) val persona: List<Persona> ) \ud83d\udda5\ufe0f Ejemplo_convertir_listajson_a_xml_nodo.kt import com.fasterxml.jackson.dataformat.xml.XmlMapper import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper import com.fasterxml.jackson.module.kotlin.readValue import com.fasterxml.jackson.module.kotlin.registerKotlinModule import java.io.File fun convertirListaJsonAXml_nodo(jsonPath: String, xmlPath: String) { val jsonMapper = jacksonObjectMapper() val xmlMapper = XmlMapper().registerKotlinModule() // Leer JSON y convertirlo a lista de objetos Persona val personas: List<Persona> = jsonMapper.readValue(File(jsonPath)) // Envolver la lista en la clase contenedora para XML val listaPersonas = ListaPersonas(personas) // Escribir el XML xmlMapper.writerWithDefaultPrettyPrinter() .writeValue(File(xmlPath), listaPersonas) println(\"\u2705 Conversi\u00f3n JSON \u2192 XML completada\") } fun main() { convertirListaJsonAXml_nodo( \"documentos/lista_personas.json\", \"documentos/lista_personas_nodo.xml\" ) } Ahora la conversi\u00f3n si que es correcta: <ListaPersonas> <persona> <nombre>Luc\u00eda</nombre> <edad>28</edad> </persona> <persona> <nombre>Pepe</nombre> <edad>30</edad> </persona> <persona> <nombre>Ana</nombre> <edad>50</edad> </persona> <persona> <nombre>Juan</nombre> <edad>12</edad> </persona> </ListaPersonas> \ud83d\udda5\ufe0f Ejemplo_convertir_xml_a_json.kt import com.fasterxml.jackson.dataformat.xml.XmlMapper import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper import com.fasterxml.jackson.module.kotlin.readValue import com.fasterxml.jackson.module.kotlin.registerKotlinModule import java.io.File fun convertirXmlAJson(xmlPath: String, jsonPath: String) { val xmlMapper = XmlMapper().registerKotlinModule() val jsonMapper = jacksonObjectMapper() val persona = xmlMapper.readValue<Persona>(File(xmlPath)) jsonMapper.writerWithDefaultPrettyPrinter().writeValue(File(jsonPath), persona) println(\"Conversi\u00f3n XML \u2192 JSON completada\") } fun main() { convertirXmlAJson(\"documentos/persona.xml\", \"documentos/persona.json\") } Fichero XML compuesto por una lista de elementos Si el fichero XML contiene una lista de objetos , entonces debemos indicar expl\u00edcitamente que queremos leer un List<Objeto> . lista_personas.xml <ArrayList> <item> <nombre>Luc\u00eda</nombre> <edad>28</edad> </item> <item> <nombre>Pepe</nombre> <edad>30</edad> </item> <item> <nombre>Ana</nombre> <edad>50</edad> </item> <item> <nombre>Juan</nombre> <edad>12</edad> </item> </ArrayList> \ud83d\udda5\ufe0f Ejemplo_convertir_listaxml_a_json.kt import com.fasterxml.jackson.dataformat.xml.XmlMapper import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper import com.fasterxml.jackson.module.kotlin.readValue import com.fasterxml.jackson.module.kotlin.registerKotlinModule import java.io.File fun convertirListaXmlAJson(xmlPath: String, jsonPath: String) { val jsonMapper = jacksonObjectMapper() val xmlMapper = XmlMapper().registerKotlinModule() val personas: List<Persona> = xmlMapper.readValue(File(xmlPath)) jsonMapper.writerWithDefaultPrettyPrinter().writeValue(File(jsonPath), personas) println(\"Conversi\u00f3n XML \u2192 JSON completada\") } fun main() { convertirListaXmlAJson(\"documentos/lista_personas.xml\", \"documentos/lista_personas.json\") } Clase contenedora Cuando el XML contiene un nodo ra\u00edz que agrupa varios elementos, es conveniente utilizar una clase contenedora auxiliar para mapear correctamente la estructura del documento. lista_personas_nodo.xml <ListaPersonas> <persona> <nombre>Luc\u00eda</nombre> <edad>28</edad> </persona> <persona> <nombre>Pepe</nombre> <edad>30</edad> </persona> <persona> <nombre>Ana</nombre> <edad>50</edad> </persona> <persona> <nombre>Juan</nombre> <edad>12</edad> </persona> </ListaPersonas> \ud83d\udccc Utilizaremos la clase contenedora ListapPersona creada anteriormente. \ud83d\udda5\ufe0f Ejemplo_convertir_listaxml_a_json_nodo.kt import com.fasterxml.jackson.dataformat.xml.XmlMapper import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper import com.fasterxml.jackson.module.kotlin.readValue import com.fasterxml.jackson.module.kotlin.registerKotlinModule import java.io.File import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlElementWrapper fun convertirListaXmlAJsonNodo(xmlPath: String, jsonPath: String) { val jsonMapper = jacksonObjectMapper() val xmlMapper = XmlMapper().registerKotlinModule() // Lee el XML y lo convierte a un objeto de tipo ListaPersonas // Aqu\u00ed utilizamos la clase contenedora para representar el nodo ra\u00edz del XML val lista: ListaPersonas = xmlMapper.readValue(File(xmlPath)) //Aqu\u00ed utilizamos la clase contendora // Extrae la lista de objetos Persona desde la clase contenedora val personas = lista.persona // Escribe la lista de personas en formato JSON // El JSON generado ser\u00e1 un array de objetos jsonMapper.writerWithDefaultPrettyPrinter() .writeValue(File(jsonPath), personas) println(\"Conversi\u00f3n XML \u2192 JSON completada\") } fun main() { convertirListaXmlAJsonNodo(\"documentos/lista_personas_nodo.xml\", \"documentos/lista_personas.json\") }","title":"JSON &lt;-&gt; XML"},{"location":"T3_Formatos_diferentes/Conversion/#json-binario-estructurado","text":"En estos ejemplos utilizamos kotlinx.serialization . El objeto persona (instancia de la clase Persona) es el intermediario entre el archivo JSON y el archivo binario. \ud83d\udda5\ufe0f Ejemplo_convertir_json_a_binario.kt import kotlinx.serialization.json.Json import java.io.DataOutputStream import java.io.File import java.io.FileOutputStream import java.nio.file.Files import java.nio.file.Paths import java.io.DataInputStream import java.io.FileInputStream fun main() { val rutaJson = \"documentos/persona.json\" val rutaBin = \"documentos/persona.dat\" // Leer JSON val contenido = File(rutaJson).readText() val persona = Json.decodeFromString<Persona>(contenido) // Crear carpeta si no existe Files.createDirectories(Paths.get(rutaBin).parent) // Escribir como binario estructurado val salida = DataOutputStream(FileOutputStream(rutaBin)) salida.writeUTF(persona.nombre) // Guarda string como UTF con longitud salida.writeInt(persona.edad) // Guarda entero (4 bytes) salida.close() println(\"\u2705 .Persona guardada como binario estructurado en: $rutaBin\") //Leer el binario estructurado val entrada = DataInputStream(FileInputStream(rutaBin)) val nombre = entrada.readUTF() val edad = entrada.readInt() entrada.close() println(\"\ud83d\udcc4 Persona le\u00edda del binario:\") println(\"Nombre: $nombre, Edad: $edad\") } Fichero JSON compuesto por una lista de elementos Si el fichero JSON contiene un array ( [...] ), es decir, una lista de objetos , necesitas iterar sobre la lista al escribir y al leer. \ud83d\udda5\ufe0f Ejemplo_convertir_listajson_a_binario.kt import kotlinx.serialization.json.Json import java.io.DataOutputStream import java.io.File import java.io.FileOutputStream import java.nio.file.Files import java.nio.file.Paths import java.io.DataInputStream import java.io.FileInputStream fun main() { val rutaJson = \"documentos/lista_personas.json\" val rutaBin = \"documentos/lista_personas.dat\" // Leer JSON val contenido = File(rutaJson).readText() val personas = Json.decodeFromString<List<Persona>>(contenido) // Crear carpeta si no existe Files.createDirectories(Paths.get(rutaBin).parent) // Escribir como binario estructurado val salida = DataOutputStream(FileOutputStream(rutaBin)) salida.writeInt(personas.size) // Guardar el tama\u00f1o de la lista for (persona in personas) { salida.writeUTF(persona.nombre) salida.writeInt(persona.edad) } salida.close() println(\"\u2705 Lista de personas guardada como binario estructurado en: $rutaBin\") // Leer el binario estructurado val entrada = DataInputStream(FileInputStream(rutaBin)) val cantidad = entrada.readInt() // Leer el tama\u00f1o de la lista for (i in 0 until cantidad) { val nombre = entrada.readUTF() val edad = entrada.readInt() println(\"Nombre: $nombre, Edad: $edad\") } entrada.close() } El mismo ejermplo pero utilizando la libre\u00eda Jackson en lugar de Kotlinx.serialization \ud83d\udda5\ufe0f Ejemplo_convertir_listajson_a_binario_Jackson.kt import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper import com.fasterxml.jackson.module.kotlin.readValue import java.io.DataOutputStream import java.io.File import java.io.FileOutputStream import java.nio.file.Files import java.nio.file.Paths import java.io.DataInputStream import java.io.FileInputStream fun main() { val rutaJson = \"documentos/lista_personas.json\" val rutaBin = \"documentos/lista_personas.dat\" // Leer JSON con Jackson val mapper = jacksonObjectMapper() val personas: List<Persona> = mapper.readValue(File(rutaJson)) // Crear carpeta si no existe Files.createDirectories(Paths.get(rutaBin).parent) // Escribir como binario estructurado val salida = DataOutputStream(FileOutputStream(rutaBin)) salida.writeInt(personas.size) // Guardar el tama\u00f1o de la lista for (persona in personas) { salida.writeUTF(persona.nombre) salida.writeInt(persona.edad) } salida.close() println(\"\u2705 Lista de personas guardada como binario estructurado en: $rutaBin\") // Leer el binario estructurado val entrada = DataInputStream(FileInputStream(rutaBin)) val cantidad = entrada.readInt() // Leer el tama\u00f1o de la lista for (i in 0 until cantidad) { val nombre = entrada.readUTF() val edad = entrada.readInt() println(\"Nombre: $nombre, Edad: $edad\") } entrada.close() } \ud83d\udda5\ufe0f Ejemplo_convertir_binario_a_json.kt import kotlinx.serialization.encodeToString import kotlinx.serialization.json.Json import java.io.DataInputStream import java.io.File import java.io.FileInputStream import java.nio.file.Files import java.nio.file.Paths fun main() { val rutaBin = \"documentos/persona.dat\" val rutaJson = \"documentos/persona.json\" // Leer binario estructurado val entrada = DataInputStream(FileInputStream(rutaBin)) val nombre = entrada.readUTF() val edad = entrada.readInt() entrada.close() // Crear objeto val persona = Persona(nombre, edad) // Convertir a JSON con pretty print val json = Json { prettyPrint = true }.encodeToString(persona) // Crear carpeta si no existe Files.createDirectories(Paths.get(rutaJson).parent) // Escribir JSON en archivo File(rutaJson).writeText(json) println(\"\u2705 Binario estructurado convertido a JSON:\") println(json) } Fichero Binario compuesto por una lista de objetos Si el fichero Binario contiene una lista de objetos , debes leer el tama\u00f1o de la lista y luego leer cada objeto uno por uno, construir la lista y convertirla a JSON. \ud83d\udda5\ufe0f Ejemplo_convertir_listabinario_a_json.kt import kotlinx.serialization.encodeToString import kotlinx.serialization.json.Json import java.io.DataInputStream import java.io.File import java.io.FileInputStream import java.nio.file.Files import java.nio.file.Paths fun main() { val rutaBin = \"documentos/lista_personas.dat\" val rutaJson = \"documentos/lista_personas.json\" // Leer binario estructurado val entrada = DataInputStream(FileInputStream(rutaBin)) val cantidad = entrada.readInt() // Leer el tama\u00f1o de la lista val personas = mutableListOf<Persona>() for (i in 0 until cantidad) { val nombre = entrada.readUTF() val edad = entrada.readInt() personas.add(Persona(nombre, edad)) } entrada.close() // Convertir a JSON con pretty print val json = Json { prettyPrint = true }.encodeToString(personas) // Crear carpeta si no existe Files.createDirectories(Paths.get(rutaJson).parent) // Escribir JSON en archivo File(rutaJson).writeText(json) println(\"\u2705 Lista de personas convertida a JSON:\") println(json) } El mismo ejermplo pero utilizando la libre\u00eda Jackson en lugar de Kotlinx.serialization \ud83d\udda5\ufe0f Ejemplo_convertir_listabinario_a_json_Jackson.kt import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper import java.io.DataInputStream import java.io.File import java.io.FileInputStream import java.nio.file.Files import java.nio.file.Paths fun main() { val rutaBin = \"documentos/lista_personas.dat\" val rutaJson = \"documentos/lista_personas.json\" // Leer binario estructurado val entrada = DataInputStream(FileInputStream(rutaBin)) val cantidad = entrada.readInt() // Leer el tama\u00f1o de la lista val personas = mutableListOf<Persona>() for (i in 0 until cantidad) { val nombre = entrada.readUTF() val edad = entrada.readInt() personas.add(Persona(nombre, edad)) } entrada.close() // Convertir a JSON con pretty print usando Jackson val mapper = jacksonObjectMapper() mapper.writerWithDefaultPrettyPrinter().writeValue(File(rutaJson), personas) // Crear carpeta si no existe Files.createDirectories(Paths.get(rutaJson).parent) println(\"\u2705 Lista de personas convertida a JSON con Jackson:\") println(mapper.writeValueAsString(personas)) }","title":"JSON &lt;-&gt; Binario estructurado"},{"location":"T3_Formatos_diferentes/ejercicios/","text":"\ud83d\udcdd Ejercicio 2: Conversi\u00f3n y recuperaci\u00f3n de una ficha en m\u00faltiples formatos \ud83d\udccb Enunciado Se pide crear un programa que trabaje con una ficha de usuario ( Ficha : nombre, edad, biograf\u00eda y preferencias). La informaci\u00f3n de esta ficha se deber\u00e1 guardar en varios formatos distintos y, posteriormente, leerse y mostrarse por consola. \ud83d\udd27 Parte 1: Guardar Crea un objeto Ficha como el siguiente: val ficha = Ficha( nombre = \"Ana\", edad = 30, biografia = \"Ingeniera de software apasionada por la IA y la educaci\u00f3n.\", preferencias = Preferencias( lenguaje = \"Kotlin\", editor = \"IntelliJ\", tema = \"oscuro\" ) ) Implementa funciones que guarden la informaci\u00f3n de este objeto en los siguientes formatos, dentro de una carpeta con su nombre (ej. fichas/ficha_ana ): biografia.txt \u2013 como texto plano. general.csv \u2013 en formato CSV. notas.dat \u2013 binario simple (solo la biograf\u00eda como bytes). registro.bin \u2013 binario estructurado (nombre, edad, biograf\u00eda). preferencias.json \u2013 en JSON (solo las preferencias). ficha.xml \u2013 como XML completo. ficha.obj \u2013 como objeto. \ud83d\udce5 Parte 2: Leer Implementa funciones para leer cada uno de los ficheros anteriores y mostrar la informaci\u00f3n por consola, asegur\u00e1ndote de que los datos son correctos y se han conservado adecuadamente en todos los formatos. \ud83d\udee0\ufe0f Requisitos t\u00e9cnicos Utiliza Path , Files , StandardOpenOption y otras clases de java.nio.file . Mant\u00e9n el c\u00f3digo limpio, estructurado y bien comentado. Todos los archivos deben almacenarse dentro de fichas/ficha_<nombre> . \ud83d\udce4 Ejemplo de salida esperada \ud83d\udcc4 Biograf\u00eda: Ingeniera de software apasionada por la IA y la educaci\u00f3n. \ud83d\udcc4 Ficha CSV: Ana, 30, Ingeniera de software apasionada por la IA y la educaci\u00f3n., Kotlin, IntelliJ, oscuro \ud83d\udce6 Binario simple: Ingeniera de software apasionada por la IA y la educaci\u00f3n. \ud83d\udce6 Binario estructurado: Nombre: Ana Edad: 30 Biograf\u00eda: Ingeniera de software apasionada por la IA y la educaci\u00f3n. \ud83d\udfe8 JSON (preferencias): lenguaje \u2192 Kotlin editor \u2192 IntelliJ tema \u2192 oscuro \ud83d\udcd8 Ficha XML: Nombre: Ana Edad: 30 Biograf\u00eda: Ingeniera de software apasionada por la IA y la educaci\u00f3n. Preferencias: Lenguaje: Kotlin Editor: IntelliJ Tema: oscuro \ud83d\udfe8 Objeto: Ficha(nombre=Ana, edad=30, biografia=Ingeniera de software apasionada por la IA y la educaci\u00f3n., preferencias=Preferencias(lenguaje=Kotlin, editor=IntelliJ, tema=oscuro)) \u2705 R\u00fabrica de evaluaci\u00f3n Criterio Puntos Se crea correctamente la estructura de carpetas 1 Se genera correctamente el archivo de biograf\u00eda ( .txt ) 1 Se genera correctamente el archivo CSV manual 1 Se genera correctamente el binario simple ( .dat ) 1 Se genera correctamente el binario estructurado ( .bin ) 1 Se genera correctamente el archivo JSON con Jackson 1 Se genera correctamente el archivo XML con Jackson 1 Se genera correctamente el archivo serializado ( .obj ) 1 Se implementan correctamente las funciones de lectura y visualizaci\u00f3n 1 C\u00f3digo estructurado, funcional y con buen estilo 1 Total 10","title":"\ud83d\udcdd Ejercicio obligatorio 2"},{"location":"T3_Formatos_diferentes/ejercicios/#ejercicio-2-conversion-y-recuperacion-de-una-ficha-en-multiples-formatos","text":"","title":"\ud83d\udcdd Ejercicio 2: Conversi\u00f3n y recuperaci\u00f3n de una ficha en m\u00faltiples formatos"},{"location":"T3_Formatos_diferentes/ejercicios/#enunciado","text":"Se pide crear un programa que trabaje con una ficha de usuario ( Ficha : nombre, edad, biograf\u00eda y preferencias). La informaci\u00f3n de esta ficha se deber\u00e1 guardar en varios formatos distintos y, posteriormente, leerse y mostrarse por consola. \ud83d\udd27 Parte 1: Guardar Crea un objeto Ficha como el siguiente: val ficha = Ficha( nombre = \"Ana\", edad = 30, biografia = \"Ingeniera de software apasionada por la IA y la educaci\u00f3n.\", preferencias = Preferencias( lenguaje = \"Kotlin\", editor = \"IntelliJ\", tema = \"oscuro\" ) ) Implementa funciones que guarden la informaci\u00f3n de este objeto en los siguientes formatos, dentro de una carpeta con su nombre (ej. fichas/ficha_ana ): biografia.txt \u2013 como texto plano. general.csv \u2013 en formato CSV. notas.dat \u2013 binario simple (solo la biograf\u00eda como bytes). registro.bin \u2013 binario estructurado (nombre, edad, biograf\u00eda). preferencias.json \u2013 en JSON (solo las preferencias). ficha.xml \u2013 como XML completo. ficha.obj \u2013 como objeto. \ud83d\udce5 Parte 2: Leer Implementa funciones para leer cada uno de los ficheros anteriores y mostrar la informaci\u00f3n por consola, asegur\u00e1ndote de que los datos son correctos y se han conservado adecuadamente en todos los formatos.","title":"\ud83d\udccb Enunciado"},{"location":"T3_Formatos_diferentes/ejercicios/#requisitos-tecnicos","text":"Utiliza Path , Files , StandardOpenOption y otras clases de java.nio.file . Mant\u00e9n el c\u00f3digo limpio, estructurado y bien comentado. Todos los archivos deben almacenarse dentro de fichas/ficha_<nombre> . \ud83d\udce4 Ejemplo de salida esperada \ud83d\udcc4 Biograf\u00eda: Ingeniera de software apasionada por la IA y la educaci\u00f3n. \ud83d\udcc4 Ficha CSV: Ana, 30, Ingeniera de software apasionada por la IA y la educaci\u00f3n., Kotlin, IntelliJ, oscuro \ud83d\udce6 Binario simple: Ingeniera de software apasionada por la IA y la educaci\u00f3n. \ud83d\udce6 Binario estructurado: Nombre: Ana Edad: 30 Biograf\u00eda: Ingeniera de software apasionada por la IA y la educaci\u00f3n. \ud83d\udfe8 JSON (preferencias): lenguaje \u2192 Kotlin editor \u2192 IntelliJ tema \u2192 oscuro \ud83d\udcd8 Ficha XML: Nombre: Ana Edad: 30 Biograf\u00eda: Ingeniera de software apasionada por la IA y la educaci\u00f3n. Preferencias: Lenguaje: Kotlin Editor: IntelliJ Tema: oscuro \ud83d\udfe8 Objeto: Ficha(nombre=Ana, edad=30, biografia=Ingeniera de software apasionada por la IA y la educaci\u00f3n., preferencias=Preferencias(lenguaje=Kotlin, editor=IntelliJ, tema=oscuro))","title":"\ud83d\udee0\ufe0f Requisitos t\u00e9cnicos"},{"location":"T3_Formatos_diferentes/ejercicios/#rubrica-de-evaluacion","text":"Criterio Puntos Se crea correctamente la estructura de carpetas 1 Se genera correctamente el archivo de biograf\u00eda ( .txt ) 1 Se genera correctamente el archivo CSV manual 1 Se genera correctamente el binario simple ( .dat ) 1 Se genera correctamente el binario estructurado ( .bin ) 1 Se genera correctamente el archivo JSON con Jackson 1 Se genera correctamente el archivo XML con Jackson 1 Se genera correctamente el archivo serializado ( .obj ) 1 Se implementan correctamente las funciones de lectura y visualizaci\u00f3n 1 C\u00f3digo estructurado, funcional y con buen estilo 1 Total 10","title":"\u2705 R\u00fabrica de evaluaci\u00f3n"},{"location":"T3_Formatos_diferentes/ficheros_intercambio/","text":"Ficheros de intercambio En el desarrollo de aplicaciones, es habitual trabajar con datos almacenados o transmitidos en distintos formatos de ficheros. La conversi\u00f3n entre estos formatos permite intercambiar informaci\u00f3n entre sistemas heterog\u00e9neos, integrarse con APIs, facilitar la persistencia de datos o adaptarse a requisitos espec\u00edficos. \u00bfCu\u00e1ndo utilizar cada uno de ellos? JSON y XML : para APIs REST, configuraci\u00f3n, exportaci\u00f3n de datos. CSV : para importar/exportar datos desde hojas de c\u00e1lculo. Estos formatos no solo permiten guardar la informaci\u00f3n de forma m\u00e1s organizada y legible, sino que requieren utilizar librer\u00edas espec\u00edficas para leer y escribir. En los siguientes apartados veremos c\u00f3mo trabajar con cada uno de estos formatos, qu\u00e9 librer\u00edas se utilizan en Kotlin para manipularlos, y c\u00f3mo adaptar nuestras clases y funciones para poder persistir y recuperar objetos f\u00e1cilmente desde cada tipo de fichero. \ud83d\udd39Data Class Aunque este tipo de ficheros est\u00e1n formados por texto, los programas no deber\u00edan trabajar directamente con texto, sino con datos estructurados. Por este motivo, toda la lectura y escritura de ficheros de intercambio se realizar\u00e1 mediante objetos , y no manipulando directamente cadenas de texto. Cuando leemos un fichero CSV, JSON o XML leemos texto pero, el objetivo final es obtener informaci\u00f3n con significado. Para representar correctamente esa informaci\u00f3n dentro del programa, utilizaremos data class , que nos permiten modelar los datos de forma clara y segura. Define qu\u00e9 informaci\u00f3n tiene un objeto y de qu\u00e9 tipo es cada dato: El data class de una l\u00ednea CSV se repreentar\u00eda as\u00ed: CSV Data Class nombre;nota Luc\u00eda;28 data class Alumno( val nombre: String, val nota: Int ) Ejemplos Para probar y organizar los ejemplos propuestos en esta parte del temario, crearemos un proyecto llamado Ficheros_Gradle , en el que incluiremos Gradle como herramienta de construcci\u00f3n. Los ejemplos los iremos creando directamente en la carpeta src/main/Kotlin . Crearemo tambi\u00e9n la carpeta documentos , donde iremos dejando los ficheros geneados en los distintos ejemplos. | \ud83d\udd39Dependencias Gradle En este apartado vamos a desarrollar una aplicaci\u00f3n en Kotlin que gestione la lectura y escritura de datos utilizando distintos formatos de archivo estructurado: CSV, JSON y XML. Para facilitar el uso de librer\u00edas externas que nos ayuden a trabajar con estos formatos, vamos a utilizar Gradle como herramienta de construcci\u00f3n del proyecto. Gradle nos permitir\u00e1: Gestionar las dependencias necesarias. Automatizar el proceso de compilaci\u00f3n y ejecuci\u00f3n. Organizar el proyecto de forma profesional y escalable. Dependencias que utilizaremos : Formato Librer\u00eda Prop\u00f3sito principal CSV OpenCSV, Kotlin-CSV Lectura y escritura de archivos separados por comas o punto y coma JSON kotlinx.serialization Conversi\u00f3n entre objetos Kotlin y texto JSON (ligero, multiplataforma, oficial) JSON Jackson Conversi\u00f3n entre objetos Java/Kotlin y JSON (muy usado en backend Java) XML javax.xml (DOM API) Construcci\u00f3n y manipulaci\u00f3n manual de documentos XML (bajo nivel, detallado) XML Jackson Conversi\u00f3n directa entre objetos y XML (usando anotaciones, m\u00e1s sencillo) En el fichero build.gradle.kts se incluir\u00e1n los plugins y dependencias necesarias: plugins { kotlin(\"jvm\") version \"2.0.20\" kotlin(\"plugin.serialization\") version \"2.0.20\" application } repositories { mavenCentral() } dependencies { // Kotlin est\u00e1ndar implementation(kotlin(\"stdlib\")) // Serializaci\u00f3n JSON implementation(\"org.jetbrains.kotlinx:kotlinx-serialization-json:1.6.3\") // OpenCSV para CSV implementation(\"com.opencsv:opencsv:5.9\") //Kotlin-CSV implementation(\"com.github.doyaaaaaken:kotlin-csv-jvm:1.9.1\") // librer\u00eda JDOM2 implementation(\"org.jdom:jdom2:2.0.6\") // librerias jackson implementation(\"com.fasterxml.jackson.module:jackson-module-kotlin:2.17.0\") implementation(\"com.fasterxml.jackson.dataformat:jackson-dataformat-xml:2.17.0\") } \ud83d\udd39Ficheros CSV El formato CSV es un archivo de texto donde los valores est\u00e1n separados por comas u otro delimitador (como punto y coma), muy usado para intercambiar datos entre hojas de c\u00e1lculo, sistemas contables, etc. La lectura y escrituara de un archivo CSV se puede hacer de tres formas: Sin utilizar librer\u00edas y mediante la lectura l\u00ednea a l\u00ednea + split(). Con la librer\u00eda OpenCSV . Con la librer\u00eda Kotlin-CSV . En este bloque de contenidos vamos a trabajar con distintos programas de ejemplo y en todos estos casos, los datos representan siempre el mismo tipo de informaci\u00f3n: alumnos. Alumnos.csv nombre:nota Luc\u00eda;9 Carlos;8 Elena;10 La data class Alumno correspondiente ser\u00e1: data class Alumno( val nombre: String, val nota: Int ) \ud83d\udccc Esta clase la crearemos fuera fuera de los programas de ejemplo para poder reutilizarla desde cualquier otro main. \ud83d\udda5\ufe0f 1- Sin librer\u00edas: lectura l\u00ednea a l\u00ednea + split() Ejemplo_CSV_lect_esc.kt import java.nio.file.Files import java.nio.file.Paths import java.nio.file.StandardOpenOption fun main() { val ruta = Paths.get(\"documentos/alumnos.csv\") // 1. Crear contenido CSV (con cabecera) val lineas = listOf( \"nombre;nota\", // cabecera \"Luc\u00eda;9\", \"Carlos;8\", \"Elena;10\" ) // 2. Escribir el archivo Files.write( ruta, lineas, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING ) println(\"Archivo CSV creado: ${ruta.toAbsolutePath()}\") // 3. Leer el archivo y convertir a objetos Alumno val lineasLeidas = Files.readAllLines(ruta) val alumnos = mutableListOf<Alumno>() for (i in lineasLeidas.indices) { // Saltamos la cabecera (l\u00ednea 0) if (i == 0) continue val linea = lineasLeidas[i] val partes = linea.split(\";\") if (partes.size == 2) { val nombre = partes[0] val nota = partes[1].toInt() val alumno = Alumno(nombre, nota) alumnos.add(alumno) } else { println(\"L\u00ednea mal formada: $linea\") } } // 4. Usar los objetos println(\"\\nListado de alumnos:\") for (alumno in alumnos) { println(\"Alumno: ${alumno.nombre}, Nota: ${alumno.nota}\") } } \ud83d\udda5\ufe0f 2- Con OpenCSV Nota OpenCSV fue desarrollado antes de que java.nio.file.Path se introdujera en Java 7, y sus m\u00e9todos a\u00fan usan la API antigua (java.io.*) , como FileReader y FileWriter. Lectura con OpenCSV Clase / M\u00e9todo \u00bfQu\u00e9 hace? Ejemplo b\u00e1sico CSVReader(FileReader) Crea un lector de archivos CSV. val reader = CSVReader(FileReader(\"archivo.csv\")) readAll() Lee todo el contenido como List<Array<String>> . val filas = reader.readAll() readNext() Lee una fila como Array<String> . val fila = reader.readNext() close() Cierra el lector. reader.close() CSVReaderBuilder(...) Permite configurar el lector: separador, comillas, salto de l\u00ednea, etc. CSVReaderBuilder(FileReader(...)).withSeparator(';') withSkipLines(n) Omite las primeras n l\u00edneas (\u00fatil para saltar cabeceras). withSkipLines(1) build() Construye el lector configurado. build() Escritura con OpenCSV Clase / M\u00e9todo \u00bfQu\u00e9 hace? Ejemplo b\u00e1sico CSVWriter(FileWriter) Crea un escritor CSV b\u00e1sico. val writer = CSVWriter(FileWriter(\"archivo.csv\")) writeNext(Array<String>) Escribe una l\u00ednea al CSV. writer.writeNext(arrayOf(\"Ana\", \"30\")) writeAll(List<Array<String>>) Escribe m\u00faltiples filas al CSV. writer.writeAll(listaFilas) flush() Fuerza la escritura del buffer. writer.flush() close() Cierra el escritor. writer.close() CSVWriterBuilder(...) Permite configurar el escritor: delimitador, comillas, escape, etc. CSVWriterBuilder(FileWriter(...)).withSeparator(';') withQuoteChar(c) Define el car\u00e1cter de comillas (por defecto es \" ). withQuoteChar(CSVWriter.NO_QUOTE_CHARACTER) withEscapeChar(c) Define el car\u00e1cter de escape (por defecto \\ ). withEscapeChar('\\\\') withLineEnd(e) Define el car\u00e1cter de fin de l\u00ednea. withLineEnd(\"\\n\") build() Construye el escritor configurado. build() CSVReader y CSVWriter son clases Java, pensadas originalmente para Java, aunque se pueden usar desde Kotlin. Ejempo_OpenCSV_lect_esc.kt import com.opencsv.CSVReader import com.opencsv.CSVWriter import java.io.FileReader import java.io.FileWriter import java.nio.file.Paths fun main() { val ruta = Paths.get(\"documentos/alumnos.csv\").toString() // 1. Escribir el archivo CSV (con cabecera) CSVWriter(FileWriter(ruta)).use { writer -> writer.writeNext(arrayOf(\"nombre\", \"nota\")) //cabecera writer.writeNext(arrayOf(\"Luc\u00eda\", \"9\")) writer.writeNext(arrayOf(\"Carlos\", \"8\")) writer.writeNext(arrayOf(\"Elena\", \"10\")) } println(\"Archivo CSV creado: $ruta\") // 2. Leer el archivo CSV y convertir a objetos Alumno val alumnos = mutableListOf<Alumno>() CSVReader(FileReader(ruta)).use { reader -> val filas = reader.readAll() for (i in filas.indices) { // Saltamos la cabecera if (i == 0) continue val fila = filas[i] if (fila.size == 2) { val nombre = fila[0] val nota = fila[1].toInt() alumnos.add(Alumno(nombre, nota)) } else { println(\"L\u00ednea mal formada: ${fila.joinToString(\";\")}\") } } } // 3. Usar los objetos println(\"\\nListado de alumnos:\") for (alumno in alumnos) { println(\"Alumno: ${alumno.nombre}, Nota: ${alumno.nota}\") } } Nota El archivo CSV generado sin librer\u00edas es un archivo de texto plano con el separador ; , pero sin comillas y sin escape. En cambio, el fichero CSV generado con OpenCSV sigue el estantar CSV (RFC 4180) que incluye encerrar los campos entre comillas dobles, si el campo contiene el separador (como ; o , ). \ud83d\udda5\ufe0f 3- Con Kotlin-CSV Nota la librer\u00eda kotlin-csv tambi\u00e9n utiliza java.io.File para muchas de sus operaciones principales, aunque de una forma un poco m\u00e1s moderna y flexible que OpenCSV . Tradicionalmente, en entornos Java se ha utilizado la librer\u00eda OpenCSV para leer y escribir este tipo de archivos, debido a su potencia y versatilidad, sin embargo, cuando desarrollamos en Kotlin, existen alternativas m\u00e1s modernas y adaptadas al lenguaje. Una de ellas es kotlin-csv, una librer\u00eda ligera y expresiva dise\u00f1ada espec\u00edficamente para aprovechar las ventajas de Kotlin, como las expresiones lambda, la sintaxis DSL y el trabajo con secuencias (sequences) y corrutinas. csvWriter y csvReader no son clases, sino funciones DSL propias de Kotlin Tipo M\u00e9todo Ejemplo m\u00ednimo Lectura readAll(File) val filas = csvReader().readAll(File(\"alumnos.csv\")) readAllWithHeader(File) val datos = csvReader().readAllWithHeader(File(\"alumnos.csv\")) open { readAllAsSequence() } csvReader().open(\"alumnos.csv\") { readAllAsSequence().forEach { println(it) } } Escritura writeAll(data, File) csvWriter().writeAll(listOf(listOf(\"Luc\u00eda\", \"9\")), File(\"salida.csv\")) writeRow(row, File) csvWriter().writeRow(listOf(\"Carlos\", \"8\"), File(\"salida.csv\")) writeAllWithHeader(data, File) csvWriter().writeAllWithHeader(listOf(mapOf(\"nombre\" to \"Elena\", \"nota\" to \"10\")), File(\"salida.csv\")) Configuraci\u00f3n delimiter , quoteChar , etc. csvReader { delimiter = ';' } Ejempo_KotlinCSV_lect_esc.kt import com.github.doyaaaaaken.kotlincsv.dsl.csvReader import com.github.doyaaaaaken.kotlincsv.dsl.csvWriter import java.io.File import java.nio.file.Paths fun main() { val ruta = Paths.get(\"documentos/alumnos.csv\").toString() // Escribir con cabecera csvWriter().open(ruta) { writeRow(listOf(\"nombre\", \"nota\")) //cabecera writeRow(listOf(\"Luc\u00eda\", \"9\")) writeRow(listOf(\"Carlos\", \"8\")) writeRow(listOf(\"Elena\", \"10\")) } // Leer con cabecera (como Map) val filas: List<Map<String, String>> = csvReader().readAllWithHeader(File(ruta)) val alumnos = filas.mapNotNull { fila -> val nombre = fila[\"nombre\"] val notaStr = fila[\"nota\"] if (nombre != null && notaStr != null) Alumno(nombre, notaStr.toInt()) else null } println(\"Listado de alumnos:\") alumnos.forEach { println(\"Alumno: ${it.nombre}, Nota: ${it.nota}\") } } \ud83d\udd39Ficheros JSON En muchas aplicaciones modernas, los datos deben almacenarse o intercambiarse en formato JSON (JavaScript Object Notation), un formato ligero y legible ampliamente utilizado en APIs, configuraciones, bases de datos NoSQL y almacenamiento persistente. Estructura La estructura de los ficheros JSON (JavaScript Object Notation) se basa en una sintaxis sencilla y legible para representar datos estructurados. JSON est\u00e1 formado por pares clave-valor y/o listas ordenadas de valores. Ejemplo : Informaci\u00f3n sobre un alumno. \"alumno\": { \"nombre\": \"Mar\u00eda\", \"edad\": 20, \"activo\": true, \"notas\": [8.5, 9.2, 7.8], \"direccion\": { \"calle\": \"Av. del Sol\", \"ciudad\": \"Valencia\", \"codigoPostal\": 46001} } Elementos principales Objeto: Conjunto de pares clave-valor, delimitado por {}: \"alumno\" Array: Lista ordenada de valores, delimitada por []: \"notas\" Clave: Siempre entre comillas dobles: \"nombre\" Valor: Puede ser: string, n\u00famero, booleano, null, objeto o array: \"Mar\u00eda\", \"Valencia\", 20, true, etc. Librer\u00edas En Kotlin , existen varias librer\u00edas que permiten trabajar con ficheros JSON de forma sencilla: Librer\u00eda Lenguaje base Uso recomendado Multiplataforma Notas destacadas kotlinx.serialization Kotlin Kotlin puro y Kotlin Multiplatform \u2705 S\u00ed Ligera, r\u00e1pida y con soporte oficial de JetBrains Jackson Java Proyectos Java/Kotlin con Spring Boot \u274c No Muy flexible y poderosa Gson Java Aplicaciones Android o proyectos simples \u274c No F\u00e1cil de usar, pero m\u00e1s lenta y menos segura org.json Java Scripts r\u00e1pidos o aprendizaje \u274c No Acceso directo a claves sin clases de datos Cuando trabajamos con ficheros JSON en Kotlin , existen dos formas de acceder a los datos, tratarlos como texto plano o estructuras gen\u00e9ricas, o convertirlos directamente en objetos Kotlin. Aunque la primera opci\u00f3n es posible y \u00fatil en ciertos casos, trabajar sin conversi\u00f3n implica mayor esfuerzo manual, riesgo de errores en los nombres de claves y ausencia de validaci\u00f3n de tipos. Las librer\u00edas kotlinx.serialization y Jackson nos permiten convertir los ficheros JSON a objetos y viceversa. Esto proporciona importantes ventajas : \u2714\ufe0f Validaci\u00f3n autom\u00e1tica de la estructura del JSON. \u2714\ufe0f Conversi\u00f3n directa entre JSON y objetos Kotlin. \u2714\ufe0f C\u00f3digo m\u00e1s limpio y mantenible. \u2714\ufe0f Mayor seguridad de tipos, detectando errores en tiempo de compilaci\u00f3n. \ud83d\udd39 kotlinx.serialization kotlinx.serialization es la librer\u00eda oficial de serializaci\u00f3n de Kotlin, desarrollada por JetBrains, que permite convertir objetos Kotlin a y desde diferentes formatos como JSON, ProtoBuf, CBOR, XML (experimental), entre otros. Como ya vimos en el apartado anterior, la serializaci\u00f3n es el proceso de convertir los datos utilizados por una aplicaci\u00f3n a un formato que pueda transferirse por red o almacenarse en una base de datos o archivo. A su vez, la deserializaci\u00f3n es el proceso inverso: leer datos de una fuente externa y convertirlos en un objeto de tiempo de ejecuci\u00f3n. Nota Todas las bibliotecas de serializaci\u00f3n de Kotlin pertenecen al grupo org.jetbrains.kotlinx:grupo . Sus nombres empiezan con kotlinx-serialization- y tienen sufijos que reflejan el formato de serializaci\u00f3n: org.jetbrains.kotlinx:kotlinx-serialization-json Clases y funciones clave de kotlinx.serialization.json Clase / Funci\u00f3n Tipo Descripci\u00f3n Json Clase Punto de entrada principal para serializar y deserializar en JSON JsonObject Clase Representa un objeto JSON {} como un Map<String, JsonElement> JsonArray Clase Representa un array JSON [] , como una lista de JsonElement JsonElement Clase Superclase abstracta para cualquier valor JSON JsonPrimitive Clase Representa valores primitivos JSON (string, n\u00famero, booleano, null) JsonNull Objeto Representa el valor null en JSON JsonLiteral Clase Subtipo de JsonPrimitive que representa valores literales (string/num) JsonObjectBuilder Clase DSL Permite construir objetos JSON usando buildJsonObject { ... } JsonArrayBuilder Clase DSL Permite construir arrays JSON usando buildJsonArray { ... } buildJsonObject { ... } Funci\u00f3n Crea un JsonObject de forma declarativa buildJsonArray { ... } Funci\u00f3n Crea un JsonArray de forma declarativa parseToJsonElement(...) Funci\u00f3n Convierte un String en JsonElement (analiza el JSON sin clase) encodeToJsonElement(...) Funci\u00f3n Convierte un objeto Kotlin en JsonElement usando un Json decodeFromJsonElement(...) Funci\u00f3n Convierte un JsonElement a un objeto Kotlin jsonPrimitive Propiedad Accede al valor primitivo dentro de un JsonElement jsonObject Propiedad Convierte un JsonElement a JsonObject (si es compatible) jsonArray Propiedad Convierte un JsonElement a JsonArray (si es compatible) M\u00e9todos principales de kotlinx.serialization Son funciones generales que no est\u00e1n dentro del paquete .json, pero que se usan muy a menudo en la serializaci\u00f3n en Kotlin. M\u00e9todo de kotlinx.serialization \u00bfQu\u00e9 hace? Ejemplo b\u00e1sico Json.encodeToString(objeto) Convierte un objeto Kotlin a una cadena JSON. Json.encodeToString(persona) Json.encodeToString(serializer, obj) Igual que el anterior pero especificando el serializador. Json.encodeToString(Persona.serializer(), persona) Json.decodeFromString(json) Convierte una cadena JSON a un objeto Kotlin. Json.decodeFromString<Persona>(json) Json.decodeFromString(serializer, s) Igual que el anterior pero con el serializador expl\u00edcito. Json.decodeFromString(Persona.serializer(), json) Json.encodeToJsonElement(objeto) Convierte un objeto a un \u00e1rbol JsonElement . val elem = Json.encodeToJsonElement(persona) Json.decodeFromJsonElement(elem) Convierte un JsonElement a objeto Kotlin. val persona = Json.decodeFromJsonElement<Persona>(elem) Json.parseToJsonElement(string) Parsea una cadena JSON a un \u00e1rbol JsonElement sin mapear. val elem = Json.parseToJsonElement(json) Requisitos para usar kotlinx.serialization en Gradle (JSON) Activar el plugin de Kotlin serialization en build.gradle.kts plugins { kotlin(\"jvm\") version \"2.0.20\" kotlin(\"plugin.serialization\") version \"2.0.20\" application } dependencies { implementation(\"org.jetbrains.kotlinx:kotlinx-serialization-json:1.6.3\") } \u26a0\ufe0f Aseg\u00farate de usar una versi\u00f3n compatible con tu Kotlin. Por ejemplo, 1.6.3 funciona bien con Kotlin 2.0.20. Anota tus clases con @Serializable import kotlinx.serialization.Serializable @Serializable data class Objeto(val clave1: String, val clave2: Int) Nota En Kotlin, las data class est\u00e1n dise\u00f1adas para modelar datos puros. La palabra clave data no es obligatoria para la serializaci\u00f3n, pero se usa por buena pr\u00e1ctica y para obtener funcionalidades adicionales que son muy \u00fatiles, especialmente cuando trabajas con objetos de datos, como toString(), equals(), hashCode(), copy().. Utiliza el objeto Json para serializar/deserializar Para serializar una instancia de esta clase llamamos a Json.encodeToString() y para deserializar llamamos a Json.decodeFromString() . import kotlinx.serialization.json.Json import kotlinx.serialization.encodeToString import kotlinx.serialization.decodeFromString fun main() { val obj = Objeto(\"Mar\u00eda\", 22) val json = Json.encodeToString(obj) println(\"JSON: $json\") val obj = Json.decodeFromString<Objeto>(json) println(\"Objeto: $obj\") } Tambi\u00e9n puedes serializar colecciones de objetos , como listas, en una sola llamada: val dataList = listOf(Objeto(\"Mar\u00eda\", 22), Objeto(\"Carlos\", 30), Objeto(\"Ana\", 18)) val jsonList = Json.encodeToString(dataList) El resultado ser\u00eda: [ {\"nombre\":\"Luc\u00eda\",\"edad\":28}, {\"nombre\":\"Carlos\",\"edad\":30}, {\"nombre\":\"Elena\",\"edad\":18} ] Ejemplo de lectura y escritura de un archivo json Estructura del proyecto: Ficheros_Gradle/ \u251c\u2500\u2500 documentos/ | \u2514\u2500\u2500persona.json \u2514\u2500\u2500 src/ \u2514\u2500\u2500 main/ \u2514\u2500\u2500 kotlin/ \u2514\u2500\u2500 Ejemplos/ \u2514\u2500\u2500Ejemplo_JSON_KSerialization.kt \u2514\u2500\u2500Persona.kt 1- El fichero json que vamos a generar ser\u00e1 el que tenga el siguiente contenido. Es un objeto JSON que contiene dos atributos, nombre y edad, representando una persona.: { \"nombre\": \"Luc\u00eda\", \"edad\": 28 } 2- Crea la Data Class Persona.kt con la misma estructura del archivo fuera del programa de ejemplo para poder reutilizarla desde cualquier otro main. Anota la clase como serializable . import kotlinx.serialization.Serializable @Serializable data class Persona(val nombre: String, val edad: Int) \ud83d\udda5\ufe0f Ejemplo_JSON_KSerialization.kt import kotlinx.serialization.encodeToString import kotlinx.serialization.json.* import java.nio.file.Files import java.nio.file.Paths import java.io.IOException import java.nio.file.Files.readString fun escribirJSON() { val ruta = Paths.get(\"documentos/persona.json\") val persona = Persona(\"Luc\u00eda\", 28) try { // Convertir a String con formato bonito val jsonString = Json { prettyPrint = true }.encodeToString(persona) // Crear carpeta si no existe Files.createDirectories(ruta.parent) // Escribir JSON en archivo Files.writeString(ruta, jsonString) println(\"Archivo JSON creado en: ${ruta.toAbsolutePath()}\") println(\"Contenido:\\n$jsonString\") } catch (e: IOException) { println(\"\u26a0\ufe0f Error de entrada/salida: ${e.message}\") } catch (e: Exception) { println(\"\u26a0\ufe0f Error inesperado: ${e.message}\") } } fun leerJSON(){ val rutaEntrada = Paths.get(\"documentos/persona.json\") // --- Lectura segura --- try { if (!Files.exists(rutaEntrada)) { println(\"El archivo no existe: $rutaEntrada\") return } val contenidoJson = readString(rutaEntrada) val persona = Json.decodeFromString<Persona>(contenidoJson) println(\"Lectura correcta: $persona\") } catch (e: IOException) { println(\"Error de E/S: ${e.message}\") } } fun main() { escribirJSON() leerJSON() } \ud83d\udd39Jackson (JSON) Jackson es la librer\u00eda m\u00e1s usada en Java para JSON. Muchos frameworks Java lo usan por defecto (Spring Boot, Micronaut, Quarkus, etc.). Conocerlo permite trabajar con APIs externas, backends y entornos mixtos (Java + Kotlin). Mientras que kotlinx.serialization est\u00e1 centrado en JSON y formatos binarios (CBOR, ProtoBuf...), Jackson tambi\u00e9n soporta XML, YAML, CSV de forma unificada, adem\u00e1s, si necesitas convertir entre formatos (XML \u2194 JSON), Jackson es ideal, por lo que es importante cononcer ambas librer\u00edas para entender los proyectos Kotlin puros y modernos (kotlinx.serialization) y tambi\u00e9n los proyectos reales empresariales con Jackson. Clases esenciales para trabajar con JSON usando Jackson Clase / interfaz Para qu\u00e9 sirve ObjectMapper La clase principal para leer y escribir JSON File (de java.io) Representa el archivo f\u00edsico JSON Tu data class en Kotlin Define la estructura del objeto a leer o escribir M\u00e9todo Jackson \u00bfQu\u00e9 hace? Ejemplo b\u00e1sico readValue(String, Class) Convierte una cadena JSON a un objeto Kotlin o Java. mapper.readValue(json, Persona::class.java) readValue(File, Class) Convierte un archivo JSON a un objeto. mapper.readValue(File(\"persona.json\"), Persona::class.java) readTree(String) Lee un JSON como \u00e1rbol ( JsonNode ) sin mapear a clase. val node = mapper.readTree(json) writeValue(File, Object) Escribe un objeto como JSON en un archivo. mapper.writeValue(File(\"salida.json\"), persona) writeValueAsString(Object) Convierte un objeto en una cadena JSON. val json = mapper.writeValueAsString(persona) writeValueAsBytes(Object) Convierte un objeto en un array de bytes JSON. val bytes = mapper.writeValueAsBytes(persona) writerWithDefaultPrettyPrinter() Devuelve un escritor que formatea (indentado) el JSON. mapper.writerWithDefaultPrettyPrinter().writeValue(...) Anotaciones en Jackson Las anotaciones en Jackson (como @JsonIgnoreProperties, @JsonProperty, etc.) no siempre son necesarias, pero se usan para resolver problemas comunes al serializar o deserializar objetos. Caso \u00bfAnotaci\u00f3n necesaria? JSON coincide exactamente con la data class \u274c No JSON tiene campos extra \u2705 S\u00ed (@JsonIgnoreProperties) Nombres distintos en JSON \u2705 S\u00ed (@JsonProperty) Quieres ocultar campos \u2705 S\u00ed (@JsonIgnore) Anotaci\u00f3n \u00bfPara qu\u00e9 sirve? @JsonProperty(\"x\") Mapear nombres distintos entre JSON y la clase @JsonIgnore Excluir una propiedad al serializar/deserializar @JsonIgnoreProperties(ignoreUnknown = true) Evitar errores por campos JSON no mapeados @JsonInclude(...) Excluir valores nulos o vac\u00edos en el JSON Ejemplo de lectura y escritura con Jackson Dependencia Gradle: dependencies { implementation(\"com.fasterxml.jackson.module:jackson-module-kotlin:2.17.0\") } Nota \u26a0\ufe0f Con la librer\u00eda Jackson no es obligatorio usar la anotaci\u00f3n @Serializable . Jackson puede trabajar directamente con clases normales de Kotlin. En este caso, seguiremos utilizando la data class Persona , que ya est\u00e1 anotada con @Serializable porque se usa tambi\u00e9n en ejemplos con kotlinx.serialization . \ud83d\udc49 Esta anotaci\u00f3n no afecta a Jackson ni provoca errores, por lo que la misma clase se puede reutilizar sin problemas en ambos casos. import kotlinx.serialization.Serializable @Serializable data class Persona(val nombre: String, val edad: Int) \ud83d\udda5\ufe0f Ejemplo_JSON_jackson.kt import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper import com.fasterxml.jackson.module.kotlin.readValue import java.io.File fun escribirJson() { val mapper = jacksonObjectMapper() val persona = Persona(\"Mario\", 35) val archivo = File(\"documentos/persona.json\") mapper.writerWithDefaultPrettyPrinter().writeValue(archivo, persona) println(\"JSON generado correctamente en: ${archivo.absolutePath}\") } fun leerJson() { val mapper = jacksonObjectMapper() val archivo = File(\"documentos/persona.json\") val persona = mapper.readValue<Persona>(archivo) println(\"Lectura correcta: ${persona.nombre} tiene ${persona.edad} a\u00f1os.\") } fun main() { escribirJson() leerJson() } Ejemplo de lectura y escritura de un array (lista) de elementos con Jackson Fichero JSON compuesto por una lista de elementos Si el fichero JSON contiene un array ( [...] ), es decir, una lista de objetos , entonces debemos indicar expl\u00edcitamente que queremos leer un List<Objeto> . [ { \"nombre\" : \"Luc\u00eda\", \"edad\" : 28 }, { \"nombre\" : \"Pepe\", \"edad\" : 30 }, { \"nombre\" : \"Ana\", \"edad\" : 50 }, { \"nombre\" : \"Juan\", \"edad\" : 12 } ] \ud83d\udda5\ufe0f Ejemplo_listaJSON_jackson.kt import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper import com.fasterxml.jackson.module.kotlin.readValue import java.io.File fun escribirListaJson() { val mapper = jacksonObjectMapper() val personas = listOf( Persona(\"Luc\u00eda\", 28), Persona(\"Pepe\", 30), Persona(\"Ana\", 50), Persona(\"Juan\", 12) ) val archivo = File(\"documentos/lista_personas.json\") mapper.writerWithDefaultPrettyPrinter().writeValue(archivo, personas) println(\"JSON generado correctamente en: ${archivo.absolutePath}\") } fun leerListaJson() { val mapper = jacksonObjectMapper() val archivo = File(\"documentos/lista_personas.json\") val lista=mapper.readValue<List<Persona>>(archivo) for (p in lista) { println(\"${p.nombre} tiene ${p.edad} a\u00f1os.\") } } fun main() { escribirListaJson() leerListaJson() } \ud83d\udd39Ficheros XML Un fichero XML (eXtensible Markup Language) es un formato de texto estructurado dise\u00f1ado para almacenar y transportar datos de forma legible tanto para humanos como para m\u00e1quinas. Tiene una estructura jer\u00e1rquica basada en etiquetas, similar al HTML, pero orientada al contenido de datos, no a la presentaci\u00f3n. XML permite guardar objetos o estructuras de datos en un archivo de texto legible. Estructura <raiz> <!-- Elemento ra\u00edz obligatorio --> <elemento> <subelemento>valor</subelemento> </elemento> <otroElemento atributo=\"valor\" /> </raiz> La mejor forma de trabajar con XML en Kotlin es utlizar la librer\u00eda DOM (Document Object Model) o JDOM2 , que permiten crear, leer y modificar f\u00e1cilmente estructuras XML. DOM -> Est\u00e1ndar Java, sin dependencias. Requiere muchas l\u00edneas de c\u00f3digo para hacer algo relativamente simple. JDOM2 -> API m\u00e1s amigable para desarrolladores. Requiere a\u00f1adir una librer\u00eda externa. \ud83d\udd39JDOM2 JDOM2 es una librer\u00eda ligera y f\u00e1cil de usar para trabajar con XML de forma manual y controlada, ideal cuando no necesitas solo convertir directamente a objetos, sino manipular el contenido de manera estructurada. Clase \u00bfPara qu\u00e9 sirve? SAXBuilder Analiza (parsea) un archivo XML y devuelve un Document. Document Representa todo el documento XML. Element Representa una etiqueta (nodo) del XML. Attribute Representa un atributo dentro de una etiqueta. XMLOutputter Convierte el \u00e1rbol de elementos en texto XML. M\u00e9todos comunes de JDOM2 para manipular XML M\u00e9todo Clase Descripci\u00f3n Element(String name) Element Crea un nuevo elemento XML con el nombre especificado addContent(Element child) Element A\u00f1ade un elemento hijo al elemento actual addContent(String text) Element A\u00f1ade texto al contenido del elemento setText(String text) Element Establece el texto del elemento getText() Element Obtiene el texto del elemento getChild(String name) Element Obtiene el primer hijo con ese nombre getChildren(String name) Element Obtiene todos los hijos con ese nombre getChildren() Element Obtiene todos los hijos del elemento setAttribute(String, String) Element Establece un atributo del elemento getAttributeValue(String) Element Obtiene el valor de un atributo Document(Element root) Document Crea un documento XML con el elemento ra\u00edz dado getRootElement() Document Obtiene el elemento ra\u00edz del documento SAXBuilder().build(File) SAXBuilder Carga un documento XML desde un archivo XMLOutputter().output(Document, OutputStream) XMLOutputter Escribe el documento XML en una salida (archivo, consola, etc.) setFormat(Format.prettyFormat()) XMLOutputter Establece un formato bonito con sangr\u00edas JDOM2 no realiza serializaci\u00f3n autom\u00e1tica de objetos Kotlin, se necesita mapear manualmente entre objetos (data class) y elementos XML. A continuaci\u00f3n lo veremos con un ejemplo: Ejemplo de lectura y escritura de un archivo xml con JDOM2 : Vamos a generar el siguiente archivo XML utilizando dos ejemplos, uno se encargar\u00e1 de crear el documento XML, y otro de leer su contenido desde el fichero generado. <?xml version=\"1.0\" encoding=\"UTF-8\"?> <alumnos> <alumno> <nombre>Luc\u00eda</nombre> <nota>8</nota> </alumno> <alumno> <nombre>Carlos</nombre> <nota>6</nota> </alumno> <alumno> <nombre>Elena</nombre> <nota>10</nota> </alumno> </alumnos> Dependencias en build.gradle.kts dependencies { implementation(\"org.jdom:jdom2:2.0.6\") } Reutilizamos la clase Alumno creada en los ejemplos anteriores: data class Alumno(val nombre: String, val nota: Int) \ud83d\udda5\ufe0f Ejemplo_Objeto_a_XML.kt : Leemos el objeto Alumno y lo convertimos en fichero xml (alumnos.xml). import org.jdom2.Document import org.jdom2.Element import org.jdom2.output.Format import org.jdom2.output.XMLOutputter import java.io.File fun main() { // Lista de alumnos val alumnos = listOf( Alumno(\"Luc\u00eda\", 8), Alumno(\"Carlos\", 6), Alumno(\"Elena\", 10) ) // Crear elemento ra\u00edz <alumnos> val raiz = Element(\"alumnos\") // A\u00f1adir cada alumno como <alumno> for (alumno in alumnos) { val alumnoElement = Element(\"alumno\") alumnoElement.addContent(Element(\"nombre\").setText(alumno.nombre)) alumnoElement.addContent(Element(\"nota\").setText(alumno.nota.toString())) raiz.addContent(alumnoElement) } // Crear el documento XML val documento = Document(raiz) // Escribir en archivo con formato bonito val salida = XMLOutputter() salida.format = Format.getPrettyFormat() salida.output(documento, File(\"documentos/alumnos.xml\").outputStream()) println(\"Archivo XML creado con \u00e9xito.\") } \ud83d\udda5\ufe0f Ejemplo_XML_a_Objeto.kt : Leemos el archivo alumnos.xml y lo convertimos a objeto. import org.jdom2.input.SAXBuilder import java.io.File fun main() { //Crea una lista mutable de tipo Alumno. val alumnos = mutableListOf<Alumno>() val archivo = File(\"documentos/alumnos.xml\") val builder = SAXBuilder() val documento = builder.build(archivo) val raiz = documento.rootElement val listaAlumnos = raiz.getChildren(\"alumno\") //Por cada nodo <alumno> del XML, crea un objeto Alumno con sus atributos. for (elemento in listaAlumnos) { val nombre = elemento.getChildText(\"nombre\") val nota = elemento.getChildText(\"nota\").toIntOrNull() ?: 0 alumnos.add(Alumno(nombre, nota)) } // Mostrar los objetos alumnos.forEach { println(it) } } \ud83d\udd39Jackson (XML) JDOM2 no realiza serializaci\u00f3n autom\u00e1tica de objetos Kotlin, pero se puede recurrir a librer\u00edas como Jackson o kotlinx.serialization . A diferencia de la librer\u00eda kotlinx.serialization-josn , para ficheros JSON , que es es la librer\u00eda oficial de serializaci\u00f3n de Kotlin, la librer\u00eda kotlinx.serialization-xml , para ficheros XML , no es oficial (a\u00fan experimental) y est\u00e1 mantenidad por terceros, por lo que no es una buena elecci\u00f3n. Utilizaremos, por tanto, la librer\u00eda Jackson para realizar la serializaci\u00f3n autom\u00e1tica de objetos Kotlin, la cual tambi\u00e9n permite soporte completo para XML y JSON, es decier, puede serializar y deserializar ambos formatos usando las mismas clases. M\u00e9todos comunes de Jackson para XML (XmlMapper) M\u00e9todo Clase Descripci\u00f3n readValue(File, Class<T>) XmlMapper Lee un archivo XML y lo convierte en un objeto Kotlin/Java readValue(String, Class<T>) XmlMapper Lee un String XML y lo convierte en un objeto writeValue(File, Object) XmlMapper Escribe un objeto como XML en un archivo writeValueAsString(Object) XmlMapper Convierte un objeto en una cadena XML writeValueAsBytes(Object) XmlMapper Convierte un objeto en un array de bytes XML registerModule(Module) ObjectMapper / XmlMapper Registra un m\u00f3dulo como KotlinModule o JavaTimeModule enable(SerializationFeature) XmlMapper Activa una opci\u00f3n de serializaci\u00f3n (por ejemplo, indentado) disable(DeserializationFeature) XmlMapper Desactiva una opci\u00f3n de deserializaci\u00f3n configure(MapperFeature, boolean) XmlMapper Configura opciones generales del mapeo setDefaultPrettyPrinter(...) XmlMapper Establece un formateador personalizado Ejemplo de lectura y escritura del fichero alumnos.xml con Jackson XML Dependencias en build.gradle.kts : dependencies { implementation(\"com.fasterxml.jackson.module:jackson-module-kotlin:2.17.0\") implementation(\"com.fasterxml.jackson.dataformat:jackson-dataformat-xml:2.17.0\") } Siguiendo con el ejemplo alumnos.xml : <?xml version=\"1.0\" encoding=\"UTF-8\"?> <alumnos> <alumno> <nombre>Luc\u00eda</nombre> <nota>8</nota> </alumno> <alumno> <nombre>Carlos</nombre> <nota>6</nota> </alumno> <alumno> <nombre>Elena</nombre> <nota>10</nota> </alumno> </alumnos> Clase Contenedora En XML siempre hay un \u00fanico elemento ra\u00edz. Jackson necesita una clase que represente ese nodo ra\u00edz. En nuestro ejemplo ese elemento ra\u00edz es: <alumnos> Creamos la clase contenedora ListaAlumnos , que act\u00faa como puente entre el XML y Kotlin. Esta clase da nombre al nodo raiz <alumnos> y explica como mapear los elementos repetidos <alumno> . data class ListaAlumnos( @JacksonXmlElementWrapper(useWrapping = false) // No a\u00f1ade un <alumnoList>, usa directamente <alumno> @JacksonXmlProperty(localName = \"alumno\") // Cada elemento se llama <alumno> val alumno: List<Alumno> = emptyList() ) \ud83d\udda5\ufe0f Ejemplo_XML_Jackson.kt import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlElementWrapper import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty import com.fasterxml.jackson.dataformat.xml.XmlMapper import com.fasterxml.jackson.module.kotlin.KotlinModule import com.fasterxml.jackson.module.kotlin.readValue import com.fasterxml.jackson.module.kotlin.registerKotlinModule import java.io.File fun escribirXml() { val xmlMapper = XmlMapper().registerModule(KotlinModule.Builder().build()) val lista = ListaAlumnos( listOf( Alumno(\"Luc\u00eda\", 8), Alumno(\"Carlos\", 6), Alumno(\"Mar\u00eda\", 10) ) ) val archivo = File(\"documentos/alumnos.xml\") xmlMapper.writerWithDefaultPrettyPrinter().writeValue(archivo, lista) println(\"XML escrito correctamente en: ${archivo.absolutePath}\") } fun leerXml() { val xmlMapper = XmlMapper().registerKotlinModule() val archivo = File(\"documentos/alumnos.xml\") //val lista = xmlMapper.readValue(archivo, ListaAlumnos::class.java) val lista=xmlMapper.readValue<ListaAlumnos>(archivo) println(\"Lectura correcta:\") lista.alumno.forEach { println(\"${it.nombre} tiene un ${it.nota}\") } } fun main() { escribirXml() leerXml() }","title":"\ud83d\udd39Ficheros de intercambio"},{"location":"T3_Formatos_diferentes/ficheros_intercambio/#ficheros-de-intercambio","text":"En el desarrollo de aplicaciones, es habitual trabajar con datos almacenados o transmitidos en distintos formatos de ficheros. La conversi\u00f3n entre estos formatos permite intercambiar informaci\u00f3n entre sistemas heterog\u00e9neos, integrarse con APIs, facilitar la persistencia de datos o adaptarse a requisitos espec\u00edficos. \u00bfCu\u00e1ndo utilizar cada uno de ellos? JSON y XML : para APIs REST, configuraci\u00f3n, exportaci\u00f3n de datos. CSV : para importar/exportar datos desde hojas de c\u00e1lculo. Estos formatos no solo permiten guardar la informaci\u00f3n de forma m\u00e1s organizada y legible, sino que requieren utilizar librer\u00edas espec\u00edficas para leer y escribir. En los siguientes apartados veremos c\u00f3mo trabajar con cada uno de estos formatos, qu\u00e9 librer\u00edas se utilizan en Kotlin para manipularlos, y c\u00f3mo adaptar nuestras clases y funciones para poder persistir y recuperar objetos f\u00e1cilmente desde cada tipo de fichero.","title":"Ficheros de intercambio"},{"location":"T3_Formatos_diferentes/ficheros_intercambio/#data-class","text":"Aunque este tipo de ficheros est\u00e1n formados por texto, los programas no deber\u00edan trabajar directamente con texto, sino con datos estructurados. Por este motivo, toda la lectura y escritura de ficheros de intercambio se realizar\u00e1 mediante objetos , y no manipulando directamente cadenas de texto. Cuando leemos un fichero CSV, JSON o XML leemos texto pero, el objetivo final es obtener informaci\u00f3n con significado. Para representar correctamente esa informaci\u00f3n dentro del programa, utilizaremos data class , que nos permiten modelar los datos de forma clara y segura. Define qu\u00e9 informaci\u00f3n tiene un objeto y de qu\u00e9 tipo es cada dato: El data class de una l\u00ednea CSV se repreentar\u00eda as\u00ed: CSV Data Class nombre;nota Luc\u00eda;28 data class Alumno( val nombre: String, val nota: Int ) Ejemplos Para probar y organizar los ejemplos propuestos en esta parte del temario, crearemos un proyecto llamado Ficheros_Gradle , en el que incluiremos Gradle como herramienta de construcci\u00f3n. Los ejemplos los iremos creando directamente en la carpeta src/main/Kotlin . Crearemo tambi\u00e9n la carpeta documentos , donde iremos dejando los ficheros geneados en los distintos ejemplos. |","title":"\ud83d\udd39Data Class"},{"location":"T3_Formatos_diferentes/ficheros_intercambio/#dependencias-gradle","text":"En este apartado vamos a desarrollar una aplicaci\u00f3n en Kotlin que gestione la lectura y escritura de datos utilizando distintos formatos de archivo estructurado: CSV, JSON y XML. Para facilitar el uso de librer\u00edas externas que nos ayuden a trabajar con estos formatos, vamos a utilizar Gradle como herramienta de construcci\u00f3n del proyecto. Gradle nos permitir\u00e1: Gestionar las dependencias necesarias. Automatizar el proceso de compilaci\u00f3n y ejecuci\u00f3n. Organizar el proyecto de forma profesional y escalable. Dependencias que utilizaremos : Formato Librer\u00eda Prop\u00f3sito principal CSV OpenCSV, Kotlin-CSV Lectura y escritura de archivos separados por comas o punto y coma JSON kotlinx.serialization Conversi\u00f3n entre objetos Kotlin y texto JSON (ligero, multiplataforma, oficial) JSON Jackson Conversi\u00f3n entre objetos Java/Kotlin y JSON (muy usado en backend Java) XML javax.xml (DOM API) Construcci\u00f3n y manipulaci\u00f3n manual de documentos XML (bajo nivel, detallado) XML Jackson Conversi\u00f3n directa entre objetos y XML (usando anotaciones, m\u00e1s sencillo) En el fichero build.gradle.kts se incluir\u00e1n los plugins y dependencias necesarias: plugins { kotlin(\"jvm\") version \"2.0.20\" kotlin(\"plugin.serialization\") version \"2.0.20\" application } repositories { mavenCentral() } dependencies { // Kotlin est\u00e1ndar implementation(kotlin(\"stdlib\")) // Serializaci\u00f3n JSON implementation(\"org.jetbrains.kotlinx:kotlinx-serialization-json:1.6.3\") // OpenCSV para CSV implementation(\"com.opencsv:opencsv:5.9\") //Kotlin-CSV implementation(\"com.github.doyaaaaaken:kotlin-csv-jvm:1.9.1\") // librer\u00eda JDOM2 implementation(\"org.jdom:jdom2:2.0.6\") // librerias jackson implementation(\"com.fasterxml.jackson.module:jackson-module-kotlin:2.17.0\") implementation(\"com.fasterxml.jackson.dataformat:jackson-dataformat-xml:2.17.0\") }","title":"\ud83d\udd39Dependencias Gradle"},{"location":"T3_Formatos_diferentes/ficheros_intercambio/#ficheros-csv","text":"El formato CSV es un archivo de texto donde los valores est\u00e1n separados por comas u otro delimitador (como punto y coma), muy usado para intercambiar datos entre hojas de c\u00e1lculo, sistemas contables, etc. La lectura y escrituara de un archivo CSV se puede hacer de tres formas: Sin utilizar librer\u00edas y mediante la lectura l\u00ednea a l\u00ednea + split(). Con la librer\u00eda OpenCSV . Con la librer\u00eda Kotlin-CSV . En este bloque de contenidos vamos a trabajar con distintos programas de ejemplo y en todos estos casos, los datos representan siempre el mismo tipo de informaci\u00f3n: alumnos. Alumnos.csv nombre:nota Luc\u00eda;9 Carlos;8 Elena;10 La data class Alumno correspondiente ser\u00e1: data class Alumno( val nombre: String, val nota: Int ) \ud83d\udccc Esta clase la crearemos fuera fuera de los programas de ejemplo para poder reutilizarla desde cualquier otro main. \ud83d\udda5\ufe0f 1- Sin librer\u00edas: lectura l\u00ednea a l\u00ednea + split() Ejemplo_CSV_lect_esc.kt import java.nio.file.Files import java.nio.file.Paths import java.nio.file.StandardOpenOption fun main() { val ruta = Paths.get(\"documentos/alumnos.csv\") // 1. Crear contenido CSV (con cabecera) val lineas = listOf( \"nombre;nota\", // cabecera \"Luc\u00eda;9\", \"Carlos;8\", \"Elena;10\" ) // 2. Escribir el archivo Files.write( ruta, lineas, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING ) println(\"Archivo CSV creado: ${ruta.toAbsolutePath()}\") // 3. Leer el archivo y convertir a objetos Alumno val lineasLeidas = Files.readAllLines(ruta) val alumnos = mutableListOf<Alumno>() for (i in lineasLeidas.indices) { // Saltamos la cabecera (l\u00ednea 0) if (i == 0) continue val linea = lineasLeidas[i] val partes = linea.split(\";\") if (partes.size == 2) { val nombre = partes[0] val nota = partes[1].toInt() val alumno = Alumno(nombre, nota) alumnos.add(alumno) } else { println(\"L\u00ednea mal formada: $linea\") } } // 4. Usar los objetos println(\"\\nListado de alumnos:\") for (alumno in alumnos) { println(\"Alumno: ${alumno.nombre}, Nota: ${alumno.nota}\") } } \ud83d\udda5\ufe0f 2- Con OpenCSV Nota OpenCSV fue desarrollado antes de que java.nio.file.Path se introdujera en Java 7, y sus m\u00e9todos a\u00fan usan la API antigua (java.io.*) , como FileReader y FileWriter. Lectura con OpenCSV Clase / M\u00e9todo \u00bfQu\u00e9 hace? Ejemplo b\u00e1sico CSVReader(FileReader) Crea un lector de archivos CSV. val reader = CSVReader(FileReader(\"archivo.csv\")) readAll() Lee todo el contenido como List<Array<String>> . val filas = reader.readAll() readNext() Lee una fila como Array<String> . val fila = reader.readNext() close() Cierra el lector. reader.close() CSVReaderBuilder(...) Permite configurar el lector: separador, comillas, salto de l\u00ednea, etc. CSVReaderBuilder(FileReader(...)).withSeparator(';') withSkipLines(n) Omite las primeras n l\u00edneas (\u00fatil para saltar cabeceras). withSkipLines(1) build() Construye el lector configurado. build() Escritura con OpenCSV Clase / M\u00e9todo \u00bfQu\u00e9 hace? Ejemplo b\u00e1sico CSVWriter(FileWriter) Crea un escritor CSV b\u00e1sico. val writer = CSVWriter(FileWriter(\"archivo.csv\")) writeNext(Array<String>) Escribe una l\u00ednea al CSV. writer.writeNext(arrayOf(\"Ana\", \"30\")) writeAll(List<Array<String>>) Escribe m\u00faltiples filas al CSV. writer.writeAll(listaFilas) flush() Fuerza la escritura del buffer. writer.flush() close() Cierra el escritor. writer.close() CSVWriterBuilder(...) Permite configurar el escritor: delimitador, comillas, escape, etc. CSVWriterBuilder(FileWriter(...)).withSeparator(';') withQuoteChar(c) Define el car\u00e1cter de comillas (por defecto es \" ). withQuoteChar(CSVWriter.NO_QUOTE_CHARACTER) withEscapeChar(c) Define el car\u00e1cter de escape (por defecto \\ ). withEscapeChar('\\\\') withLineEnd(e) Define el car\u00e1cter de fin de l\u00ednea. withLineEnd(\"\\n\") build() Construye el escritor configurado. build() CSVReader y CSVWriter son clases Java, pensadas originalmente para Java, aunque se pueden usar desde Kotlin. Ejempo_OpenCSV_lect_esc.kt import com.opencsv.CSVReader import com.opencsv.CSVWriter import java.io.FileReader import java.io.FileWriter import java.nio.file.Paths fun main() { val ruta = Paths.get(\"documentos/alumnos.csv\").toString() // 1. Escribir el archivo CSV (con cabecera) CSVWriter(FileWriter(ruta)).use { writer -> writer.writeNext(arrayOf(\"nombre\", \"nota\")) //cabecera writer.writeNext(arrayOf(\"Luc\u00eda\", \"9\")) writer.writeNext(arrayOf(\"Carlos\", \"8\")) writer.writeNext(arrayOf(\"Elena\", \"10\")) } println(\"Archivo CSV creado: $ruta\") // 2. Leer el archivo CSV y convertir a objetos Alumno val alumnos = mutableListOf<Alumno>() CSVReader(FileReader(ruta)).use { reader -> val filas = reader.readAll() for (i in filas.indices) { // Saltamos la cabecera if (i == 0) continue val fila = filas[i] if (fila.size == 2) { val nombre = fila[0] val nota = fila[1].toInt() alumnos.add(Alumno(nombre, nota)) } else { println(\"L\u00ednea mal formada: ${fila.joinToString(\";\")}\") } } } // 3. Usar los objetos println(\"\\nListado de alumnos:\") for (alumno in alumnos) { println(\"Alumno: ${alumno.nombre}, Nota: ${alumno.nota}\") } } Nota El archivo CSV generado sin librer\u00edas es un archivo de texto plano con el separador ; , pero sin comillas y sin escape. En cambio, el fichero CSV generado con OpenCSV sigue el estantar CSV (RFC 4180) que incluye encerrar los campos entre comillas dobles, si el campo contiene el separador (como ; o , ). \ud83d\udda5\ufe0f 3- Con Kotlin-CSV Nota la librer\u00eda kotlin-csv tambi\u00e9n utiliza java.io.File para muchas de sus operaciones principales, aunque de una forma un poco m\u00e1s moderna y flexible que OpenCSV . Tradicionalmente, en entornos Java se ha utilizado la librer\u00eda OpenCSV para leer y escribir este tipo de archivos, debido a su potencia y versatilidad, sin embargo, cuando desarrollamos en Kotlin, existen alternativas m\u00e1s modernas y adaptadas al lenguaje. Una de ellas es kotlin-csv, una librer\u00eda ligera y expresiva dise\u00f1ada espec\u00edficamente para aprovechar las ventajas de Kotlin, como las expresiones lambda, la sintaxis DSL y el trabajo con secuencias (sequences) y corrutinas. csvWriter y csvReader no son clases, sino funciones DSL propias de Kotlin Tipo M\u00e9todo Ejemplo m\u00ednimo Lectura readAll(File) val filas = csvReader().readAll(File(\"alumnos.csv\")) readAllWithHeader(File) val datos = csvReader().readAllWithHeader(File(\"alumnos.csv\")) open { readAllAsSequence() } csvReader().open(\"alumnos.csv\") { readAllAsSequence().forEach { println(it) } } Escritura writeAll(data, File) csvWriter().writeAll(listOf(listOf(\"Luc\u00eda\", \"9\")), File(\"salida.csv\")) writeRow(row, File) csvWriter().writeRow(listOf(\"Carlos\", \"8\"), File(\"salida.csv\")) writeAllWithHeader(data, File) csvWriter().writeAllWithHeader(listOf(mapOf(\"nombre\" to \"Elena\", \"nota\" to \"10\")), File(\"salida.csv\")) Configuraci\u00f3n delimiter , quoteChar , etc. csvReader { delimiter = ';' } Ejempo_KotlinCSV_lect_esc.kt import com.github.doyaaaaaken.kotlincsv.dsl.csvReader import com.github.doyaaaaaken.kotlincsv.dsl.csvWriter import java.io.File import java.nio.file.Paths fun main() { val ruta = Paths.get(\"documentos/alumnos.csv\").toString() // Escribir con cabecera csvWriter().open(ruta) { writeRow(listOf(\"nombre\", \"nota\")) //cabecera writeRow(listOf(\"Luc\u00eda\", \"9\")) writeRow(listOf(\"Carlos\", \"8\")) writeRow(listOf(\"Elena\", \"10\")) } // Leer con cabecera (como Map) val filas: List<Map<String, String>> = csvReader().readAllWithHeader(File(ruta)) val alumnos = filas.mapNotNull { fila -> val nombre = fila[\"nombre\"] val notaStr = fila[\"nota\"] if (nombre != null && notaStr != null) Alumno(nombre, notaStr.toInt()) else null } println(\"Listado de alumnos:\") alumnos.forEach { println(\"Alumno: ${it.nombre}, Nota: ${it.nota}\") } }","title":"\ud83d\udd39Ficheros CSV"},{"location":"T3_Formatos_diferentes/ficheros_intercambio/#ficheros-json","text":"En muchas aplicaciones modernas, los datos deben almacenarse o intercambiarse en formato JSON (JavaScript Object Notation), un formato ligero y legible ampliamente utilizado en APIs, configuraciones, bases de datos NoSQL y almacenamiento persistente. Estructura La estructura de los ficheros JSON (JavaScript Object Notation) se basa en una sintaxis sencilla y legible para representar datos estructurados. JSON est\u00e1 formado por pares clave-valor y/o listas ordenadas de valores. Ejemplo : Informaci\u00f3n sobre un alumno. \"alumno\": { \"nombre\": \"Mar\u00eda\", \"edad\": 20, \"activo\": true, \"notas\": [8.5, 9.2, 7.8], \"direccion\": { \"calle\": \"Av. del Sol\", \"ciudad\": \"Valencia\", \"codigoPostal\": 46001} } Elementos principales Objeto: Conjunto de pares clave-valor, delimitado por {}: \"alumno\" Array: Lista ordenada de valores, delimitada por []: \"notas\" Clave: Siempre entre comillas dobles: \"nombre\" Valor: Puede ser: string, n\u00famero, booleano, null, objeto o array: \"Mar\u00eda\", \"Valencia\", 20, true, etc. Librer\u00edas En Kotlin , existen varias librer\u00edas que permiten trabajar con ficheros JSON de forma sencilla: Librer\u00eda Lenguaje base Uso recomendado Multiplataforma Notas destacadas kotlinx.serialization Kotlin Kotlin puro y Kotlin Multiplatform \u2705 S\u00ed Ligera, r\u00e1pida y con soporte oficial de JetBrains Jackson Java Proyectos Java/Kotlin con Spring Boot \u274c No Muy flexible y poderosa Gson Java Aplicaciones Android o proyectos simples \u274c No F\u00e1cil de usar, pero m\u00e1s lenta y menos segura org.json Java Scripts r\u00e1pidos o aprendizaje \u274c No Acceso directo a claves sin clases de datos Cuando trabajamos con ficheros JSON en Kotlin , existen dos formas de acceder a los datos, tratarlos como texto plano o estructuras gen\u00e9ricas, o convertirlos directamente en objetos Kotlin. Aunque la primera opci\u00f3n es posible y \u00fatil en ciertos casos, trabajar sin conversi\u00f3n implica mayor esfuerzo manual, riesgo de errores en los nombres de claves y ausencia de validaci\u00f3n de tipos. Las librer\u00edas kotlinx.serialization y Jackson nos permiten convertir los ficheros JSON a objetos y viceversa. Esto proporciona importantes ventajas : \u2714\ufe0f Validaci\u00f3n autom\u00e1tica de la estructura del JSON. \u2714\ufe0f Conversi\u00f3n directa entre JSON y objetos Kotlin. \u2714\ufe0f C\u00f3digo m\u00e1s limpio y mantenible. \u2714\ufe0f Mayor seguridad de tipos, detectando errores en tiempo de compilaci\u00f3n.","title":"\ud83d\udd39Ficheros JSON"},{"location":"T3_Formatos_diferentes/ficheros_intercambio/#kotlinxserialization","text":"kotlinx.serialization es la librer\u00eda oficial de serializaci\u00f3n de Kotlin, desarrollada por JetBrains, que permite convertir objetos Kotlin a y desde diferentes formatos como JSON, ProtoBuf, CBOR, XML (experimental), entre otros. Como ya vimos en el apartado anterior, la serializaci\u00f3n es el proceso de convertir los datos utilizados por una aplicaci\u00f3n a un formato que pueda transferirse por red o almacenarse en una base de datos o archivo. A su vez, la deserializaci\u00f3n es el proceso inverso: leer datos de una fuente externa y convertirlos en un objeto de tiempo de ejecuci\u00f3n. Nota Todas las bibliotecas de serializaci\u00f3n de Kotlin pertenecen al grupo org.jetbrains.kotlinx:grupo . Sus nombres empiezan con kotlinx-serialization- y tienen sufijos que reflejan el formato de serializaci\u00f3n: org.jetbrains.kotlinx:kotlinx-serialization-json Clases y funciones clave de kotlinx.serialization.json Clase / Funci\u00f3n Tipo Descripci\u00f3n Json Clase Punto de entrada principal para serializar y deserializar en JSON JsonObject Clase Representa un objeto JSON {} como un Map<String, JsonElement> JsonArray Clase Representa un array JSON [] , como una lista de JsonElement JsonElement Clase Superclase abstracta para cualquier valor JSON JsonPrimitive Clase Representa valores primitivos JSON (string, n\u00famero, booleano, null) JsonNull Objeto Representa el valor null en JSON JsonLiteral Clase Subtipo de JsonPrimitive que representa valores literales (string/num) JsonObjectBuilder Clase DSL Permite construir objetos JSON usando buildJsonObject { ... } JsonArrayBuilder Clase DSL Permite construir arrays JSON usando buildJsonArray { ... } buildJsonObject { ... } Funci\u00f3n Crea un JsonObject de forma declarativa buildJsonArray { ... } Funci\u00f3n Crea un JsonArray de forma declarativa parseToJsonElement(...) Funci\u00f3n Convierte un String en JsonElement (analiza el JSON sin clase) encodeToJsonElement(...) Funci\u00f3n Convierte un objeto Kotlin en JsonElement usando un Json decodeFromJsonElement(...) Funci\u00f3n Convierte un JsonElement a un objeto Kotlin jsonPrimitive Propiedad Accede al valor primitivo dentro de un JsonElement jsonObject Propiedad Convierte un JsonElement a JsonObject (si es compatible) jsonArray Propiedad Convierte un JsonElement a JsonArray (si es compatible) M\u00e9todos principales de kotlinx.serialization Son funciones generales que no est\u00e1n dentro del paquete .json, pero que se usan muy a menudo en la serializaci\u00f3n en Kotlin. M\u00e9todo de kotlinx.serialization \u00bfQu\u00e9 hace? Ejemplo b\u00e1sico Json.encodeToString(objeto) Convierte un objeto Kotlin a una cadena JSON. Json.encodeToString(persona) Json.encodeToString(serializer, obj) Igual que el anterior pero especificando el serializador. Json.encodeToString(Persona.serializer(), persona) Json.decodeFromString(json) Convierte una cadena JSON a un objeto Kotlin. Json.decodeFromString<Persona>(json) Json.decodeFromString(serializer, s) Igual que el anterior pero con el serializador expl\u00edcito. Json.decodeFromString(Persona.serializer(), json) Json.encodeToJsonElement(objeto) Convierte un objeto a un \u00e1rbol JsonElement . val elem = Json.encodeToJsonElement(persona) Json.decodeFromJsonElement(elem) Convierte un JsonElement a objeto Kotlin. val persona = Json.decodeFromJsonElement<Persona>(elem) Json.parseToJsonElement(string) Parsea una cadena JSON a un \u00e1rbol JsonElement sin mapear. val elem = Json.parseToJsonElement(json) Requisitos para usar kotlinx.serialization en Gradle (JSON) Activar el plugin de Kotlin serialization en build.gradle.kts plugins { kotlin(\"jvm\") version \"2.0.20\" kotlin(\"plugin.serialization\") version \"2.0.20\" application } dependencies { implementation(\"org.jetbrains.kotlinx:kotlinx-serialization-json:1.6.3\") } \u26a0\ufe0f Aseg\u00farate de usar una versi\u00f3n compatible con tu Kotlin. Por ejemplo, 1.6.3 funciona bien con Kotlin 2.0.20. Anota tus clases con @Serializable import kotlinx.serialization.Serializable @Serializable data class Objeto(val clave1: String, val clave2: Int) Nota En Kotlin, las data class est\u00e1n dise\u00f1adas para modelar datos puros. La palabra clave data no es obligatoria para la serializaci\u00f3n, pero se usa por buena pr\u00e1ctica y para obtener funcionalidades adicionales que son muy \u00fatiles, especialmente cuando trabajas con objetos de datos, como toString(), equals(), hashCode(), copy().. Utiliza el objeto Json para serializar/deserializar Para serializar una instancia de esta clase llamamos a Json.encodeToString() y para deserializar llamamos a Json.decodeFromString() . import kotlinx.serialization.json.Json import kotlinx.serialization.encodeToString import kotlinx.serialization.decodeFromString fun main() { val obj = Objeto(\"Mar\u00eda\", 22) val json = Json.encodeToString(obj) println(\"JSON: $json\") val obj = Json.decodeFromString<Objeto>(json) println(\"Objeto: $obj\") } Tambi\u00e9n puedes serializar colecciones de objetos , como listas, en una sola llamada: val dataList = listOf(Objeto(\"Mar\u00eda\", 22), Objeto(\"Carlos\", 30), Objeto(\"Ana\", 18)) val jsonList = Json.encodeToString(dataList) El resultado ser\u00eda: [ {\"nombre\":\"Luc\u00eda\",\"edad\":28}, {\"nombre\":\"Carlos\",\"edad\":30}, {\"nombre\":\"Elena\",\"edad\":18} ] Ejemplo de lectura y escritura de un archivo json Estructura del proyecto: Ficheros_Gradle/ \u251c\u2500\u2500 documentos/ | \u2514\u2500\u2500persona.json \u2514\u2500\u2500 src/ \u2514\u2500\u2500 main/ \u2514\u2500\u2500 kotlin/ \u2514\u2500\u2500 Ejemplos/ \u2514\u2500\u2500Ejemplo_JSON_KSerialization.kt \u2514\u2500\u2500Persona.kt 1- El fichero json que vamos a generar ser\u00e1 el que tenga el siguiente contenido. Es un objeto JSON que contiene dos atributos, nombre y edad, representando una persona.: { \"nombre\": \"Luc\u00eda\", \"edad\": 28 } 2- Crea la Data Class Persona.kt con la misma estructura del archivo fuera del programa de ejemplo para poder reutilizarla desde cualquier otro main. Anota la clase como serializable . import kotlinx.serialization.Serializable @Serializable data class Persona(val nombre: String, val edad: Int) \ud83d\udda5\ufe0f Ejemplo_JSON_KSerialization.kt import kotlinx.serialization.encodeToString import kotlinx.serialization.json.* import java.nio.file.Files import java.nio.file.Paths import java.io.IOException import java.nio.file.Files.readString fun escribirJSON() { val ruta = Paths.get(\"documentos/persona.json\") val persona = Persona(\"Luc\u00eda\", 28) try { // Convertir a String con formato bonito val jsonString = Json { prettyPrint = true }.encodeToString(persona) // Crear carpeta si no existe Files.createDirectories(ruta.parent) // Escribir JSON en archivo Files.writeString(ruta, jsonString) println(\"Archivo JSON creado en: ${ruta.toAbsolutePath()}\") println(\"Contenido:\\n$jsonString\") } catch (e: IOException) { println(\"\u26a0\ufe0f Error de entrada/salida: ${e.message}\") } catch (e: Exception) { println(\"\u26a0\ufe0f Error inesperado: ${e.message}\") } } fun leerJSON(){ val rutaEntrada = Paths.get(\"documentos/persona.json\") // --- Lectura segura --- try { if (!Files.exists(rutaEntrada)) { println(\"El archivo no existe: $rutaEntrada\") return } val contenidoJson = readString(rutaEntrada) val persona = Json.decodeFromString<Persona>(contenidoJson) println(\"Lectura correcta: $persona\") } catch (e: IOException) { println(\"Error de E/S: ${e.message}\") } } fun main() { escribirJSON() leerJSON() }","title":"\ud83d\udd39 kotlinx.serialization"},{"location":"T3_Formatos_diferentes/ficheros_intercambio/#jackson-json","text":"Jackson es la librer\u00eda m\u00e1s usada en Java para JSON. Muchos frameworks Java lo usan por defecto (Spring Boot, Micronaut, Quarkus, etc.). Conocerlo permite trabajar con APIs externas, backends y entornos mixtos (Java + Kotlin). Mientras que kotlinx.serialization est\u00e1 centrado en JSON y formatos binarios (CBOR, ProtoBuf...), Jackson tambi\u00e9n soporta XML, YAML, CSV de forma unificada, adem\u00e1s, si necesitas convertir entre formatos (XML \u2194 JSON), Jackson es ideal, por lo que es importante cononcer ambas librer\u00edas para entender los proyectos Kotlin puros y modernos (kotlinx.serialization) y tambi\u00e9n los proyectos reales empresariales con Jackson. Clases esenciales para trabajar con JSON usando Jackson Clase / interfaz Para qu\u00e9 sirve ObjectMapper La clase principal para leer y escribir JSON File (de java.io) Representa el archivo f\u00edsico JSON Tu data class en Kotlin Define la estructura del objeto a leer o escribir M\u00e9todo Jackson \u00bfQu\u00e9 hace? Ejemplo b\u00e1sico readValue(String, Class) Convierte una cadena JSON a un objeto Kotlin o Java. mapper.readValue(json, Persona::class.java) readValue(File, Class) Convierte un archivo JSON a un objeto. mapper.readValue(File(\"persona.json\"), Persona::class.java) readTree(String) Lee un JSON como \u00e1rbol ( JsonNode ) sin mapear a clase. val node = mapper.readTree(json) writeValue(File, Object) Escribe un objeto como JSON en un archivo. mapper.writeValue(File(\"salida.json\"), persona) writeValueAsString(Object) Convierte un objeto en una cadena JSON. val json = mapper.writeValueAsString(persona) writeValueAsBytes(Object) Convierte un objeto en un array de bytes JSON. val bytes = mapper.writeValueAsBytes(persona) writerWithDefaultPrettyPrinter() Devuelve un escritor que formatea (indentado) el JSON. mapper.writerWithDefaultPrettyPrinter().writeValue(...) Anotaciones en Jackson Las anotaciones en Jackson (como @JsonIgnoreProperties, @JsonProperty, etc.) no siempre son necesarias, pero se usan para resolver problemas comunes al serializar o deserializar objetos. Caso \u00bfAnotaci\u00f3n necesaria? JSON coincide exactamente con la data class \u274c No JSON tiene campos extra \u2705 S\u00ed (@JsonIgnoreProperties) Nombres distintos en JSON \u2705 S\u00ed (@JsonProperty) Quieres ocultar campos \u2705 S\u00ed (@JsonIgnore) Anotaci\u00f3n \u00bfPara qu\u00e9 sirve? @JsonProperty(\"x\") Mapear nombres distintos entre JSON y la clase @JsonIgnore Excluir una propiedad al serializar/deserializar @JsonIgnoreProperties(ignoreUnknown = true) Evitar errores por campos JSON no mapeados @JsonInclude(...) Excluir valores nulos o vac\u00edos en el JSON Ejemplo de lectura y escritura con Jackson Dependencia Gradle: dependencies { implementation(\"com.fasterxml.jackson.module:jackson-module-kotlin:2.17.0\") } Nota \u26a0\ufe0f Con la librer\u00eda Jackson no es obligatorio usar la anotaci\u00f3n @Serializable . Jackson puede trabajar directamente con clases normales de Kotlin. En este caso, seguiremos utilizando la data class Persona , que ya est\u00e1 anotada con @Serializable porque se usa tambi\u00e9n en ejemplos con kotlinx.serialization . \ud83d\udc49 Esta anotaci\u00f3n no afecta a Jackson ni provoca errores, por lo que la misma clase se puede reutilizar sin problemas en ambos casos. import kotlinx.serialization.Serializable @Serializable data class Persona(val nombre: String, val edad: Int) \ud83d\udda5\ufe0f Ejemplo_JSON_jackson.kt import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper import com.fasterxml.jackson.module.kotlin.readValue import java.io.File fun escribirJson() { val mapper = jacksonObjectMapper() val persona = Persona(\"Mario\", 35) val archivo = File(\"documentos/persona.json\") mapper.writerWithDefaultPrettyPrinter().writeValue(archivo, persona) println(\"JSON generado correctamente en: ${archivo.absolutePath}\") } fun leerJson() { val mapper = jacksonObjectMapper() val archivo = File(\"documentos/persona.json\") val persona = mapper.readValue<Persona>(archivo) println(\"Lectura correcta: ${persona.nombre} tiene ${persona.edad} a\u00f1os.\") } fun main() { escribirJson() leerJson() } Ejemplo de lectura y escritura de un array (lista) de elementos con Jackson Fichero JSON compuesto por una lista de elementos Si el fichero JSON contiene un array ( [...] ), es decir, una lista de objetos , entonces debemos indicar expl\u00edcitamente que queremos leer un List<Objeto> . [ { \"nombre\" : \"Luc\u00eda\", \"edad\" : 28 }, { \"nombre\" : \"Pepe\", \"edad\" : 30 }, { \"nombre\" : \"Ana\", \"edad\" : 50 }, { \"nombre\" : \"Juan\", \"edad\" : 12 } ] \ud83d\udda5\ufe0f Ejemplo_listaJSON_jackson.kt import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper import com.fasterxml.jackson.module.kotlin.readValue import java.io.File fun escribirListaJson() { val mapper = jacksonObjectMapper() val personas = listOf( Persona(\"Luc\u00eda\", 28), Persona(\"Pepe\", 30), Persona(\"Ana\", 50), Persona(\"Juan\", 12) ) val archivo = File(\"documentos/lista_personas.json\") mapper.writerWithDefaultPrettyPrinter().writeValue(archivo, personas) println(\"JSON generado correctamente en: ${archivo.absolutePath}\") } fun leerListaJson() { val mapper = jacksonObjectMapper() val archivo = File(\"documentos/lista_personas.json\") val lista=mapper.readValue<List<Persona>>(archivo) for (p in lista) { println(\"${p.nombre} tiene ${p.edad} a\u00f1os.\") } } fun main() { escribirListaJson() leerListaJson() }","title":"\ud83d\udd39Jackson (JSON)"},{"location":"T3_Formatos_diferentes/ficheros_intercambio/#ficheros-xml","text":"Un fichero XML (eXtensible Markup Language) es un formato de texto estructurado dise\u00f1ado para almacenar y transportar datos de forma legible tanto para humanos como para m\u00e1quinas. Tiene una estructura jer\u00e1rquica basada en etiquetas, similar al HTML, pero orientada al contenido de datos, no a la presentaci\u00f3n. XML permite guardar objetos o estructuras de datos en un archivo de texto legible. Estructura <raiz> <!-- Elemento ra\u00edz obligatorio --> <elemento> <subelemento>valor</subelemento> </elemento> <otroElemento atributo=\"valor\" /> </raiz> La mejor forma de trabajar con XML en Kotlin es utlizar la librer\u00eda DOM (Document Object Model) o JDOM2 , que permiten crear, leer y modificar f\u00e1cilmente estructuras XML. DOM -> Est\u00e1ndar Java, sin dependencias. Requiere muchas l\u00edneas de c\u00f3digo para hacer algo relativamente simple. JDOM2 -> API m\u00e1s amigable para desarrolladores. Requiere a\u00f1adir una librer\u00eda externa.","title":"\ud83d\udd39Ficheros XML"},{"location":"T3_Formatos_diferentes/ficheros_intercambio/#jdom2","text":"JDOM2 es una librer\u00eda ligera y f\u00e1cil de usar para trabajar con XML de forma manual y controlada, ideal cuando no necesitas solo convertir directamente a objetos, sino manipular el contenido de manera estructurada. Clase \u00bfPara qu\u00e9 sirve? SAXBuilder Analiza (parsea) un archivo XML y devuelve un Document. Document Representa todo el documento XML. Element Representa una etiqueta (nodo) del XML. Attribute Representa un atributo dentro de una etiqueta. XMLOutputter Convierte el \u00e1rbol de elementos en texto XML. M\u00e9todos comunes de JDOM2 para manipular XML M\u00e9todo Clase Descripci\u00f3n Element(String name) Element Crea un nuevo elemento XML con el nombre especificado addContent(Element child) Element A\u00f1ade un elemento hijo al elemento actual addContent(String text) Element A\u00f1ade texto al contenido del elemento setText(String text) Element Establece el texto del elemento getText() Element Obtiene el texto del elemento getChild(String name) Element Obtiene el primer hijo con ese nombre getChildren(String name) Element Obtiene todos los hijos con ese nombre getChildren() Element Obtiene todos los hijos del elemento setAttribute(String, String) Element Establece un atributo del elemento getAttributeValue(String) Element Obtiene el valor de un atributo Document(Element root) Document Crea un documento XML con el elemento ra\u00edz dado getRootElement() Document Obtiene el elemento ra\u00edz del documento SAXBuilder().build(File) SAXBuilder Carga un documento XML desde un archivo XMLOutputter().output(Document, OutputStream) XMLOutputter Escribe el documento XML en una salida (archivo, consola, etc.) setFormat(Format.prettyFormat()) XMLOutputter Establece un formato bonito con sangr\u00edas JDOM2 no realiza serializaci\u00f3n autom\u00e1tica de objetos Kotlin, se necesita mapear manualmente entre objetos (data class) y elementos XML. A continuaci\u00f3n lo veremos con un ejemplo: Ejemplo de lectura y escritura de un archivo xml con JDOM2 : Vamos a generar el siguiente archivo XML utilizando dos ejemplos, uno se encargar\u00e1 de crear el documento XML, y otro de leer su contenido desde el fichero generado. <?xml version=\"1.0\" encoding=\"UTF-8\"?> <alumnos> <alumno> <nombre>Luc\u00eda</nombre> <nota>8</nota> </alumno> <alumno> <nombre>Carlos</nombre> <nota>6</nota> </alumno> <alumno> <nombre>Elena</nombre> <nota>10</nota> </alumno> </alumnos> Dependencias en build.gradle.kts dependencies { implementation(\"org.jdom:jdom2:2.0.6\") } Reutilizamos la clase Alumno creada en los ejemplos anteriores: data class Alumno(val nombre: String, val nota: Int) \ud83d\udda5\ufe0f Ejemplo_Objeto_a_XML.kt : Leemos el objeto Alumno y lo convertimos en fichero xml (alumnos.xml). import org.jdom2.Document import org.jdom2.Element import org.jdom2.output.Format import org.jdom2.output.XMLOutputter import java.io.File fun main() { // Lista de alumnos val alumnos = listOf( Alumno(\"Luc\u00eda\", 8), Alumno(\"Carlos\", 6), Alumno(\"Elena\", 10) ) // Crear elemento ra\u00edz <alumnos> val raiz = Element(\"alumnos\") // A\u00f1adir cada alumno como <alumno> for (alumno in alumnos) { val alumnoElement = Element(\"alumno\") alumnoElement.addContent(Element(\"nombre\").setText(alumno.nombre)) alumnoElement.addContent(Element(\"nota\").setText(alumno.nota.toString())) raiz.addContent(alumnoElement) } // Crear el documento XML val documento = Document(raiz) // Escribir en archivo con formato bonito val salida = XMLOutputter() salida.format = Format.getPrettyFormat() salida.output(documento, File(\"documentos/alumnos.xml\").outputStream()) println(\"Archivo XML creado con \u00e9xito.\") } \ud83d\udda5\ufe0f Ejemplo_XML_a_Objeto.kt : Leemos el archivo alumnos.xml y lo convertimos a objeto. import org.jdom2.input.SAXBuilder import java.io.File fun main() { //Crea una lista mutable de tipo Alumno. val alumnos = mutableListOf<Alumno>() val archivo = File(\"documentos/alumnos.xml\") val builder = SAXBuilder() val documento = builder.build(archivo) val raiz = documento.rootElement val listaAlumnos = raiz.getChildren(\"alumno\") //Por cada nodo <alumno> del XML, crea un objeto Alumno con sus atributos. for (elemento in listaAlumnos) { val nombre = elemento.getChildText(\"nombre\") val nota = elemento.getChildText(\"nota\").toIntOrNull() ?: 0 alumnos.add(Alumno(nombre, nota)) } // Mostrar los objetos alumnos.forEach { println(it) } }","title":"\ud83d\udd39JDOM2"},{"location":"T3_Formatos_diferentes/ficheros_intercambio/#jackson-xml","text":"JDOM2 no realiza serializaci\u00f3n autom\u00e1tica de objetos Kotlin, pero se puede recurrir a librer\u00edas como Jackson o kotlinx.serialization . A diferencia de la librer\u00eda kotlinx.serialization-josn , para ficheros JSON , que es es la librer\u00eda oficial de serializaci\u00f3n de Kotlin, la librer\u00eda kotlinx.serialization-xml , para ficheros XML , no es oficial (a\u00fan experimental) y est\u00e1 mantenidad por terceros, por lo que no es una buena elecci\u00f3n. Utilizaremos, por tanto, la librer\u00eda Jackson para realizar la serializaci\u00f3n autom\u00e1tica de objetos Kotlin, la cual tambi\u00e9n permite soporte completo para XML y JSON, es decier, puede serializar y deserializar ambos formatos usando las mismas clases. M\u00e9todos comunes de Jackson para XML (XmlMapper) M\u00e9todo Clase Descripci\u00f3n readValue(File, Class<T>) XmlMapper Lee un archivo XML y lo convierte en un objeto Kotlin/Java readValue(String, Class<T>) XmlMapper Lee un String XML y lo convierte en un objeto writeValue(File, Object) XmlMapper Escribe un objeto como XML en un archivo writeValueAsString(Object) XmlMapper Convierte un objeto en una cadena XML writeValueAsBytes(Object) XmlMapper Convierte un objeto en un array de bytes XML registerModule(Module) ObjectMapper / XmlMapper Registra un m\u00f3dulo como KotlinModule o JavaTimeModule enable(SerializationFeature) XmlMapper Activa una opci\u00f3n de serializaci\u00f3n (por ejemplo, indentado) disable(DeserializationFeature) XmlMapper Desactiva una opci\u00f3n de deserializaci\u00f3n configure(MapperFeature, boolean) XmlMapper Configura opciones generales del mapeo setDefaultPrettyPrinter(...) XmlMapper Establece un formateador personalizado Ejemplo de lectura y escritura del fichero alumnos.xml con Jackson XML Dependencias en build.gradle.kts : dependencies { implementation(\"com.fasterxml.jackson.module:jackson-module-kotlin:2.17.0\") implementation(\"com.fasterxml.jackson.dataformat:jackson-dataformat-xml:2.17.0\") } Siguiendo con el ejemplo alumnos.xml : <?xml version=\"1.0\" encoding=\"UTF-8\"?> <alumnos> <alumno> <nombre>Luc\u00eda</nombre> <nota>8</nota> </alumno> <alumno> <nombre>Carlos</nombre> <nota>6</nota> </alumno> <alumno> <nombre>Elena</nombre> <nota>10</nota> </alumno> </alumnos>","title":"\ud83d\udd39Jackson (XML)"},{"location":"T3_Formatos_diferentes/ficheros_intercambio/#clase-contenedora","text":"En XML siempre hay un \u00fanico elemento ra\u00edz. Jackson necesita una clase que represente ese nodo ra\u00edz. En nuestro ejemplo ese elemento ra\u00edz es: <alumnos> Creamos la clase contenedora ListaAlumnos , que act\u00faa como puente entre el XML y Kotlin. Esta clase da nombre al nodo raiz <alumnos> y explica como mapear los elementos repetidos <alumno> . data class ListaAlumnos( @JacksonXmlElementWrapper(useWrapping = false) // No a\u00f1ade un <alumnoList>, usa directamente <alumno> @JacksonXmlProperty(localName = \"alumno\") // Cada elemento se llama <alumno> val alumno: List<Alumno> = emptyList() ) \ud83d\udda5\ufe0f Ejemplo_XML_Jackson.kt import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlElementWrapper import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty import com.fasterxml.jackson.dataformat.xml.XmlMapper import com.fasterxml.jackson.module.kotlin.KotlinModule import com.fasterxml.jackson.module.kotlin.readValue import com.fasterxml.jackson.module.kotlin.registerKotlinModule import java.io.File fun escribirXml() { val xmlMapper = XmlMapper().registerModule(KotlinModule.Builder().build()) val lista = ListaAlumnos( listOf( Alumno(\"Luc\u00eda\", 8), Alumno(\"Carlos\", 6), Alumno(\"Mar\u00eda\", 10) ) ) val archivo = File(\"documentos/alumnos.xml\") xmlMapper.writerWithDefaultPrettyPrinter().writeValue(archivo, lista) println(\"XML escrito correctamente en: ${archivo.absolutePath}\") } fun leerXml() { val xmlMapper = XmlMapper().registerKotlinModule() val archivo = File(\"documentos/alumnos.xml\") //val lista = xmlMapper.readValue(archivo, ListaAlumnos::class.java) val lista=xmlMapper.readValue<ListaAlumnos>(archivo) println(\"Lectura correcta:\") lista.alumno.forEach { println(\"${it.nombre} tiene un ${it.nota}\") } } fun main() { escribirXml() leerXml() }","title":"Clase Contenedora"},{"location":"T3_Formatos_diferentes/intro/","text":"Introducci\u00f3n En el desarrollo de software, especialmente en aplicaciones que gestionan informaci\u00f3n o se comunican entre sistemas, es fundamental contar con formatos est\u00e1ndar para el intercambio de datos. Entre los m\u00e1s utilizados destacan JSON (JavaScript Object Notation), XML (eXtensible Markup Language) y CSV (Comma-Separated Values). Estos formatos permiten que los datos puedan ser almacenados, transmitidos y compartidos entre diferentes aplicaciones, plataformas o lenguajes de programaci\u00f3n de forma estructurada y comprensible. Su uso se ha convertido en una pr\u00e1ctica habitual en \u00e1mbitos como: La comunicaci\u00f3n entre aplicaciones web (por ejemplo, mediante APIs REST). La exportaci\u00f3n e importaci\u00f3n de datos entre sistemas distintos. El almacenamiento estructurado de informaci\u00f3n, en ocasiones como alternativa ligera a una base de datos. A diferencia de los ficheros de texto plano , que se leen l\u00ednea a l\u00ednea como cadenas sin estructura interna definida, o de los ficheros binarios , que contienen datos codificados que requieren conocer su formato exacto para ser interpretados, estos formatos poseen una estructura interna estandarizada y legible, lo que requiere un enfoque diferente para acceder a su contenido. El acceso y procesamiento de estos ficheros se basa en parsear (analizar) su contenido utilizando librer\u00edas espec\u00edficas . Cada formato tiene caracter\u00edsticas que lo hacen adecuado para determinados contextos: CSV : simple, muy legible y eficiente para representar datos tabulares (como hojas de c\u00e1lculo). JSON : ligero, f\u00e1cil de leer y escribir, ideal para estructuras de datos jer\u00e1rquicas y ampliamente usado en servicios web modernos. XML : muy estructurado y extensible, adecuado cuando se necesita validar datos o integrar con sistemas complejos y est\u00e1ndares empresariales. Antes de abordar la conversi\u00f3n entre formatos como JSON, XML o CSV, es esencial comprender el concepto de serializaci\u00f3n de objetos . En programaci\u00f3n, la serializaci\u00f3n es el proceso mediante el cual un objeto en memoria \u2014con sus propiedades y valores\u2014 se transforma en una representaci\u00f3n textual o binaria que puede ser almacenada en un fichero o transmitida a trav\u00e9s de una red. La mayor\u00eda de las operaciones de lectura o escritura en estos formatos no trabajan directamente con texto, sino con objetos. Por ejemplo, al guardar informaci\u00f3n en JSON, no escribimos el fichero l\u00ednea a l\u00ednea, sino que serializamos un objeto Kotlin (o Java, Python, etc.) a ese formato. Del mismo modo, al leer un archivo XML o CSV, deserializamos su contenido para reconstruir objetos que podamos usar en la aplicaci\u00f3n. Comprender c\u00f3mo funciona la serializaci\u00f3n y qu\u00e9 herramientas proporciona el lenguaje para ello (como kotlinx.serialization, Jackson o Gson en Kotlin/Java) es clave para que la conversi\u00f3n entre formatos no sea un proceso manual y tedioso, sino autom\u00e1tico, controlado y estructurado. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"\ud83d\udd39Introducci\u00f3n"},{"location":"T3_Formatos_diferentes/intro/#introduccion","text":"En el desarrollo de software, especialmente en aplicaciones que gestionan informaci\u00f3n o se comunican entre sistemas, es fundamental contar con formatos est\u00e1ndar para el intercambio de datos. Entre los m\u00e1s utilizados destacan JSON (JavaScript Object Notation), XML (eXtensible Markup Language) y CSV (Comma-Separated Values). Estos formatos permiten que los datos puedan ser almacenados, transmitidos y compartidos entre diferentes aplicaciones, plataformas o lenguajes de programaci\u00f3n de forma estructurada y comprensible. Su uso se ha convertido en una pr\u00e1ctica habitual en \u00e1mbitos como: La comunicaci\u00f3n entre aplicaciones web (por ejemplo, mediante APIs REST). La exportaci\u00f3n e importaci\u00f3n de datos entre sistemas distintos. El almacenamiento estructurado de informaci\u00f3n, en ocasiones como alternativa ligera a una base de datos. A diferencia de los ficheros de texto plano , que se leen l\u00ednea a l\u00ednea como cadenas sin estructura interna definida, o de los ficheros binarios , que contienen datos codificados que requieren conocer su formato exacto para ser interpretados, estos formatos poseen una estructura interna estandarizada y legible, lo que requiere un enfoque diferente para acceder a su contenido. El acceso y procesamiento de estos ficheros se basa en parsear (analizar) su contenido utilizando librer\u00edas espec\u00edficas . Cada formato tiene caracter\u00edsticas que lo hacen adecuado para determinados contextos: CSV : simple, muy legible y eficiente para representar datos tabulares (como hojas de c\u00e1lculo). JSON : ligero, f\u00e1cil de leer y escribir, ideal para estructuras de datos jer\u00e1rquicas y ampliamente usado en servicios web modernos. XML : muy estructurado y extensible, adecuado cuando se necesita validar datos o integrar con sistemas complejos y est\u00e1ndares empresariales. Antes de abordar la conversi\u00f3n entre formatos como JSON, XML o CSV, es esencial comprender el concepto de serializaci\u00f3n de objetos . En programaci\u00f3n, la serializaci\u00f3n es el proceso mediante el cual un objeto en memoria \u2014con sus propiedades y valores\u2014 se transforma en una representaci\u00f3n textual o binaria que puede ser almacenada en un fichero o transmitida a trav\u00e9s de una red. La mayor\u00eda de las operaciones de lectura o escritura en estos formatos no trabajan directamente con texto, sino con objetos. Por ejemplo, al guardar informaci\u00f3n en JSON, no escribimos el fichero l\u00ednea a l\u00ednea, sino que serializamos un objeto Kotlin (o Java, Python, etc.) a ese formato. Del mismo modo, al leer un archivo XML o CSV, deserializamos su contenido para reconstruir objetos que podamos usar en la aplicaci\u00f3n. Comprender c\u00f3mo funciona la serializaci\u00f3n y qu\u00e9 herramientas proporciona el lenguaje para ello (como kotlinx.serialization, Jackson o Gson en Kotlin/Java) es clave para que la conversi\u00f3n entre formatos no sea un proceso manual y tedioso, sino autom\u00e1tico, controlado y estructurado. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"Introducci\u00f3n"},{"location":"T3_Formatos_diferentes/seriaci_dobjectes/","text":"3.- Serializaci\u00f3n de Objetos La serializaci\u00f3n de objetos en Java es el proceso de convertir un objeto java en una secuencia de bytes, con el fin de guardarlo en un archivo o base de datos. La deserializaci\u00f3n es el proceso inverso: leer esos bytes y reconstruir el objeto. Para que un objeto pueda ser seriado es necesario que su clase y todo su contenido implementan la interfaz Serializable . Se trata de una interfaz sin m\u00e9todos, porque el \u00fanico objetivo de la interfaz es actuar de marcador para indicar en la m\u00e1quina virtual qu\u00e9 clases se pueden seriar y cu\u00e1les no. Todas las clases equivalentes a los tipos b\u00e1sicos ya implementan serializable. Tambi\u00e9n implementan esta interfaz la clase String y todos los contenedores y los objetos Array. La seriaci\u00f3n de colecciones depende en \u00faltimo t\u00e9rmino de los elementos contenidos. Si \u00e9stos son seriables, la colecci\u00f3n tambi\u00e9n lo ser\u00e1. En caso de que la clase del objeto que se intente seriar, o las de alguno de los objetos que contenga, no implementaran la interfaz Serializable, se lanzar\u00eda una excepci\u00f3n de tipos NotSerializableException , impidiendo el almacenamiento. Kotlin no proporciona ninguna librer\u00eda adicional para serializar objetos java. Utiliza exactamente el mismo sistema de serializaci\u00f3n binaria de Java, ya que es 100% compatible. Clases y herramientas que se utilizan Herramienta Uso principal java.io.Serializable Marca que un objeto es serializable ObjectOutputStream Serializa y escribe un objeto ObjectInputStream Lee un objeto serializado transient Excluye atributos de la serializaci\u00f3n ReadObject Lee y reconstruye un objeto binario WriteObject Guarda un objeto como binario Nota La serializaci\u00f3n en java sigue necesitando usar las clases de java.io (ObjectOutputStream, ObjectInputStream) porque java.nio no proporciona soporte directo para serializaci\u00f3n de objetos. Con java.nio.file.Files y Paths puedes usar Files para escribir directamente un ByteArray generado con la serializaci\u00f3n tradicional. Los Streams ObjectInputStream y ObjectOutputStream a\u00f1aden a cualquier otro Stream la capacidad de seriar cualquier objeto Serializable. El stream de salida dispondr\u00e1 del m\u00e9todo writeObject y el stream de entrada, el m\u00e9todo de lectura readObject . El m\u00e9todo readObject s\u00f3lo permite recuperar instancias que sean de la misma clase que la que se guard\u00f3. De lo contrario, se lanzar\u00eda una excepci\u00f3n de tipos ClassCastExeception . Adem\u00e1s, es necesario que la aplicaci\u00f3n disponga del c\u00f3digo compilado de la clase; si no fuera as\u00ed, la excepci\u00f3n lanzada ser\u00eda ClassNotFoundException . Ejemplos Los ejemplos de esta parte se incluir\u00e1n en el paquete formatos , dentro de nuestro proyecto Ficheros . Los pasos para serializar un objeto java (kotlin) son los siguientes: \ud83d\udda5\ufe0f 1. Persona.kt : Crear una clase serializable import java.io.Serializable class Persona(val nombre: String, val edad: Int) : Serializable \ud83d\udda5\ufe0f 2. Ejemplo_guardar_persona.kt : Serializar un objeto a un archivo import java.io.ObjectOutputStream import java.nio.file.Files import java.nio.file.Paths fun main() { val persona = Persona(\"Alicia\", 30) val path = Paths.get(\"documentos/persona.obj\") val objectOut = ObjectOutputStream(Files.newOutputStream(path)) objectOut.writeObject(persona) objectOut.close() println(\"Objeto serializado correctamente.\") } \ud83d\udda5\ufe0f 3. Ejemplo_leer_persona.kt : Deserializar un objeto desde un archivo import java.io.ObjectInputStream import java.nio.file.Paths import java.nio.file.Files fun main() { val path = Paths.get(\"documentos/persona.obj\") val objectIn = ObjectInputStream(Files.newInputStream(path)) val persona= objectIn.readObject() as Persona objectIn.close() println(\"Objeto deserializado:\") println(\"Nombre: ${persona.nombre}, Edad: ${persona.edad}\") } @Transient Si hay atributos que no quieres guardar, usa el modificador @Transient Los atributos marcados como @Transient no se serializan, por lo que al deserializar el objeto el campo aparece con su valor por defecto, siendo null en el caso de tipos objeto. class Usuario( val nombre: String, @Transient val clave: String ) : Serializable Recomendaci\u00f3n: serialVersionUID serialVersionUID garantiza la compatibilidad de una clase serializable durante la deserializaci\u00f3n, evitando errores tanto cuando se modifica la definici\u00f3n de la clase como cuando el mismo c\u00f3digo se ejecuta en distintos entornos o versiones de Java. Si no se define expl\u00edcitamente, Java genera autom\u00e1ticamente un serialVersionUID que se guarda junto con el nombre del paquete y de la clase en el fichero serializado. Este identificador puede variar entre compilaciones, entornos o versiones de Java, lo que puede provocar errores al compartir los ficheros. Para evitarlo, es recomendable definir manualmente el serialVersionUID , asegurando la compatibilidad y permitiendo compartir objetos serializados incluso entre proyectos distintos o entre Java y Kotlin. La clase persona.kt quedar\u00eda as\u00ed: import java.io.Serializable class Persona(val nombre: String, val edad: Int) : Serializable { companion object { private const val serialVersionUID: Long = 1 } } Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"\ud83d\udd39Serializaci\u00f3n de Objetos"},{"location":"T3_Formatos_diferentes/seriaci_dobjectes/#3-serializacion-de-objetos","text":"La serializaci\u00f3n de objetos en Java es el proceso de convertir un objeto java en una secuencia de bytes, con el fin de guardarlo en un archivo o base de datos. La deserializaci\u00f3n es el proceso inverso: leer esos bytes y reconstruir el objeto. Para que un objeto pueda ser seriado es necesario que su clase y todo su contenido implementan la interfaz Serializable . Se trata de una interfaz sin m\u00e9todos, porque el \u00fanico objetivo de la interfaz es actuar de marcador para indicar en la m\u00e1quina virtual qu\u00e9 clases se pueden seriar y cu\u00e1les no. Todas las clases equivalentes a los tipos b\u00e1sicos ya implementan serializable. Tambi\u00e9n implementan esta interfaz la clase String y todos los contenedores y los objetos Array. La seriaci\u00f3n de colecciones depende en \u00faltimo t\u00e9rmino de los elementos contenidos. Si \u00e9stos son seriables, la colecci\u00f3n tambi\u00e9n lo ser\u00e1. En caso de que la clase del objeto que se intente seriar, o las de alguno de los objetos que contenga, no implementaran la interfaz Serializable, se lanzar\u00eda una excepci\u00f3n de tipos NotSerializableException , impidiendo el almacenamiento. Kotlin no proporciona ninguna librer\u00eda adicional para serializar objetos java. Utiliza exactamente el mismo sistema de serializaci\u00f3n binaria de Java, ya que es 100% compatible. Clases y herramientas que se utilizan Herramienta Uso principal java.io.Serializable Marca que un objeto es serializable ObjectOutputStream Serializa y escribe un objeto ObjectInputStream Lee un objeto serializado transient Excluye atributos de la serializaci\u00f3n ReadObject Lee y reconstruye un objeto binario WriteObject Guarda un objeto como binario Nota La serializaci\u00f3n en java sigue necesitando usar las clases de java.io (ObjectOutputStream, ObjectInputStream) porque java.nio no proporciona soporte directo para serializaci\u00f3n de objetos. Con java.nio.file.Files y Paths puedes usar Files para escribir directamente un ByteArray generado con la serializaci\u00f3n tradicional. Los Streams ObjectInputStream y ObjectOutputStream a\u00f1aden a cualquier otro Stream la capacidad de seriar cualquier objeto Serializable. El stream de salida dispondr\u00e1 del m\u00e9todo writeObject y el stream de entrada, el m\u00e9todo de lectura readObject . El m\u00e9todo readObject s\u00f3lo permite recuperar instancias que sean de la misma clase que la que se guard\u00f3. De lo contrario, se lanzar\u00eda una excepci\u00f3n de tipos ClassCastExeception . Adem\u00e1s, es necesario que la aplicaci\u00f3n disponga del c\u00f3digo compilado de la clase; si no fuera as\u00ed, la excepci\u00f3n lanzada ser\u00eda ClassNotFoundException . Ejemplos Los ejemplos de esta parte se incluir\u00e1n en el paquete formatos , dentro de nuestro proyecto Ficheros . Los pasos para serializar un objeto java (kotlin) son los siguientes: \ud83d\udda5\ufe0f 1. Persona.kt : Crear una clase serializable import java.io.Serializable class Persona(val nombre: String, val edad: Int) : Serializable \ud83d\udda5\ufe0f 2. Ejemplo_guardar_persona.kt : Serializar un objeto a un archivo import java.io.ObjectOutputStream import java.nio.file.Files import java.nio.file.Paths fun main() { val persona = Persona(\"Alicia\", 30) val path = Paths.get(\"documentos/persona.obj\") val objectOut = ObjectOutputStream(Files.newOutputStream(path)) objectOut.writeObject(persona) objectOut.close() println(\"Objeto serializado correctamente.\") } \ud83d\udda5\ufe0f 3. Ejemplo_leer_persona.kt : Deserializar un objeto desde un archivo import java.io.ObjectInputStream import java.nio.file.Paths import java.nio.file.Files fun main() { val path = Paths.get(\"documentos/persona.obj\") val objectIn = ObjectInputStream(Files.newInputStream(path)) val persona= objectIn.readObject() as Persona objectIn.close() println(\"Objeto deserializado:\") println(\"Nombre: ${persona.nombre}, Edad: ${persona.edad}\") } @Transient Si hay atributos que no quieres guardar, usa el modificador @Transient Los atributos marcados como @Transient no se serializan, por lo que al deserializar el objeto el campo aparece con su valor por defecto, siendo null en el caso de tipos objeto. class Usuario( val nombre: String, @Transient val clave: String ) : Serializable Recomendaci\u00f3n: serialVersionUID serialVersionUID garantiza la compatibilidad de una clase serializable durante la deserializaci\u00f3n, evitando errores tanto cuando se modifica la definici\u00f3n de la clase como cuando el mismo c\u00f3digo se ejecuta en distintos entornos o versiones de Java. Si no se define expl\u00edcitamente, Java genera autom\u00e1ticamente un serialVersionUID que se guarda junto con el nombre del paquete y de la clase en el fichero serializado. Este identificador puede variar entre compilaciones, entornos o versiones de Java, lo que puede provocar errores al compartir los ficheros. Para evitarlo, es recomendable definir manualmente el serialVersionUID , asegurando la compatibilidad y permitiendo compartir objetos serializados incluso entre proyectos distintos o entre Java y Kotlin. La clase persona.kt quedar\u00eda as\u00ed: import java.io.Serializable class Persona(val nombre: String, val edad: Int) : Serializable { companion object { private const val serialVersionUID: Long = 1 } } Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"3.- Serializaci\u00f3n de Objetos"}]}