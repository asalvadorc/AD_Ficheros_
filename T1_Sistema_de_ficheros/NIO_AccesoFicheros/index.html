<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>üîπ Acceso al sistema de ficheros. Java.nio - AD - Acceso a Datos - Ficheros</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
        <link href="../../css/extra.css" rel="stylesheet" />
        <link href="../../img/favicon.ico" rel="stylesheet" />
        <link href="../../css/copy-button.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "\ud83d\udd39 Acceso al sistema de ficheros. Java.nio";
        var mkdocs_page_input_path = "T1_Sistema_de_ficheros/NIO_AccesoFicheros.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../..">
          <img src="../../assets/logocaminas.png" class="logo" alt="Logo"/>
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../RA_CE/">RA y CE</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Sistema de ficheros</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../ficheros/">üîπ Ficheros</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="#">üîπ Acceso al sistema de ficheros. Java.nio</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#paths">üîπPaths</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#path">üîπPath</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#files">üîπFiles</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#filesystem">üîπFileSystem</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#basicfileattributes">üîπBasicFileAttributes</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#filestore">üîπFileStore</a>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../exercicis/">üìù Ejercicio obligatorio 1</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Manejo de ficheros</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../T2_Gestion_del_contenido/Formas_acceso/">üîπFormas de acceso a un fichero</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../T2_Gestion_del_contenido/clases/">üîπClases y m√©todos sobre ficheros. Java.nio</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../T2_Gestion_del_contenido/Lectura_Escritura_ficheros/">üîπLectura y escritura de ficheros</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Ficheros de diferentes formatos</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../T3_Formatos_diferentes/intro/">üîπIntroducci√≥n</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../T3_Formatos_diferentes/seriaci_dobjectes/">üîπSerializaci√≥n de Objetos</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../T3_Formatos_diferentes/ficheros_intercambio/">üîπFicheros de intercambio</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../T3_Formatos_diferentes/Conversion/">üîπConversi√≥n entre formatos diferentes</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../T3_Formatos_diferentes/ejercicios/">üìù Ejercicio obligatorio 2</a>
                  </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../Resumen/">Resumen</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">AD - Acceso a Datos - Ficheros</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" aria-label="Docs"></a></li>
          <li class="breadcrumb-item">Sistema de ficheros</li>
      <li class="breadcrumb-item active">üîπ Acceso al sistema de ficheros. Java.nio</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="acceso-al-sistema-de-ficheros-javanio">Acceso al sistema de ficheros. Java.nio</h1>
<div class="admonition warning">
<p class="admonition-title">Proyecto Ficheros</p>
<p>Para probar y organizar los ejemplos propuestos en esta parte del temario, crearemos en <strong>IntelliJ</strong> un proyecto llamado <strong>Ficheros</strong>.</p>
<p>Dentro de este proyecto crearemos tres paquetes (<strong>sistema</strong>, <strong>contenido</strong> y <strong>formatos</strong>) para organizar los diferentes ejemplos, que en cada ocasi√≥n se indicar√° en que paquete deben ubicarse.</p>
<p><img alt="Ref" src="../new_project.png" />|<img alt="Ref" src="../paquetes.png" /></p>
</div>
<p>Durante muchos a√±os se ha utilizado la librer√≠a <strong>java.io</strong> para trabajar con ficheros en el mundo Java. Se trata de un <strong>API</strong> muy potente y flexible que nos permite realizar casi cualquier tipo de operaci√≥n. Sin embargo es una API complicada de entender. <strong>Java.nio</strong> (New IO) es una nueva API disponible desde Java7 que nos permite mejorar el rendimiento, as√≠ como simplificar el manejo de muchas operaciones. </p>
<p><strong>Java.nio</strong> define interfaces y clases para que la m√°quina virtual Java tenga acceso a archivos, atributos de archivos y sistemas de archivos. Aunque dicho API comprende numerosas clases, solo existen unas pocas de ellas que sirven de puntos de entrada al API, lo que simplifica considerablemente su manejo.</p>
<p>La interfaz <strong>java.nio.file.Path</strong> representa un path, y las clases que implementen esta interfaz puede utilizarse para localizar ficheros en el sistema de ficheros. Nos permite manejar rutas al estilo GNU/Linux y rutas al estilo Windows dependiendo del SO en el que estemos trabajando.</p>
<p>La clase <strong>java.nio.file.Files</strong> es el otro punto de entrada a la librer√≠a de ficheros de Java. Es la que nos permite manejar ficheros reales del disco desde Java.</p>
<div class="admonition tip">
<p class="admonition-title">Clases para la gesit√≥n de ficheros</p>
<ul>
<li><strong>Paths</strong>: Crea objetos Path desde cadenas de texto</li>
<li><strong>Path</strong>: Representa rutas a archivos o directorios</li>
<li><strong>Files</strong>: Permite operaciones sobre archivos usando Path</li>
</ul>
</div>
<div class="admonition warning">
<p class="admonition-title">Ejemplos</p>
<p>Los siguientes ejemplos se incluir√°n en el paquete <strong>sistema</strong> dentro del proyecto <strong>Ficheros</strong>.  </p>
</div>
<h2 id="paths">üîπPaths</h2>
<p>La clase <strong>Paths</strong> es una clase de utilidad que proporciona m√©todos est√°ticos para crear objetos <strong>Path</strong>, que luego puedes usar con m√©todos de <strong>Files</strong>.</p>
<table>
<thead>
<tr>
<th>M√©todo</th>
<th>Descripci√≥n</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>get(String first, String... )</strong></td>
<td>Crea un objeto Path a partir de una o m√°s cadenas.</td>
</tr>
<tr>
<td><strong>get(URI uri)</strong></td>
<td>Crea un Path desde un URI que debe ser del esquema file:///.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p>El uso de <strong>Paths.get(...)</strong> en Java (o Kotlin) no implica que el archivo o directorio exista. Este m√©todo simplemente crea una instancia de Path que representa una ruta en el sistema de archivos, pero no accede al disco ni verifica su existencia.</p>
</div>
<p>üñ•Ô∏è <strong>Ejemplo_get.kt</strong></p>
<pre><code>    import java.nio.file.Path
    import java.nio.file.Paths

    fun main() {
        val path1: Path = Paths.get("documentos", "archivo.txt")
        val path2: Path = Paths.get("C:", "usuarios", "nombre", "archivo.txt")

        println("Ruta 1: $path1")
        println("Ruta 2: $path2")
    }
</code></pre>
<p>üñ•Ô∏è <strong>Ejemplo_uri.kt</strong></p>
<pre><code>    import java.net.URI
    import java.nio.file.Path
    import java.nio.file.Paths

    fun main() {
        val uri = URI("file:///C:/usuarios/nombre/archivo.txt")
        val path: Path = Paths.get(uri)

        println("Ruta a partir de URI: $path")
    }
</code></pre>
<h2 id="path">üîπPath</h2>
<p>La clase <strong>Path</strong> Se utiliza junto con la clase <strong>Files</strong> para realizar operaciones como lectura, escritura, copia, o eliminaci√≥n de archivos.<br />
La forma mas sencilla de construir un objeto que cumpla la interfaz <strong>Path</strong> es a partir de la clase <strong>java.nio.file.Paths</strong>, que tiene m√©todos est√°ticos que retornan objetos Path a partir de una representaci√≥n tipo String del path deseado.<br />
Por supuesto, no es necesario que los ficheros existan de verdad en el disco duro para que se puedan crear los objetos Path correspondientes.</p>
<p>Un objeto Path puede representarse de dos formas:</p>
<ul>
<li>
<p><strong>Ruta absoluta</strong>   </p>
<pre><code>val path = Paths.get("/home/usuario/archivo.txt")
</code></pre>
</li>
<li>
<p><strong>Ruta relativa</strong>   </p>
<pre><code>val path = Paths.get("documentos/ejemplo.txt")
println(path.toAbsolutePath())
</code></pre>
</li>
</ul>
<p>Las <strong>operaciones</strong> y <strong>m√©todos</strong> principales que se pueden hacer con Path son:</p>
<table>
<thead>
<tr>
<th><strong>M√©todo</strong></th>
<th><strong>Qu√© devuelve</strong></th>
<th><strong>Descripci√≥n</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>.startsWith(Path other)</td>
<td><code>Boolean</code></td>
<td>Devuelve <code>true</code> si el path empieza por el path dado.</td>
</tr>
<tr>
<td>.endsWith(Path other)</td>
<td><code>Boolean</code></td>
<td>Devuelve <code>true</code> si el path termina con el path dado.</td>
</tr>
<tr>
<td>.getParent()</td>
<td><code>Path?</code></td>
<td>Devuelve el path padre (superior) o <code>null</code> si no tiene.</td>
</tr>
<tr>
<td>.getRoot()</td>
<td><code>Path?</code></td>
<td>Devuelve el componente ra√≠z (<code>/</code>, <code>C:\</code>, etc.) o <code>null</code> si no existe.</td>
</tr>
<tr>
<td>.iterator()</td>
<td><code>Iterator&lt;Path&gt;</code></td>
<td>Permite iterar sobre cada parte del path (carpetas y nombre final).</td>
</tr>
<tr>
<td>.toString()</td>
<td><code>String</code></td>
<td>Devuelve el path como texto.</td>
</tr>
<tr>
<td>.toAbsolutePath()</td>
<td><code>Path</code></td>
<td>Devuelve el path completo desde la ra√≠z del sistema.</td>
</tr>
<tr>
<td>.resolve(Path/String)</td>
<td><code>Path</code></td>
<td>Une dos partes de un path de forma correcta, manejando barras autom√°ticamente.</td>
</tr>
<tr>
<td>.toFile()</td>
<td><code>java.io.File</code></td>
<td>Convierte el <code>Path</code> en un <code>File</code> de la API tradicional de Java (<code>java.io</code>).</td>
</tr>
</tbody>
</table>
<p>üñ•Ô∏è <strong>Ejemplo_Path.kt</strong></p>
<pre><code>    import java.nio.file.Path
    import java.nio.file.Paths

    fun main() {
        val path: Path = Paths.get("documentos/ejemplo.txt")

        println("toString(): ${path}")
        println("toAbsolutePath(): ${path.toAbsolutePath()}")
        println("getFileName(): ${path.fileName}")
        println("getParent(): ${path.parent}")
        println("getRoot(): ${path.root}")

        val otroPath: Path = Paths.get("imagenes/foto.png")
        println("resolve(): ${path.resolve(otroPath)}")

        val relativo: Path = path.relativize(Paths.get("documentos/otroArchivo.txt"))
        println("relativize(): $relativo")

        val rutaNormalizada: Path = Paths.get("carpeta/../archivo.txt").normalize()
        println("normalize(): $rutaNormalizada")

        println("startsWith(\"documentos\"): ${path.startsWith("documentos")}")
        println("endsWith(\"ejemplo.txt\"): ${path.endsWith("ejemplo.txt")}")
    }
</code></pre>
<h2 id="files">üîπFiles</h2>
<p>La clase <strong>Files</strong> es el otro punto de entrada a la librer√≠a de ficheros de Java. Es la que nos permite manejar ficheros reales del disco desde Java.<br />
Esta clase tiene m√©todos est√°ticos para el manejo de ficheros, los m√©todos de la clase <strong>Files</strong> trabajan sobre objetos <strong>Path</strong>. Muchos de estos m√©todos devuelven <strong>streams</strong>, lo que permite procesar archivos y directorios de forma eficiente y elegante. </p>
<p>En Java (y tambi√©n en Kotlin), un <strong>Stream</strong> es una secuencia de elementos que permite realizar operaciones funcionales (como map, filter, forEach, etc.) sobre datos de forma eficiente y fluida, sin necesidad de estructuras intermedias ni bucles expl√≠citos. Algunos m√©todo de <strong>Files</strong> utilizan o devuelven <strong>Streams</strong>.</p>
<p>Las <strong>operaciones</strong> y <strong>m√©todos</strong> principales a realizar con Files son:</p>
<table>
<thead>
<tr>
<th>M√©todo</th>
<th>Qu√© devuelve</th>
<th>Descripci√≥n</th>
</tr>
</thead>
<tbody>
<tr>
<td>list(Path)</td>
<td><code>Stream&lt;Path&gt;</code></td>
<td>Lista contenido directo (no recursivo) del directorio.</td>
</tr>
<tr>
<td>.walk(Path)</td>
<td><code>Stream&lt;Path&gt;</code></td>
<td>Recorre directorios de forma recursiva.</td>
</tr>
<tr>
<td>.find(...  )</td>
<td><code>Stream&lt;Path&gt;</code></td>
<td>Busca elementos que cumplan una condici√≥n.</td>
</tr>
<tr>
<td>.lines(Path)</td>
<td><code>Stream&lt;String&gt;</code></td>
<td>Devuelve las l√≠neas de un archivo de texto.</td>
</tr>
<tr>
<td>.exists(Path)</td>
<td><code>Boolean</code></td>
<td>Verifica si el archivo existe.</td>
</tr>
<tr>
<td>.isDirectory(Path)</td>
<td><code>Boolean</code></td>
<td>Verifica si es un directorio.</td>
</tr>
<tr>
<td>.isRegularFile(Path)</td>
<td><code>Boolean</code></td>
<td>Verifica si es un archivo normal.</td>
</tr>
<tr>
<td>.isReadable(Path)</td>
<td><code>Boolean</code></td>
<td>Verifica si se puede leer.</td>
</tr>
<tr>
<td>.createFile(Path)</td>
<td><code>Path</code></td>
<td>Crea un archivo vac√≠o.</td>
</tr>
<tr>
<td>.createDirectory(Path)</td>
<td><code>Path</code></td>
<td>Crea un directorio.</td>
</tr>
<tr>
<td>.createDirectories(Path)</td>
<td><code>Path</code></td>
<td>Crea directorios y subdirectorios necesarios.</td>
</tr>
<tr>
<td>.delete(Path)</td>
<td><code>void</code></td>
<td>Elimina un archivo o directorio.</td>
</tr>
<tr>
<td>.deleteIfExists(Path)</td>
<td><code>Boolean</code></td>
<td>Elimina si existe.</td>
</tr>
<tr>
<td>.move(Path, Path)</td>
<td><code>Path</code></td>
<td>Mueve un archivo o directorio.</td>
</tr>
<tr>
<td>.copy(Path, Path)</td>
<td><code>Path</code></td>
<td>Copia un archivo o directorio.</td>
</tr>
<tr>
<td>.size(Path)</td>
<td><code>Long</code></td>
<td>Tama√±o del archivo.</td>
</tr>
<tr>
<td>.getLastModifiedTime(Path)</td>
<td><code>FileTime</code></td>
<td>√öltima modificaci√≥n.</td>
</tr>
<tr>
<td>.getOwner(Path)</td>
<td><code>UserPrincipal</code></td>
<td>Devuelve el propietario.</td>
</tr>
<tr>
<td>.getAttribute(Path, String)</td>
<td><code>Object</code></td>
<td>Devuelve un atributo espec√≠fico.</td>
</tr>
</tbody>
</table>
<p>üñ•Ô∏è <strong>Ejemplo_permisos.kt</strong>: existencia y comprobaci√≥n de permisos</p>
<pre><code>    import java.nio.file.Path
    import java.nio.file.Paths
    import java.nio.file.Files

    fun main() {
        val path: Path = Paths.get("documentos/ejemplo.txt")

        println("path = $path")
        println("exists = ${Files.exists(path)}")
        println("readable = ${Files.isReadable(path)}")
        println("writable = ${Files.isWritable(path)}")
        println("executable = ${Files.isExecutable(path)}")
    }
</code></pre>
<p>üñ•Ô∏è <strong>Ejemplo_creardirectorio.kt</strong>: crear un directorio</p>
<pre><code>    import java.nio.file.Path
    import java.nio.file.Paths
    import java.nio.file.Files
    import java.nio.file.FileAlreadyExistsException
    import java.io.IOException

    fun main() {
        val path: Path = Paths.get("documentos")

        try {
            val newDir = Files.createDirectory(path)
            println("Directorio creado en: $newDir")
        } catch (e: FileAlreadyExistsException) {
            println("El directorio ya existe: $path")
        } catch (e: IOException) {
            println("Error de entrada/salida: ${e.message}")
            e.printStackTrace()
        }
    }
</code></pre>
<p>üñ•Ô∏è <strong>Ejemplo_borrardirectorio.kt</strong>: elimina un directorio</p>
<pre><code>    import java.nio.file.Files
    import java.nio.file.Path
    import java.nio.file.Paths

    fun main() {
        val directorio: Path = Paths.get("c:/mi_directorio")

        // Si ya existe, lo eliminamos
        if (Files.exists(directorio)) {
            println("El directorio ya existe. Borr√°ndolo...")
            Files.delete(directorio)
        }

    }
</code></pre>
<p><strong class="azul">Gesti√≥n de errores y validaciones</strong></p>
<p>El m√©todo  <strong>delete(Path)</strong> borra el fichero o directorio o lanza una excepci√≥n si el borrado falla. El siguiente ejemplo muestra como capturar y gestionar las excepciones que pueden producirse en el borrado. Si el fichero o directorio no existe, la excepci√≥n que se produce es  <strong>NoSuchFileException</strong>. Los sucesivos <strong>cath</strong> permiten determinar por  que ha fallado el borrado:</p>
<pre><code>    import java.nio.file.*
    import java.io.IOException

        fun main() {
            val path = Paths.get("c:/mi_directorio")
            try {
                Files.delete(path)
            } catch (e: NoSuchFileException) {
                System.err.printf("%s: no such file or directory%n", path)
            } catch (e: DirectoryNotEmptyException) {
                System.err.printf("%s not empty%n", path)
            } catch (e: IOException) {
                // Problemas de permisos u otros errores de E/S
                System.err.println("Error: ${e.message}")
            }
        }
</code></pre>
<div class="admonition warning">
<p>El metodo <strong>deleteIfExists(Path)</strong> tambien borra el fichero o directorio, pero no lanza ningun error en caso de que el fichero o directorio no exista.</p>
</div>
<p>üñ•Ô∏è <strong>Ejemplo_copiardirectorio.kt</strong>: copiar directorios</p>
<p>Se puede copiar un archivo o directorio usando el m√©todo copy(Path, Path, CopyOption...). La copia falla si el archivo de destino existe, a menos que se especifique la opci√≥n REPLACE_EXISTING. </p>
<p>Se puede copiar directorios aunque, los archivos dentro del directorio no se copian, por lo que el nuevo directorio est√° vac√≠o incluso cuando el directorio original contiene archivos.</p>
<pre><code>   import java.io.IOException
    import java.nio.file.FileAlreadyExistsException
    import java.nio.file.Files
    import java.nio.file.Path
    import java.nio.file.Paths
    // import java.nio.file.StandardCopyOption  // si se desea sobrescribir

    fun main() {
        val sourcePath: Path = Paths.get("documentos")
        val destinationPath: Path = Paths.get("documentos/destino")

        try {
            Files.copy(sourcePath, destinationPath)
            // Para sobrescribir si ya existe, descomenta la siguiente l√≠nea:
            // Files.copy(sourcePath, destinationPath, StandardCopyOption.REPLACE_EXISTING)

            println("Copia realizada con √©xito.")
        } catch (e: FileAlreadyExistsException) {
            println("El fichero o directorio ya existe en el destino.")
        } catch (e: IOException) {
            println("Error al copiar: ${e.message}")
            e.printStackTrace()
        }
    }
</code></pre>
<p>üñ•Ô∏è <strong>Ejemplo_copiarficheros.kt</strong>: copiar ficheros</p>
<pre><code>    import java.io.IOException
    import java.nio.file.FileAlreadyExistsException
    import java.nio.file.Files
    import java.nio.file.Path
    import java.nio.file.Paths
    import java.nio.file.StandardCopyOption

    fun main() {
        val sourcePath: Path = Paths.get("documentos/ejemplo.txt")
        val destinationPath: Path = Paths.get("documentos/ejemplo_copia.txt")

        try {
            Files.copy(sourcePath, destinationPath, StandardCopyOption.REPLACE_EXISTING)
            println("Archivo copiado correctamente a: $destinationPath")
        } catch (e: FileAlreadyExistsException) {
            println("El archivo destino ya existe.")
        } catch (e: IOException) {
            println(" Error al copiar el archivo: ${e.message}")
            e.printStackTrace()
        }
    }
</code></pre>
<p>üñ•Ô∏è <strong>Ejemplo_moverficheros.kt</strong>: mover ficheros y directorios cambiando el nombre.</p>
<pre><code>    import java.io.IOException
    import java.nio.file.FileAlreadyExistsException
    import java.nio.file.Files
    import java.nio.file.Path
    import java.nio.file.Paths
    import java.nio.file.StandardCopyOption

    fun main() {
        val sourcePath: Path = Paths.get("documentos/ejemplo.txt")
        val destinationPath: Path = Paths.get("documentos2/ejemplo2.txt")

        try {
            Files.move(sourcePath, destinationPath, StandardCopyOption.REPLACE_EXISTING)
            println("Archivo movido/renombrado correctamente a: $destinationPath")
        } catch (e: FileAlreadyExistsException) {
            println("El archivo destino ya existe.")
        } catch (e: IOException) {
            println("Error al mover el archivo: ${e.message}")
            e.printStackTrace()
        }
    }
</code></pre>
<p>El siguiente ejemplo recorre la estructura home en tu sistema, indicando los permisos de cada archivo y directorio: </p>
<p>üñ•Ô∏è <strong>Ejemplo_SistemaFicheros.kt</strong></p>
<pre><code>    import java.nio.file.*
    import java.nio.file.attribute.BasicFileAttributes
    import java.util.Scanner

    fun main() {
        val scanner = Scanner(System.`in`)
        var currentPath: Path = Paths.get(System.getProperty("user.home"))

        while (true) {
            println("\n Directorio actual: $currentPath")
            try {
                val paths = Files.list(currentPath).toList()
                paths.forEachIndexed { index, path -&gt;
                    val attrs = Files.readAttributes(path, BasicFileAttributes::class.java)
                    val tipo = when {
                        attrs.isDirectory -&gt; "[DIR]"
                        attrs.isRegularFile -&gt; "[FILE]"
                        else -&gt; "[OTRO]"
                    }

                    val permisos = listOfNotNull(
                        if (Files.isReadable(path)) "r" else null,
                        if (Files.isWritable(path)) "w" else null,
                        if (Files.isExecutable(path)) "x" else null
                    ).joinToString("")

                    val size = if (attrs.isRegularFile) "${attrs.size()} bytes" else ""

                    println("$index. $tipo ${path.fileName} [$permisos] $size")
                }

                println("\nOpciones:")
                println(" - N√∫mero: acceder a subdirectorio")
                println(" - `..`: subir al directorio padre")
                println(" - `salir`: finalizar el programa")
                print("Opci√≥n: ")

                when (val input = scanner.nextLine()) {
                    "salir" -&gt; {
                        println("Saliendo del explorador.")
                        return
                    }
                    ".." -&gt; {
                        currentPath = currentPath.parent ?: currentPath
                    }
                    else -&gt; {
                        val index = input.toIntOrNull()
                        if (index != null &amp;&amp; index in paths.indices) {
                            val selected = paths[index]
                            if (Files.isDirectory(selected)) {
                                currentPath = selected
                            } else {
                                println("No es un directorio.")
                            }
                        } else {
                            println("Entrada no v√°lida.")
                        }
                    }
                }

            } catch (e: Exception) {
                println("Error al acceder al directorio: ${e.message}")
            }
        }
    }
</code></pre>
<h2 id="filesystem">üîπFileSystem</h2>
<p>En la biblioteca <strong>java.nio</strong> podemos encontrar otras clases que complementan y ampl√≠an lo que se puede hacer con <strong>java.nio.file.Path</strong>.</p>
<p>El concepto de <strong>FileSystem</strong> define un <strong>sistema de ficheros completo</strong>. Mientras que por otro lado el concepto de <strong>Path</strong> hace referencia a un <strong>directorio, fichero o link</strong> que tengamos dentro de nuestro sistema de ficheros. </p>
<table>
<thead>
<tr>
<th>M√©todo</th>
<th>Qu√© devuelve</th>
<th>Descripci√≥n</th>
</tr>
</thead>
<tbody>
<tr>
<td>.getDefault()</td>
<td><code>FileSystem</code></td>
<td>Devuelve el sistema de ficheros por defecto del entorno en ejecuci√≥n.</td>
</tr>
<tr>
<td>.getSeparator()</td>
<td><code>String</code></td>
<td>Devuelve el separador de nombres de ruta (por ejemplo, <code>/</code> o <code>\</code>).</td>
</tr>
<tr>
<td>.getRootDirectories()</td>
<td><code>Iterable&lt;Path&gt;</code></td>
<td>Devuelve los directorios ra√≠z del sistema (ej: <code>/</code>, <code>C:\</code>).</td>
</tr>
<tr>
<td>.getFileStores()</td>
<td><code>Iterable&lt;FileStore&gt;</code></td>
<td>Devuelve las particiones o vol√∫menes montados en el sistema.</td>
</tr>
<tr>
<td>.getPath(...)</td>
<td><code>Path</code></td>
<td>Crea una instancia de <code>Path</code> a partir de cadenas de texto.</td>
</tr>
<tr>
<td>.provider()</td>
<td><code>FileSystemProvider</code></td>
<td>Devuelve el proveedor del sistema de archivos (ej. <code>UnixFileSystemProvider</code>).</td>
</tr>
</tbody>
</table>
<hr />
<p>Esto:</p>
<pre><code>val fileSystem = FileSystems.getDefault()
val path = fileSystem.getPath("C:\\Users\\alumno\\documento.txt")
</code></pre>
<p>Es equivalente a usar:</p>
<pre><code>val path = Paths.get("C:\\Users\\alumno\\documento.txt")
</code></pre>
<p>Pero usando FileSystems.getDefault() puedes:</p>
<ul>
<li>
<p>Cambiar de sistema de ficheros si lo necesitas (por ejemplo, ZIP o virtuales).</p>
</li>
<li>
<p>Obtener caracter√≠sticas del sistema.</p>
</li>
</ul>
<p>üñ•Ô∏è <strong>Ejemplo_FileSystem.kt</strong>: obtener el nombre de un fichero as√≠ como la carpeta padre en la que se encuentra ubicado.</p>
<pre><code>    import java.nio.file.FileSystems
    import java.nio.file.Path

    fun main() {
        val sistemaFicheros = FileSystems.getDefault()
        val rutaFichero: Path = sistemaFicheros.getPath("documentos/destino/ejemplo3.txt")

        println(rutaFichero.fileName)
        println(rutaFichero.parent.fileName)

        val rutaDirectorio: Path = sistemaFicheros.getPath("documentos/destino")
        val it = rutaDirectorio.iterator()

        while (it.hasNext()) {
            println(it.next().fileName)
        }
    }
</code></pre>
<h2 id="basicfileattributes">üîπBasicFileAttributes</h2>
<p>BasicFileAttributes permite obtener <strong>informaci√≥n detallada sobre archivos y directorios</strong>, como fecha de creaci√≥n, tama√±o, etc.</p>
<p>Para poder utilizar un objeto de tipo <strong>BasicFileAttributes</strong>, primero es necesario llamar al m√©todo <strong>readAttributes</strong>:</p>
<div class="admonition note">
<pre><code>val attr = Files.readAttributes(path, BasicFileAttributes::class.java)
</code></pre>
<ul>
<li>Este m√©todo pertenece a la clase <strong>Files</strong> y se encarga de leer los atributos asociados al archivo o directorio indicado por <strong>path</strong>.</li>
<li><strong>BasicFileAttributes::class.java:</strong> indica que queremos obtener los atributos b√°sicos definidos en esa clase.</li>
<li>El resultado (<strong>attr</strong>) es un objeto del tipo BasicFileAttributes.</li>
</ul>
</div>
<table>
<thead>
<tr>
<th>M√©todo</th>
<th>Descripci√≥n</th>
<th>Devuelve</th>
</tr>
</thead>
<tbody>
<tr>
<td>creationTime()</td>
<td>Devuelve la fecha de creaci√≥n del archivo.</td>
<td><code>FileTime</code></td>
</tr>
<tr>
<td>lastModifiedTime()</td>
<td>Devuelve la √∫ltima fecha de modificaci√≥n.</td>
<td><code>FileTime</code></td>
</tr>
<tr>
<td>size()</td>
<td>Devuelve el tama√±o del archivo en bytes.</td>
<td><code>Long</code></td>
</tr>
<tr>
<td>isDirectory()</td>
<td>Verifica si el <code>Path</code> representa un directorio.</td>
<td><code>Boolean</code></td>
</tr>
<tr>
<td>isRegularFile()</td>
<td>Verifica si es un archivo regular (no directorio).</td>
<td><code>Boolean</code></td>
</tr>
</tbody>
</table>
<p>üñ•Ô∏è <strong>Ejemplo_BasicFileAttributes.kt</strong>:  leer los atributos b√°sicos de un archivo o directorio.</p>
<pre><code>import java.nio.file.Files
import java.nio.file.Paths
import java.nio.file.attribute.BasicFileAttributes

fun main() {
    val path = Paths.get("documentos")

    if (Files.exists(path)) {
        val attr = Files.readAttributes(path, BasicFileAttributes::class.java)
        println("Creaci√≥n: ${attr.creationTime()}")
        println("√öltimo acceso: ${attr.lastAccessTime()}")
        println("Es un directorio: ${attr.isDirectory}")
        println("Tama√±o del archivo: ${attr.size()} bytes")
    }
}
</code></pre>
<h2 id="filestore">üîπFileStore</h2>
<p>FileStore permite obtener <strong>informaci√≥n sobre el sistema de archivos</strong>, como el espacio disponible.</p>
<p>No se puede instanciar un FileStore directamente. Para usarlo, necesitamos obtenerlo desde un Path (archivo o directorio)</p>
<pre><code>    val Store = Files.getFileStore(path)
</code></pre>
<table>
<thead>
<tr>
<th>M√©todo</th>
<th>Descripci√≥n</th>
<th>Devuelve</th>
</tr>
</thead>
<tbody>
<tr>
<td>name()</td>
<td>Nombre del volumen o unidad l√≥gica.</td>
<td><code>String</code></td>
</tr>
<tr>
<td>type()</td>
<td>Tipo de sistema de archivos (por ejemplo, <code>ext4</code>, <code>NTFS</code>, etc.).</td>
<td><code>String</code></td>
</tr>
<tr>
<td>getTotalSpace()</td>
<td>Espacio total disponible en el volumen (en bytes).</td>
<td><code>Long</code></td>
</tr>
<tr>
<td>getUsableSpace()</td>
<td>Espacio disponible para el usuario (en bytes).</td>
<td><code>Long</code></td>
</tr>
<tr>
<td>supportsFileAttributeView(...)</td>
<td>Verifica si el volumen soporta ciertos atributos como POSIX o DOS.</td>
<td><code>Boolean</code></td>
</tr>
</tbody>
</table>
<p>üñ•Ô∏è <strong>Ejemplo_FileStore.kt</strong>: obtener informaci√≥n del almacenamiento f√≠sico.</p>
<pre><code>import java.nio.file.FileStore
import java.nio.file.Files
import java.nio.file.Paths

fun main() {
    val path = Paths.get("/")
    val fileStore: FileStore = Files.getFileStore(path)

    println("Sistema de archivos: ${fileStore.type()}")
    println("Espacio total: ${fileStore.totalSpace / (1024 * 1024)} MB")
    println("Espacio disponible: ${fileStore.usableSpace / (1024 * 1024)} MB")
}
</code></pre>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Funciona en Windows y Linux, aunque Files.getFileStore(Paths.get("/")) podr√≠a requerir ajustes en Windows para seleccionar una unidad espec√≠fica (C:\, D:\, etc.).    </p>
</div>
<p><strong>EjemploCompleto_File.kt</strong> :El siguiente ejemplo utiliza todas estas funciones para mostrar informaci√≥n sobre el sistema de ficheros.</p>
<pre><code>    import java.io.File
    import java.nio.file.*
    import java.nio.file.attribute.BasicFileAttributes
    import java.nio.file.FileStore
    import java.nio.file.FileSystems

    fun main() {
        println(" Ra√≠ces del sistema:")
        File.listRoots().forEach { raiz -&gt;
            println("- ${raiz.absolutePath}")
        }

        println("\n Sistemas de archivos detectados:")
        val fileSystem: FileSystem = FileSystems.getDefault()
        fileSystem.fileStores.forEach { store: FileStore -&gt;
            println("Unidad: ${store.name()} (${store.type()})")
            println("Total: ${store.totalSpace / 1024 / 1024} MB")
            println("Libre: ${store.usableSpace / 1024 / 1024} MB")
        }

        // Usamos Path y Files para analizar un fichero concreto
        val path: Path = Paths.get("datos.txt")

        // Si el fichero existe, mostramos sus atributos
        if (Files.exists(path)) {
            println("\n Atributos del fichero '${path.fileName}':")
            val attrs: BasicFileAttributes = Files.readAttributes(path, BasicFileAttributes::class.java)

            println("Creaci√≥n: ${attrs.creationTime()}")
            println("√öltimo acceso: ${attrs.lastAccessTime()}")
            println("√öltima modificaci√≥n: ${attrs.lastModifiedTime()}")
            println("Tama√±o: ${attrs.size()} bytes")
            println("¬øEs directorio?: ${attrs.isDirectory}")
            println("¬øEs archivo normal?: ${attrs.isRegularFile}")
        } else {
            println("\n El fichero 'datos.txt' no existe en la ra√≠z del proyecto.")
        }
    }
</code></pre>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../ficheros/" class="btn btn-neutral float-left" title="üîπ Ficheros"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../exercicis/" class="btn btn-neutral float-right" title="üìù Ejercicio obligatorio 1">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../ficheros/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../exercicis/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../..";</script>
    <script src="../../js/theme_extra.js"></script>
    <script src="../../js/theme.js"></script>
      <script src="../../js/copy-button.js"></script>
      <script src="../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
